# 1 "/var/folders/cn/5z8pptpn6ljclwqzcy8kttrw0000gn/T/tmpqd_1g3sk"
#include <Arduino.h>
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/ESPEasy.ino"

#ifdef CONTINUOUS_INTEGRATION
#pragma GCC diagnostic error "-Wall"
#else
#pragma GCC diagnostic warning "-Wall"
#endif




#include "ESPEasy_common.h"

#ifdef USE_CUSTOM_H


  # warning "**** Using Settings from Custom.h File ***"
#endif



#ifdef PLUGIN_SET_GENERIC_ESP32
  # ifndef ESP32
    # define ESP32
  # endif
#endif
# 97 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/ESPEasy.ino"
#include "ESPEasy-Globals.h"


#include "_Plugin_Helper.h"


#include "src/Helpers/_CPlugin_Helper.h"


#include "src/ESPEasyCore/ESPEasy_setup.h"
#include "src/ESPEasyCore/ESPEasy_loop.h"


#ifdef PHASE_LOCKED_WAVEFORM
# include <core_esp8266_waveform.h>
#endif

#if FEATURE_ADC_VCC
ADC_MODE(ADC_VCC);
#endif



#ifdef CORE_POST_2_5_0




void preinit();
void preinit() {
  system_phy_set_powerup_option(3);




  #ifndef CORE_POST_3_0_0

  #endif





}

#endif
void setup();
void loop();
uint8_t P001_getSwitchType(struct EventStruct *event);
boolean Plugin_001(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_002(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_003(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_004(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_005(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_006(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_007(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_008(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_009(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_010(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_011(uint8_t function, struct EventStruct *event, String& string);
int Plugin_011_Read(uint8_t Par1, uint8_t Par2);
void Plugin_011_Write(uint8_t Par1, uint8_t Par2);
boolean Plugin_012(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_013(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_014(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_015(uint8_t function, struct EventStruct *event, String& string);
void P016_infoLogMemory(const __FlashStringHelper *text);
boolean Plugin_016(uint8_t function, struct EventStruct *event, String& string);
unsigned int storeB32Hex(char out[], unsigned int iOut, unsigned int val);
void enableIR_RX(boolean enable);
boolean Plugin_017(uint8_t function, struct EventStruct *event, String& string);
uint8_t Plugin_017_readPassiveTargetID(uint8_t *uid, uint8_t *uidLength);
int8_t Plugin_017_writeCommand(const uint8_t *header, uint8_t hlen);
int16_t Plugin_017_readResponse(uint8_t command, uint8_t buf[], uint8_t len);
int8_t Plugin_017_readAckFrame();
boolean Plugin_018(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_019(uint8_t function, struct EventStruct *event, String& string);
int8_t Plugin_019_Read(uint8_t Par1);
uint8_t Plugin_019_ReadAllPins(uint8_t address);
boolean Plugin_019_Write(uint8_t Par1, uint8_t Par2);
boolean Plugin_044(uint8_t function, struct EventStruct *event, String& string);
bool P020_ConvertP044Settings(struct EventStruct *event);
boolean Plugin_020(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_021(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_022(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_023(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_024(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_025(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_026(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_027(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_028(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_029(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_031(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_032(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_033(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_034(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_035(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_036(uint8_t function, struct EventStruct *event, String& string);
String P037_getMQTTLastTopicPart(const String& topic);
bool P037_addEventToQueue(struct EventStruct *event, String& newEvent);
boolean Plugin_037(uint8_t function, struct EventStruct *event, String& string);
bool MQTTCheckSubscription_037(const String& Topic, const String& Subscription);
boolean Plugin_038(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_039(uint8_t function, struct EventStruct *event, String& string);
float readMax6675(struct EventStruct *event);
float readMax31855(struct EventStruct *event);
float readMax31856(struct EventStruct *event);
float readMax31865(struct EventStruct *event);
void MAX31865_clearFaults(int8_t l_CS_pin_no);
void MAX31865_setConType(int8_t l_CS_pin_no, uint8_t l_conType);
float Plugin_039_convert_to_temperature(uint32_t l_rawvalue, float RTDnominal, float refResistor);
uint16_t getNomResistor(uint8_t l_RType);
int Plugin_039_convert_two_complement(uint32_t value, int nr_bits);
float readLM7x(struct EventStruct *event);
float convertLM7xTemp(uint16_t l_rawValue, uint16_t l_LM7xsubtype);
uint16_t readLM7xRegisters(int8_t l_CS_pin_no, uint8_t l_LM7xsubType, uint8_t l_runMode, uint16_t *l_device_id);
int get_SPI_CS_Pin(struct EventStruct *event);
void init_SPI_CS_Pin(int8_t l_CS_pin_no);
void handle_SPI_CS_Pin(int8_t l_CS_pin_no, bool l_state);
void write8BitRegister(int8_t l_CS_pin_no, uint8_t l_address, uint8_t value);
void write16BitRegister(int8_t l_CS_pin_no, uint8_t l_address, uint16_t value);
uint8_t read8BitRegister(int8_t l_CS_pin_no, uint8_t l_address);
uint16_t read16BitRegister(int8_t l_CS_pin_no, uint8_t l_address);
void transfer_n_ByteSPI(int8_t l_CS_pin_no, uint8_t l_noBytesToSend, uint8_t *l_inoutMessageBuffer);
void change16BitRegister(int8_t l_CS_pin_no, uint8_t l_readaddress, uint8_t l_writeaddress, uint16_t l_flagmask, bool l_set_reset);
void change8BitRegister(int8_t l_CS_pin_no, uint8_t l_readaddress, uint8_t l_writeaddress, uint8_t l_flagmask, bool l_set_reset);
boolean Plugin_040(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_041(uint8_t function, struct EventStruct *event, String& string);
void Plugin_041_update();
void resetAndBlack();
void pushToStrip(int ledId);
void timeToStrip(uint8_t hours, uint8_t minutes);
void pushToStrip(const int *ids, size_t count);
void pushM_ONE();
void pushM_TWO();
void pushM_THREE();
void pushM_FOUR();
void pushIT_IS();
void pushAFTER();
void pushQUATER();
void pushFOR();
void pushHALF();
void pushONE();
void pushTWO();
void pushTHREE();
void pushFOUR();
void pushFIVE1();
void pushFIVE2();
void pushSIX();
void pushSEVEN();
void pushEIGHT();
void pushNINE();
void pushTEN();
void pushTEN1();
void pushELEVEN();
void pushTWELVE();
void pushTWENTY();
void pushHOURE();
boolean Plugin_042(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_043(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_044(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_045(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_046(uint8_t function, struct EventStruct *event, String& string);
void Plugin_046_ISR_nSEL();
void Plugin_046_ISR_SCLK();
boolean Plugin_047(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_048(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_049(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_050(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_051(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_052(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_053(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_054(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_055(uint8_t function, struct EventStruct *event, String& string);
void Plugin_055_WriteFIFO(char c);
char Plugin_055_ReadFIFO();
char Plugin_055_PeekFIFO();
boolean Plugin_055_IsEmptyFIFO();
void Plugin_055_AddStringFIFO(const String& param);
void Plugin_055_WriteChime(const String& name, const String& tokens);
uint8_t Plugin_055_ReadChime(const String& name, String& tokens);
boolean Plugin_056(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_056_hasTxPin(struct EventStruct *event);
String Plugin_056_ErrorToString(int error);
String Plugin_056_WorkingPeriodToString(int workingPeriod);
void Plugin_056_setWorkingPeriod(int minutes);
boolean Plugin_057(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_058(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_059(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_060(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_061(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_062(uint8_t function, struct EventStruct *event, String& string);
uint16_t readTTP229(int16_t pinSCL, int16_t pinSDO);
boolean Plugin_063(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_064(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_065(uint8_t function, struct EventStruct *event, String& string);
void Plugin_065_Play(uint16_t track);
void Plugin_065_SetVol(int8_t vol);
void Plugin_065_SetEQ(int8_t eq);
void Plugin_065_SetMode(int8_t mode);
void Plugin_065_SetRepeat(int8_t repeat);
void Plugin_065_SendCmd(uint8_t cmd, int16_t data);
boolean Plugin_066(uint8_t function, struct EventStruct *event, String& string);
void VEML6040_setControlReg(uint8_t data);
float VEML6040_GetValue(uint8_t reg);
void VEML6040_Init(uint8_t it);
float Plugin_066_CalcCCT(float R, float G, float B);
float Plugin_066_CalcAmbientLight(float G, uint8_t it);
float Plugin_066_CalcRelW(float X, float W);
boolean Plugin_067(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_068(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_069(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_070(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_071(uint8_t function, struct EventStruct *event, String& string);
bool parity_check(unsigned input);
boolean Plugin_072(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_073(uint8_t function, struct EventStruct *event, String& string);
bool p073_plugin_write(struct EventStruct *event,
                       const String & string);
bool p073_plugin_write_7dn(struct EventStruct *event,
                           const String & text);
bool p073_plugin_write_7dt(struct EventStruct *event,
                           const String & text);
bool p073_plugin_write_7ddt(struct EventStruct *event,
                            const String & text);
bool p073_plugin_write_7dst(struct EventStruct *event);
bool p073_plugin_write_7dsd(struct EventStruct *event);
bool p073_plugin_write_7dtext(struct EventStruct *event,
                              const String & text);
bool p073_plugin_write_7dfont(struct EventStruct *event,
                              const String & text);
bool p073_plugin_write_7dbin(struct EventStruct *event,
                             const String & text);
void tm1637_i2cStart(uint8_t clk_pin,
                     uint8_t dio_pin);
void tm1637_i2cStop(uint8_t clk_pin,
                    uint8_t dio_pin);
void tm1637_i2cAck(uint8_t clk_pin,
                   uint8_t dio_pin);
void tm1637_i2cWrite_ack(uint8_t clk_pin,
                         uint8_t dio_pin,
                         uint8_t bytesToPrint[],
                         uint8_t length);
void tm1637_i2cWrite_ack(uint8_t clk_pin,
                         uint8_t dio_pin,
                         uint8_t bytetoprint);
void tm1637_i2cWrite(uint8_t clk_pin,
                     uint8_t dio_pin,
                     uint8_t bytetoprint);
void tm1637_ClearDisplay(uint8_t clk_pin,
                         uint8_t dio_pin);
void tm1637_SetPowerBrightness(uint8_t clk_pin,
                               uint8_t dio_pin,
                               uint8_t brightlvl,
                               bool poweron);
void tm1637_InitDisplay(uint8_t clk_pin,
                        uint8_t dio_pin);
uint8_t tm1637_separator(uint8_t value,
                         bool sep);
void tm1637_ShowTime6(struct EventStruct *event);
void tm1637_ShowDate6(struct EventStruct *event, bool showTime);
void tm1637_ShowTemp6(struct EventStruct *event,
                      bool sep);
void tm1637_ShowTimeTemp4(struct EventStruct *event,
                          bool sep,
                          uint8_t bufoffset);
void tm1637_SwapDigitInBuffer(struct EventStruct *event,
                              uint8_t startPos);
void tm1637_ShowBuffer(struct EventStruct *event,
                       uint8_t firstPos,
                       uint8_t lastPos,
                       bool useBinaryData);
void max7219_ClearDisplay(struct EventStruct *event,
                          uint8_t din_pin,
                          uint8_t clk_pin,
                          uint8_t cs_pin);
void max7219_SetPowerBrightness(struct EventStruct *event,
                                uint8_t din_pin,
                                uint8_t clk_pin,
                                uint8_t cs_pin,
                                uint8_t brightlvl,
                                bool poweron);
void max7219_InitDisplay(struct EventStruct *event,
                         uint8_t din_pin,
                         uint8_t clk_pin,
                         uint8_t cs_pin);
void max7219_ShowTime(struct EventStruct *event,
                      uint8_t din_pin,
                      uint8_t clk_pin,
                      uint8_t cs_pin,
                      bool sep);
void max7219_ShowTemp(struct EventStruct *event,
                      uint8_t din_pin,
                      uint8_t clk_pin,
                      uint8_t cs_pin,
                      int8_t firstDot,
                      int8_t secondDot);
void max7219_ShowDate(struct EventStruct *event,
                      uint8_t din_pin,
                      uint8_t clk_pin,
                      uint8_t cs_pin);
void max7219_ShowBuffer(struct EventStruct *event,
                        uint8_t din_pin,
                        uint8_t clk_pin,
                        uint8_t cs_pin);
boolean Plugin_074(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_075(uint8_t function, struct EventStruct *event, String& string);
void P075_sendCommand(taskIndex_t taskIndex, const char *cmd);
bool p076_getDeviceParameters(int device,
                              uint8_t& SEL_Pin,
                              uint8_t& CF_Pin,
                              uint8_t& CF1_Pin,
                              uint8_t& Cur_read,
                              uint8_t& CF_Trigger,
                              uint8_t& CF1_Trigger);
boolean Plugin_076(uint8_t function, struct EventStruct *event, String& string);
void Plugin076_ResetMultipliers();
void Plugin076_SaveMultipliers();
bool Plugin076_ReadMultipliers(ESPEASY_RULES_FLOAT_TYPE& current, ESPEASY_RULES_FLOAT_TYPE& voltage, ESPEASY_RULES_FLOAT_TYPE& power);
bool Plugin076_LoadMultipliers(taskIndex_t TaskIndex, ESPEASY_RULES_FLOAT_TYPE& current, ESPEASY_RULES_FLOAT_TYPE& voltage, ESPEASY_RULES_FLOAT_TYPE& power);
void Plugin076_Reset(taskIndex_t TaskIndex);
boolean Plugin_077(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_078(uint8_t function, struct EventStruct *event, String& string);
int p078_storageValueToBaudrate(uint8_t baudrate_setting);
boolean Plugin_079(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_080(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_081(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_082(uint8_t function, struct EventStruct *event, String& string);
bool P082_referencePointSet(struct EventStruct *event);
void P082_setOutputValue(struct EventStruct *event, uint8_t outputType, float value);
void P082_logStats(struct EventStruct *event);
void P082_html_show_satStats(struct EventStruct *event, bool tracked, bool onlyGPS);
void P082_html_show_stats(struct EventStruct *event);
void P082_setSystemTime(struct EventStruct *event);
void Plugin_082_interrupt();
boolean Plugin_083(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_084(uint8_t function, struct EventStruct *event, String& string);
uint16_t VEML6070_ReadUv(bool *status);
bool VEML6070_Init(uint8_t it);
ESPEASY_RULES_FLOAT_TYPE VEML6070_UvRiskLevel(uint16_t uv_level);
ESPEASY_RULES_FLOAT_TYPE VEML6070_UvPower(ESPEASY_RULES_FLOAT_TYPE uvrisk);
boolean Plugin_085(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_086(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_087(uint8_t function, struct EventStruct *event, String& string);
bool Plugin_087_match_all(taskIndex_t taskIndex, String& received);
String Plugin_087_valuename(uint8_t value_nr, bool displayString);
void P087_html_show_matchForms(struct EventStruct *event);
void P087_html_show_stats(struct EventStruct *event);
boolean Plugin_088(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_089(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_090(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_091(uint8_t function, struct EventStruct *event, String& string);
void getmcustate();
void sendmcucommand(uint8_t btnnum, uint8_t state, uint8_t swtype, uint8_t btnum_mode);
void sendmcudim(uint8_t dimvalue, uint8_t swtype);
boolean Plugin_092(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_093(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_094(uint8_t function, struct EventStruct *event, String& string);
bool Plugin_094_match_all(taskIndex_t taskIndex, const String& received);
String Plugin_094_valuename(uint8_t value_nr, bool displayString);
void P094_html_show_matchForms(struct EventStruct *event);
void P094_html_show_stats(struct EventStruct *event);
boolean Plugin_095(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_096(uint8_t function, struct EventStruct *event, String& string);
void Plugin_096_printText(const char *string, int X, int Y, unsigned int textSize, unsigned short color, unsigned short bkcolor);
unsigned short Plugin_096_ParseColor(const String& colorString);
void Plugin_096_FixText(String& s);
int Plugin_096_StringSplit(const String& s, char c, String op[], int limit);
boolean Plugin_097(uint8_t function, struct EventStruct *event, String& string);
void P097_setEventParams(int pin, uint16_t threshold);
void P097_got_T0();
void P097_got_T1();
void P097_got_T2();
void P097_got_T3();
void P097_got_T4();
void P097_got_T5();
void P097_got_T6();
void P097_got_T7();
void P097_got_T8();
void P097_got_T9();
void P097_got_T10();
void P097_got_T11();
void P097_got_T12();
void P097_got_T13();
void P097_got_T14();
boolean Plugin_098(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_099(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_100(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_101(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_102(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_103(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_104(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_105(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_106(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_107(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_108(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_109(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_110(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_111(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_112(uint8_t function, struct EventStruct *event, String& string);
void queueEvent(taskIndex_t TaskIndex, int wavelength, float value);
boolean Plugin_113(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_114(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_115(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_116(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_117(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_118(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_119(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_120(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_121(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_122(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_124(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_125(uint8_t function, struct EventStruct *event, String& string);
String P126_ul2stringFixed(uint32_t value, uint8_t base);
boolean Plugin_126(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_127(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_128(uint8_t function, struct EventStruct *event, String& string);
String P129_ul2stringFixed(uint32_t value, uint8_t base);
boolean Plugin_129(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_131(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_132(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_133(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_134(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_135(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_137(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_138(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_141(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_143(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_144(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_145(byte function, struct EventStruct *event, String& string);
boolean Plugin_146(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_147(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_148(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_150(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_151(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_152(uint8_t function, struct EventStruct *event, String& string);
bool P153_CheckIntervalError(struct EventStruct *event, int interval);
boolean Plugin_153(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_154(uint8_t function, struct EventStruct *event, String& string);
boolean Plugin_159(uint8_t function, struct EventStruct *event, String& string);
void ReportStatus();
#line 145 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/ESPEasy.ino"
void setup() {
  ESPEasy_setup();
}

void loop() {
  ESPEasy_loop();
}
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P001_Switch.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P001

# include "src/DataStructs/PinMode.h"
# include "src/ESPEasyCore/Controller.h"
# include "src/ESPEasyCore/ESPEasyGPIO.h"
# include "src/Helpers/_Plugin_Helper_webform.h"
# include "src/Helpers/PortStatus.h"
# include "src/Helpers/Scheduler.h"
# 41 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P001_Switch.ino"
#define PLUGIN_001 
#define PLUGIN_ID_001 1
#define PLUGIN_NAME_001 "Switch input - Switch"
#define PLUGIN_VALUENAME1_001 "State"


#define PLUGIN_001_TYPE_SWITCH 0
#define PLUGIN_001_TYPE_DIMMER 3
#define PLUGIN_001_BUTTON_TYPE_NORMAL_SWITCH 0
#define PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_LOW 1
#define PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_HIGH 2


#define P001_BOOTSTATE PCONFIG(3)
#define P001_DEBOUNCE PCONFIG_FLOAT(0)
#define P001_DOUBLECLICK PCONFIG(4)
#define P001_DC_MAX_INT PCONFIG_FLOAT(1)
#define P001_LONGPRESS PCONFIG(5)
#define P001_LP_MIN_INT PCONFIG_FLOAT(2)
#define P001_SAFE_BTN PCONFIG_FLOAT(3)


uint8_t P001_getSwitchType(struct EventStruct *event) {
  const uint8_t choice = PCONFIG(0);
  if (choice == 2 ||
      choice == PLUGIN_001_TYPE_DIMMER)
  {
    return PLUGIN_001_TYPE_DIMMER;
  }
  return PLUGIN_001_TYPE_SWITCH;
}

boolean Plugin_001(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;






  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_001;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = true;
      Device[deviceCount].InverseLogicOption = true;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_001);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_001));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {




      event->String1 = formatGpioName_bidirectional(F(""));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {

      const uint32_t key = createKey(PLUGIN_GPIO, CONFIG_PIN1);

      auto it = globalMapPortStatus.find(key);

      if (it != globalMapPortStatus.end()) {
        it->second.previousTask = event->TaskIndex;
      }

      {
        const __FlashStringHelper *options[2] = { F("Switch"), F("Dimmer") };
        int optionValues[2] = { PLUGIN_001_TYPE_SWITCH, PLUGIN_001_TYPE_DIMMER };
        const uint8_t switchtype = P001_getSwitchType(event);
        addFormSelector(F("Switch Type"), F("type"), 2, options, optionValues, switchtype);

        if (switchtype == PLUGIN_001_TYPE_DIMMER)
        {
          addFormNumericBox(F("Dim value"), F("dimvalue"), PCONFIG(1), 0, 255);
        }
      }

      {
        uint8_t choice = PCONFIG(2);
        const __FlashStringHelper *buttonOptions[3] = { F("Normal Switch"), F("Push Button Active Low"), F("Push Button Active High") };
        int buttonOptionValues[3] =
        { PLUGIN_001_BUTTON_TYPE_NORMAL_SWITCH, PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_LOW, PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_HIGH };
        addFormSelector(F("Switch Button Type"), F("button"), 3, buttonOptions, buttonOptionValues, choice);
      }

      SwitchWebformLoad(
        P001_BOOTSTATE,
        P001_DEBOUNCE,
        P001_DOUBLECLICK,
        P001_DC_MAX_INT,
        P001_LONGPRESS,
        P001_LP_MIN_INT,
        P001_SAFE_BTN);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("type"));

      if (PCONFIG(0) == PLUGIN_001_TYPE_DIMMER)
      {
        PCONFIG(1) = getFormItemInt(F("dimvalue"));
      }

      PCONFIG(2) = getFormItemInt(F("button"));

      SwitchWebformSave(
        event->TaskIndex,
        PLUGIN_GPIO,
        P001_BOOTSTATE,
        P001_DEBOUNCE,
        P001_DOUBLECLICK,
        P001_DC_MAX_INT,
        P001_LONGPRESS,
        P001_LP_MIN_INT,
        P001_SAFE_BTN);

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {

      if (validGpio(CONFIG_PIN1))
      {
        portStatusStruct newStatus;
        const uint32_t key = createKey(PLUGIN_GPIO, CONFIG_PIN1);


        newStatus = globalMapPortStatus[key];


        newStatus.state = GPIO_Read_Switch_State(event);
        newStatus.output = newStatus.state;
        (newStatus.task < 3) ? newStatus.task++ : newStatus.task = 3;



        if (Settings.TaskDevicePin1PullUp[event->TaskIndex]) {
          setInternalGPIOPullupMode(CONFIG_PIN1);
          newStatus.mode = PIN_MODE_INPUT_PULLUP;
        } else {
          pinMode(CONFIG_PIN1, INPUT);
          newStatus.mode = PIN_MODE_INPUT;
        }



        if (P001_BOOTSTATE)
        {
          newStatus.state = !newStatus.state;
          newStatus.output = !newStatus.output;
        }
        savePortStatus(key, newStatus);


        if (Settings.TaskDevicePin1Inversed[event->TaskIndex]) {
          UserVar.setFloat(event->TaskIndex, 0, !newStatus.state);
        } else {
          UserVar.setFloat(event->TaskIndex, 0, newStatus.state);
        }


        PCONFIG(7) = 0;
        PCONFIG_LONG(3) = 0;


        PCONFIG(6) = 0;

        {

          const unsigned long cur_millis = millis();
          PCONFIG_LONG(0) = cur_millis;
          PCONFIG_LONG(1) = cur_millis;
          PCONFIG_LONG(2) = cur_millis;
        }


        if (P001_DC_MAX_INT < SWITCH_DOUBLECLICK_MIN_INTERVAL) {
          P001_DC_MAX_INT = SWITCH_DOUBLECLICK_MIN_INTERVAL;
        }


        if (P001_LP_MIN_INT < SWITCH_LONGPRESS_MIN_INTERVAL) {
          P001_LP_MIN_INT = SWITCH_LONGPRESS_MIN_INTERVAL;
        }
        success = true;
      }
      break;
    }
# 337 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P001_Switch.ino"
    case PLUGIN_TEN_PER_SECOND:
    {
# 359 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P001_Switch.ino"
      const __FlashStringHelper *monitorEventString = F("GPIO");

      if (validGpio(CONFIG_PIN1))
      {
        const uint32_t key = createKey(PLUGIN_GPIO, CONFIG_PIN1);


        portStatusStruct currentStatus = globalMapPortStatus[key];

        const int8_t state = GPIO_Read_Switch_State(CONFIG_PIN1, currentStatus.mode);





        if (lround(P001_SAFE_BTN) && (state != currentStatus.state) && (PCONFIG_LONG(3) == 0))
        {
  # ifndef BUILD_NO_DEBUG
          addLog(LOG_LEVEL_DEBUG, F("SW  : 1st click"));
  # endif
          PCONFIG_LONG(3) = 1;
        }


        else if ((state != currentStatus.state) || currentStatus.forceEvent)
        {

          PCONFIG_LONG(3) = 0;


          PCONFIG_LONG(2) = millis();
          PCONFIG(6) = 0;

          const unsigned long debounceTime = timePassedSince(PCONFIG_LONG(0));

          if (debounceTime >= (unsigned long)lround(P001_DEBOUNCE))
          {
            const unsigned long deltaDC = timePassedSince(PCONFIG_LONG(1));

            if ((deltaDC >= (unsigned long)lround(P001_DC_MAX_INT)) ||
                (PCONFIG(7) == 3))
            {

              PCONFIG(7) = 0;
              PCONFIG_LONG(1) = millis();
            }


    # define COUNTER PCONFIG(7)
    # define DC P001_DOUBLECLICK


            if ((COUNTER != 0) || ((COUNTER == 0) && ((DC == 3) || ((DC == 1) && (state == 0)) || ((DC == 2) && (state == 1))))) {
              PCONFIG(7)++;
            }
    # undef DC
    # undef COUNTER

            currentStatus.state = state;
            const boolean currentOutputState = currentStatus.output;
            boolean new_outputState = currentOutputState;

            switch (PCONFIG(2))
            {
              case PLUGIN_001_BUTTON_TYPE_NORMAL_SWITCH:
                new_outputState = state;
                break;
              case PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_LOW:

                if (!state) {
                  new_outputState = !currentOutputState;
                }
                break;
              case PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_HIGH:

                if (state) {
                  new_outputState = !currentOutputState;
                }
                break;
            }


            if ((currentOutputState != new_outputState) || currentStatus.forceEvent)
            {
              uint8_t output_value;
              currentStatus.output = new_outputState;
              boolean sendState = new_outputState;

              if (Settings.TaskDevicePin1Inversed[event->TaskIndex]) {
                sendState = !sendState;
              }

              if ((PCONFIG(7) == 3) && (P001_DOUBLECLICK > 0))
              {
                output_value = 3;
              } else {
                output_value = sendState ? 1 : 0;
              }
              event->sensorType = Sensor_VType::SENSOR_TYPE_SWITCH;

              if (P001_getSwitchType(event) == PLUGIN_001_TYPE_DIMMER) {
                if (sendState) {
                  output_value = PCONFIG(1);


                  event->sensorType = Sensor_VType::SENSOR_TYPE_DIMMER;
                }
              }
              UserVar.setFloat(event->TaskIndex, 0, output_value);

                # ifndef BUILD_NO_DEBUG

              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                addLogMove(LOG_LEVEL_INFO,
                  concat(F("SW  : GPIO="), static_cast<int>(CONFIG_PIN1)) +
                  concat(F(" State="), state ? '1' : '0') +
                  concat(output_value == 3 ? F(" Doubleclick=") : F(" Output value="), static_cast<int>(output_value)));
              }
                # endif


              sendData(event);


              if (currentStatus.monitor) { sendMonitorEvent(monitorEventString, CONFIG_PIN1, output_value); }


              UserVar.setFloat(event->TaskIndex, 0, sendState ? 1 : 0);
            }
            PCONFIG_LONG(0) = millis();
          }


          currentStatus.forceEvent = 0;

          savePortStatus(key, currentStatus);
        }


    # define LP P001_LONGPRESS
    # define FIRED PCONFIG(6)



        else if (!FIRED && ((LP == 3) || ((LP == 1) && (state == 0)) || ((LP == 2) && (state == 1)))) {
    # undef LP
    # undef FIRED
# 522 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P001_Switch.ino"
          PCONFIG_LONG(3) = 0;

          const unsigned long deltaLP = timePassedSince(PCONFIG_LONG(2));

          if (deltaLP >= (unsigned long)lround(P001_LP_MIN_INT))
          {
            uint8_t output_value;
            bool needToSendEvent = false;

            PCONFIG(6) = 1;

            switch (PCONFIG(2))
            {
              case PLUGIN_001_BUTTON_TYPE_NORMAL_SWITCH:
                needToSendEvent = true;
                break;
              case PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_LOW:

                if (!state) {
                  needToSendEvent = true;
                }
                break;
              case PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_HIGH:

                if (state) {
                  needToSendEvent = true;
                }
                break;
            }

            if (needToSendEvent) {
              boolean sendState = state;

              if (Settings.TaskDevicePin1Inversed[event->TaskIndex]) {
                sendState = !sendState;
              }
              output_value = sendState ? 11 : 10;


              UserVar.setFloat(event->TaskIndex, 0, output_value);

                # ifndef BUILD_NO_DEBUG

              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                addLogMove(LOG_LEVEL_INFO,
                  concat(F("SW  : LongPress: GPIO= "), static_cast<int>(CONFIG_PIN1)) +
                  concat(F(" State="), state ? '1' : '0') +
                  concat(F(" Output value="), static_cast<int>(output_value)));
              }
                # endif


              sendData(event);


              if (currentStatus.monitor) { sendMonitorEvent(monitorEventString, CONFIG_PIN1, output_value); }


              UserVar.setFloat(event->TaskIndex, 0, sendState ? 1 : 0);
            }
            savePortStatus(key, currentStatus);
          }
        } else {
          if (PCONFIG_LONG(3) == 1) {
            const uint8_t SAFE_BUTTON_EVENT = 4;


            PCONFIG_LONG(3) = 0;


            const int tempUserVar = lround(UserVar[event->BaseVarIndex]);
            UserVar.setFloat(event->TaskIndex, 0, SAFE_BUTTON_EVENT);

              # ifndef BUILD_NO_DEBUG

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              addLogMove(LOG_LEVEL_INFO,
                concat(F("SW  : SafeButton: false positive detected. GPIO= "), CONFIG_PIN1) +
                concat(F(" State="), tempUserVar));
            }
              # endif




            if (currentStatus.monitor) { sendMonitorEvent(monitorEventString, CONFIG_PIN1, SAFE_BUTTON_EVENT); }


            UserVar.setFloat(event->TaskIndex, 0, tempUserVar);
          }
        }
# 637 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P001_Switch.ino"
      }
      success = true;
      break;
    }

    case PLUGIN_EXIT:
    {
      removeTaskFromPort(createKey(PLUGIN_GPIO, CONFIG_PIN1));
      break;
    }

    case PLUGIN_READ:
    {


      # ifndef BUILD_NO_DEBUG

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        addLogMove(LOG_LEVEL_INFO, concat(F("SW   : State "), static_cast<int>(UserVar[event->BaseVarIndex])));
      }
      # endif
      success = true;
      break;
    }

    case PLUGIN_TASKTIMER_IN:
    {
      digitalWrite(event->Par1, event->Par2);


      portStatusStruct tempStatus;


      const uint32_t key = createKey(PLUGIN_GPIO, event->Par1);
      tempStatus = globalMapPortStatus[key];

      tempStatus.state = event->Par2;
      tempStatus.mode = PIN_MODE_OUTPUT;


      tempStatus.forceMonitor = 1;
      savePortStatus(key, tempStatus);
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P002_ADC.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P002


# include "src/Helpers/Hardware.h"
# include "src/PluginStructs/P002_data_struct.h"





#define PLUGIN_002 
#define PLUGIN_ID_002 2
#define PLUGIN_NAME_002 "Analog input - internal"
#define PLUGIN_VALUENAME1_002 "Analog"


boolean Plugin_002(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_002;
      Device[deviceCount].Type = DEVICE_TYPE_ANALOG;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].TaskLogsOwnPeaks = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_002);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_002));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      P002_data_struct *P002_data =
        static_cast<P002_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P002_data) {
        P002_data->webformLoad(event);
        success = true;
      } else {
        P002_data = new (std::nothrow) P002_data_struct();

        if (nullptr != P002_data) {
          P002_data->init(event);
          P002_data->webformLoad(event);
          success = true;
          delete P002_data;
        }
      }
      break;
    }

# if FEATURE_PLUGIN_STATS
    case PLUGIN_WEBFORM_LOAD_SHOW_STATS:
    {
      P002_data_struct *P002_data =
        static_cast<P002_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P002_data) {
        success = P002_data->webformLoad_show_stats(event);
      }
      break;
    }
# endif

    case PLUGIN_WEBFORM_SAVE:
    {
      addHtmlError(P002_data_struct::webformSave(event));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P002_data_struct());
      P002_data_struct *P002_data =
        static_cast<P002_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P002_data) {
        success = true;
        P002_data->init(event);
      }
      break;
    }
    case PLUGIN_TEN_PER_SECOND:
    {
      if (P002_OVERSAMPLING != P002_USE_CURENT_SAMPLE)
      {
        P002_data_struct *P002_data =
          static_cast<P002_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P002_data) {
          P002_data->takeSample();
        }
      }
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      int raw_value = 0;
      float res_value = 0.0f;

      P002_data_struct *P002_data =
        static_cast<P002_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((P002_data != nullptr) && P002_data->getValue(res_value, raw_value)) {
        UserVar.setFloat(event->TaskIndex, 0, res_value);

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = strformat(
            F("ADC  : Analog value: %d = %s"),
            raw_value,
            formatUserVarNoCheck(event->TaskIndex, 0).c_str());

          if (P002_OVERSAMPLING == P002_USE_OVERSAMPLING) {
            log += strformat(F(" (%u samples)"), P002_data->getOversamplingCount());
          }
          addLogMove(LOG_LEVEL_INFO, log);
        }
        P002_data->reset();
        success = true;
      } else {
        addLog(LOG_LEVEL_ERROR, F("ADC  : No value received "));
        success = false;
      }

      break;
    }

    case PLUGIN_SET_CONFIG:
    {
      P002_data_struct *P002_data =
        static_cast<P002_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (P002_data != nullptr) {
        success = P002_data->plugin_set_config(event, string);

        if (success) {
          P002_data->init(event);
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P003_Pulse.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P003
# 16 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P003_Pulse.ino"
# include "src/PluginStructs/P003_data_struct.h"

# include "src/Helpers/ESPEasy_time_calc.h"

#ifndef BUILD_NO_DEBUG
#define P003_PULSE_STATS_DEFAULT_LOG_LEVEL LOG_LEVEL_DEBUG
#endif
#define P003_PULSE_STATS_ADHOC_LOG_LEVEL LOG_LEVEL_INFO

#define PLUGIN_003 
#define PLUGIN_ID_003 3
#define PLUGIN_NAME_003 "Generic - Pulse counter"


#define PLUGIN_NR_VALUENAMES_003 3
#define PLUGIN_VALUENAME1_003 "Count"
#define PLUGIN_VALUENAME2_003 "Total"
#define PLUGIN_VALUENAME3_003 "Time"


#define P003_IDX_pulseCounter 0
#define P003_IDX_pulseTotalCounter 1
#define P003_IDX_pulseTime 2


#define P003_IDX_persistedTotalCounter 3


#define P003_IDX_DEBOUNCETIME 0
#define P003_IDX_COUNTERTYPE 1
#define P003_IDX_MODETYPE 2


#define P003_NR_COUNTERTYPES 4
#define P003_COUNTERTYPE_LIST { F("Delta"), F("Delta/Total/Time"), F("Total"), F("Delta/Total"), }
#define P003_CT_INDEX_COUNTER 0
#define P003_CT_INDEX_COUNTER_TOTAL_TIME 1
#define P003_CT_INDEX_TOTAL 2
#define P003_CT_INDEX_COUNTER_TOTAL 3


boolean Plugin_003(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_003;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = true;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = PLUGIN_NR_VALUENAMES_003;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].TaskLogsOwnPeaks = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_003);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_003));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_003));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_003));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_input(F("Pulse"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Debounce Time (mSec)"), F("debounce")
                        , PCONFIG(P003_IDX_DEBOUNCETIME));

      {
        uint8_t choice = PCONFIG(P003_IDX_COUNTERTYPE);
        const __FlashStringHelper *options[P003_NR_COUNTERTYPES] = P003_COUNTERTYPE_LIST;
        addFormSelector(F("Counter Type"), F("countertype"), P003_NR_COUNTERTYPES, options, nullptr, choice);
        if (choice != 0) {
          addHtml(F("<span style=\"color:red\">Total count is not persistent!</span>"));
        }
      }

      Internal_GPIO_pulseHelper::addGPIOtriggerMode(
        F("Mode Type"),
        F("raisetype"),
        static_cast<Internal_GPIO_pulseHelper::GPIOtriggerMode>(PCONFIG(P003_IDX_MODETYPE)));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(P003_IDX_DEBOUNCETIME) = getFormItemInt(F("debounce"));
      PCONFIG(P003_IDX_COUNTERTYPE) = getFormItemInt(F("countertype"));
      PCONFIG(P003_IDX_MODETYPE) = getFormItemInt(F("raisetype"));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      Internal_GPIO_pulseHelper::pulseCounterConfig config;
      config.setDebounceTime(PCONFIG(P003_IDX_DEBOUNCETIME));
      config.gpio = CONFIG_PIN1;
      config.taskIndex = event->TaskIndex;
      config.interruptPinMode = static_cast<Internal_GPIO_pulseHelper::GPIOtriggerMode>(PCONFIG(P003_IDX_MODETYPE));
      config.pullupPinMode = Settings.TaskDevicePin1PullUp[event->TaskIndex] ? INPUT_PULLUP : INPUT;




      initPluginTaskData(event->TaskIndex, new (std::nothrow) P003_data_struct(config));
      P003_data_struct *P003_data =
        static_cast<P003_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P003_data) {
        #ifdef PULSE_STATISTIC
        #ifndef BUILD_NO_DEBUG
        P003_data->pulseHelper.setStatsLogLevel(P003_PULSE_STATS_DEFAULT_LOG_LEVEL);
        #endif
        #endif




        P003_data->pulseHelper.setPulseCountTotal(UserVar[event->BaseVarIndex + P003_IDX_persistedTotalCounter]);


        switch (PCONFIG(P003_IDX_COUNTERTYPE))
        {
          case P003_CT_INDEX_COUNTER:
          case P003_CT_INDEX_COUNTER_TOTAL:
          {
            P003_data->pulseHelper.setPulseCounter(UserVar[event->BaseVarIndex + P003_IDX_pulseCounter]);
            break;
          }
          case P003_CT_INDEX_COUNTER_TOTAL_TIME:
          {
            P003_data->pulseHelper.setPulseCounter(UserVar[event->BaseVarIndex + P003_IDX_pulseCounter],
                                                   UserVar[event->BaseVarIndex + P003_IDX_pulseTime]);
            break;
          }
          case P003_CT_INDEX_TOTAL:
          {
            break;
          }
        }

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          addLogMove(LOG_LEVEL_INFO, strformat(F("INIT : PulsePin: %d"), CONFIG_PIN1));
        }


        success = P003_data->pulseHelper.init();
      }
      break;
    }

    case PLUGIN_READ:
    {
      P003_data_struct *P003_data =
        static_cast<P003_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P003_data) {
        unsigned long pulseCounter, pulseCounterTotal;
        float pulseTime_msec;
        P003_data->pulseHelper.getPulseCounters(pulseCounter, pulseCounterTotal, pulseTime_msec);
        P003_data->pulseHelper.resetPulseCounter();





        UserVar.setFloat(event->TaskIndex, P003_IDX_pulseCounter , pulseCounter);
        UserVar.setFloat(event->TaskIndex, P003_IDX_pulseTotalCounter , pulseCounterTotal);
        UserVar.setFloat(event->TaskIndex, P003_IDX_pulseTime , pulseTime_msec);



        UserVar.setFloat(event->TaskIndex, P003_IDX_persistedTotalCounter, pulseCounterTotal);

        switch (PCONFIG(P003_IDX_COUNTERTYPE))
        {
          case P003_CT_INDEX_COUNTER:
          case P003_CT_INDEX_TOTAL:
          {
            event->sensorType = Sensor_VType::SENSOR_TYPE_SINGLE;
            break;
          }
          case P003_CT_INDEX_COUNTER_TOTAL_TIME:
          {
            event->sensorType = Sensor_VType::SENSOR_TYPE_TRIPLE;
            break;
          }
          case P003_CT_INDEX_COUNTER_TOTAL:
          {
            event->sensorType = Sensor_VType::SENSOR_TYPE_DUAL;
            break;
          }
        }
        success = true;
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P003_data_struct *P003_data =
        static_cast<P003_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P003_data) {
        const String command = parseString(string, 1);
        bool mustCallPluginRead = false;

        const bool cmd_resetpulsecounter = equals(command, F("resetpulsecounter"));
        const bool cmd_setpulsecountertotal = equals(command, F("setpulsecountertotal"));

        if (cmd_resetpulsecounter || cmd_setpulsecountertotal)
        {
# 262 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P003_Pulse.ino"
          uint8_t tidx = 1;

          if (cmd_setpulsecountertotal) { tidx = 2; }

          if (!pluginOptionalTaskIndexArgumentMatch(event->TaskIndex, string, tidx)) {
            break;
          }

          int32_t par1 = 0;

          if (cmd_setpulsecountertotal) {
            if (!validIntFromString(parseString(string, 2), par1)) { break; }
          }
          P003_data->pulseHelper.setPulseCountTotal(par1);

          if (cmd_resetpulsecounter) {
            P003_data->pulseHelper.resetPulseCounter();
          }
          mustCallPluginRead = true;

          # ifdef PULSE_STATISTIC


          P003_data->pulseHelper.updateStatisticalCounters(par1);
          # endif

          success = true;
        }
        else if (equals(command, F("logpulsestatistic")))
        {
          # ifdef PULSE_STATISTIC
# 302 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P003_Pulse.ino"
          const String subcommand = parseString(string, 2);
          const bool sub_i = equals(subcommand, F("i"));
          const bool sub_r = equals(subcommand, F("r"));

          if ((sub_i) || (sub_r) || (subcommand.isEmpty())) {
            P003_data->pulseHelper.doStatisticLogging(P003_PULSE_STATS_ADHOC_LOG_LEVEL);
            P003_data->pulseHelper.doTimingLogging(P003_PULSE_STATS_ADHOC_LOG_LEVEL);

            if (sub_i) { P003_data->pulseHelper.setStatsLogLevel(LOG_LEVEL_INFO); }

            if (sub_r) { P003_data->pulseHelper.resetStatsErrorVars(); }
            success = true;
          }
          # else
          success = false;
          # endif
        }

        if (mustCallPluginRead) {


          Scheduler.schedule_task_device_timer(event->TaskIndex, millis() - 10);
        }
      }
      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P003_data_struct *P003_data =
        static_cast<P003_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P003_data) {

        P003_data->pulseHelper.doPulseStepProcessing(GPIO_PULSE_HELPER_PROCESSING_STEP_0);
      }
      break;
    }

    case PLUGIN_TASKTIMER_IN:
    {
      P003_data_struct *P003_data =
        static_cast<P003_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P003_data) {

        P003_data->pulseHelper.doPulseStepProcessing(event->Par1);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P004_Dallas.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P004
# 17 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P004_Dallas.ino"
# include "src/PluginStructs/P004_data_struct.h"
# include "src/Helpers/Dallas1WireHelper.h"


#define PLUGIN_004 
#define PLUGIN_ID_004 4
#define PLUGIN_NAME_004 "Environment - 1-Wire Temperature"
#define PLUGIN_VALUENAME1_004 "Temperature"

#define P004_ERROR_NAN 0
#define P004_ERROR_MIN_RANGE 1
#define P004_ERROR_ZERO 2
#define P004_ERROR_MAX_RANGE 3
#define P004_ERROR_IGNORE 4


#define P004_ERROR_STATE_OUTPUT PCONFIG(0)
#define P004_RESOLUTION PCONFIG(1)
#define P004_SENSOR_TYPE_INDEX 2
#define P004_NR_OUTPUT_VALUES getValueCountFromSensorType(static_cast<Sensor_VType>(PCONFIG(P004_SENSOR_TYPE_INDEX)))



#define P004_SCAN_ON_INIT PCONFIG(3)


boolean Plugin_004(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_004;
      Device[deviceCount].Type = DEVICE_TYPE_DUAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_004);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      ExtraTaskSettings.populateDeviceValueNamesSeq(F("Temperature"), P004_NR_OUTPUT_VALUES, 2, false);
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P004_NR_OUTPUT_VALUES;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(P004_SENSOR_TYPE_INDEX));
      event->idx = P004_SENSOR_TYPE_INDEX;
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG(P004_SENSOR_TYPE_INDEX) = static_cast<uint8_t>(Sensor_VType::SENSOR_TYPE_SINGLE);

      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_RX(false);
      event->String2 = formatGpioName_TX(true);
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {

      int8_t Plugin_004_DallasPin_RX = CONFIG_PIN1;
      int8_t Plugin_004_DallasPin_TX = CONFIG_PIN2;

      if (Plugin_004_DallasPin_TX == -1) {
        Plugin_004_DallasPin_TX = Plugin_004_DallasPin_RX;
      }

      const int valueCount = P004_NR_OUTPUT_VALUES;

      if (validGpio(Plugin_004_DallasPin_RX) && validGpio(Plugin_004_DallasPin_TX)) {
        addFormCheckBox(F("Auto Select Sensor"), F("autoselect"), P004_SCAN_ON_INIT, valueCount > 1);
        addFormNote(F("Auto Select can only be used for 1 Dallas sensor per GPIO pin."));
        Dallas_addr_selector_webform_load(event->TaskIndex, Plugin_004_DallasPin_RX, Plugin_004_DallasPin_TX, valueCount);

        {

          int activeRes = P004_RESOLUTION;

          uint8_t savedAddress[8];
          Dallas_plugin_get_addr(savedAddress, event->TaskIndex);

          if (savedAddress[0] != 0) {
            activeRes = Dallas_getResolution(savedAddress, Plugin_004_DallasPin_RX, Plugin_004_DallasPin_TX);
          }

          int resolutionChoice = P004_RESOLUTION;

          if ((resolutionChoice < 9) || (resolutionChoice > 12)) { resolutionChoice = activeRes; }
          const __FlashStringHelper *resultsOptions[4] = { F("9"), F("10"), F("11"), F("12") };
          int resultsOptionValues[4] = { 9, 10, 11, 12 };
          addFormSelector(F("Device Resolution"), F("res"), 4, resultsOptions, resultsOptionValues, resolutionChoice);
          addHtml(F(" Bit"));
        }

        {

          const __FlashStringHelper *resultsOptions[5] = { F("NaN"), F("-127"), F("0"), F("125"), F("Ignore") };
          int resultsOptionValues[5] =
          { P004_ERROR_NAN, P004_ERROR_MIN_RANGE, P004_ERROR_ZERO, P004_ERROR_MAX_RANGE, P004_ERROR_IGNORE };
          addFormSelector(F("Error State Value"), F("err"), 5, resultsOptions, resultsOptionValues, P004_ERROR_STATE_OUTPUT);
        }
        addFormNote(F("External pull up resistor is needed, see docs!"));

        {
          P004_data_struct *P004_data =
            static_cast<P004_data_struct *>(getPluginTaskData(event->TaskIndex));

          if (nullptr != P004_data) {
            for (uint8_t i = 0; i < valueCount; ++i) {
              if (i == 0) {
                addFormSubHeader(F("Statistics"));
              } else {
                addFormSeparator(2);
              }
              Dallas_show_sensor_stats_webform_load(P004_data->get_sensor_data(i));
            }
          }
        }
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      int8_t Plugin_004_DallasPin_RX = CONFIG_PIN1;
      int8_t Plugin_004_DallasPin_TX = CONFIG_PIN2;

      if (Plugin_004_DallasPin_TX == -1) {
        Plugin_004_DallasPin_TX = Plugin_004_DallasPin_RX;
      }

      if (validGpio(Plugin_004_DallasPin_RX) && validGpio(Plugin_004_DallasPin_TX)) {

        Dallas_addr_selector_webform_save(event->TaskIndex, Plugin_004_DallasPin_RX, Plugin_004_DallasPin_TX, P004_NR_OUTPUT_VALUES);

        uint8_t res = getFormItemInt(F("res"));

        if ((res < 9) || (res > 12)) { res = 12; }
        P004_RESOLUTION = res;

        uint8_t savedAddress[8];
        Dallas_plugin_get_addr(savedAddress, event->TaskIndex);
        Dallas_setResolution(savedAddress, res, Plugin_004_DallasPin_RX, Plugin_004_DallasPin_TX);
      }
      P004_SCAN_ON_INIT = isFormItemChecked(F("autoselect"));
      P004_ERROR_STATE_OUTPUT = getFormItemInt(F("err"));
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      P004_data_struct *P004_data =
        static_cast<P004_data_struct *>(getPluginTaskData(event->TaskIndex));
      int8_t Plugin_004_DallasPin_RX = CONFIG_PIN1;
      int8_t Plugin_004_DallasPin_TX = CONFIG_PIN2;
      const int valueCount = P004_NR_OUTPUT_VALUES;

      if (Plugin_004_DallasPin_TX == -1) {
        Plugin_004_DallasPin_TX = Plugin_004_DallasPin_RX;
      }


      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < valueCount) {
          if (i != 0) {
            string += F("<br>");
          }

          if (nullptr != P004_data) {


            string += P004_data->get_formatted_address(i);
          } else {

            uint8_t addr[8]{};
            bool hasFixedResolution = false;
            Dallas_plugin_get_addr(addr, event->TaskIndex, i);
            Dallas_getResolution(addr, Plugin_004_DallasPin_RX, Plugin_004_DallasPin_TX, hasFixedResolution);

            string += Dallas_format_address(addr, hasFixedResolution);
          }
        }
      }
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      int8_t Plugin_004_DallasPin_RX = CONFIG_PIN1;
      int8_t Plugin_004_DallasPin_TX = CONFIG_PIN2;
      const uint8_t res = P004_RESOLUTION;
      const int valueCount = P004_NR_OUTPUT_VALUES;

      if (Plugin_004_DallasPin_TX == -1) {
        Plugin_004_DallasPin_TX = Plugin_004_DallasPin_RX;
      }

      {
        # ifdef USE_SECOND_HEAP
        HeapSelectIram ephemeral;
        # endif

        initPluginTaskData(event->TaskIndex, new (std::nothrow) P004_data_struct(
                           event->TaskIndex,
                           Plugin_004_DallasPin_RX,
                           Plugin_004_DallasPin_TX,
                           res,
                           valueCount == 1 && P004_SCAN_ON_INIT));
      }
      P004_data_struct *P004_data =
        static_cast<P004_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P004_data) {
        for (uint8_t i = 0; i < valueCount; ++i) {
          uint8_t addr[8] = { 0 };
          Dallas_plugin_get_addr(addr, event->TaskIndex, i);
          P004_data->add_addr(addr, i);
        }
        P004_data->init();
        success = true;
      }

      break;
    }

    case PLUGIN_READ:
    {
      P004_data_struct *P004_data =
        static_cast<P004_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P004_data) {
        const int valueCount = P004_NR_OUTPUT_VALUES;
        if ((valueCount == 1) && P004_SCAN_ON_INIT) {
          if (!P004_data->sensorAddressSet()) {
            P004_data->init();
          }
        }

        if (!timeOutReached(P004_data->get_timer())) {
          Scheduler.schedule_task_device_timer(event->TaskIndex, P004_data->get_timer());
        } else {
          if (!P004_data->measurement_active()) {
            if (P004_data->initiate_read()) {
              Scheduler.schedule_task_device_timer(event->TaskIndex, P004_data->get_timer());
            }
          } else {

            Scheduler.reschedule_task_device_timer(event->TaskIndex, P004_data->get_measurement_start());

            P004_data->collect_values();

            for (uint8_t i = 0; i < valueCount; ++i) {
              float value = 0.0f;

              if (P004_data->read_temp(value, i))
              {
                UserVar.setFloat(event->TaskIndex, i, value);
                success = true;
              }
              else
              {
                if (P004_ERROR_STATE_OUTPUT != P004_ERROR_IGNORE) {
                  float errorValue = NAN;

                  switch (P004_ERROR_STATE_OUTPUT) {
                    case P004_ERROR_MIN_RANGE: errorValue = -127.0f; break;
                    case P004_ERROR_ZERO: errorValue = 0.0f; break;
                    case P004_ERROR_MAX_RANGE: errorValue = 125.0f; break;
                    default:
                      break;
                  }
                  UserVar.setFloat(event->TaskIndex, i, errorValue);
                }
              }

              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log = F("DS   : Temperature: ");

                if (success) {
                  log += formatUserVarNoCheck(event, i);
                } else {
                  log += F("Error!");
                }
                log += F(" (");
                log += P004_data->get_formatted_address(i);
                log += ')';
                addLogMove(LOG_LEVEL_INFO, log);
              }
            }
            P004_data->set_measurement_inactive();
          }
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P005_DHT.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P005




#include "src/PluginStructs/P005_data_struct.h"

#define PLUGIN_005 
#define PLUGIN_ID_005 5
#define PLUGIN_NAME_005 "Environment - DHT11/12/22  SONOFF2301/7021/MS01"
#define PLUGIN_VALUENAME1_005 "Temperature"
#define PLUGIN_VALUENAME1_005_MS01 "RAW"
#define PLUGIN_VALUENAME2_005 "Humidity"



boolean Plugin_005(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_005;
        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_HUM;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = true;
        Device[deviceCount].ValueCount = 2;
        Device[deviceCount].SendDataOption = true;
        Device[deviceCount].TimerOption = true;
        Device[deviceCount].GlobalSyncOption = true;
        Device[deviceCount].PluginStats = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_005);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        if (PCONFIG(0) == P005_MS01) {
          strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_005_MS01));
        } else {
          strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_005));
        }
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_005));
        break;
      }

    case PLUGIN_GET_DEVICEGPIONAMES:
      {
        event->String1 = formatGpioName_bidirectional(F("Data"));
        break;
      }

    case PLUGIN_WEBFORM_LOAD:
      {
        const __FlashStringHelper * options[] = { F("DHT 11"), F("DHT 22"), F("DHT 12"), F("Sonoff am2301"), F("Sonoff si7021"), F("Sonoff MS01") };
        const int indices[] = { P005_DHT11, P005_DHT22, P005_DHT12, P005_AM2301, P005_SI7021, P005_MS01 };

        constexpr size_t nrElements = NR_ELEMENTS(indices);

        addFormSelector(F("Sensor model"), F("dhttype"), nrElements, options, indices, PCONFIG(0) );

        success = true;
        break;
      }

    case PLUGIN_WEBFORM_SAVE:
      {
        PCONFIG(0) = getFormItemInt(F("dhttype"));

        success = true;
        break;
      }

    case PLUGIN_INIT:
      {
        success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P005_data_struct(event));
        break;
      }

    case PLUGIN_READ:
      {
        P005_data_struct *P005_data =
          static_cast<P005_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P005_data) {
          success = P005_data->readDHT(event);
        }
        break;
      }
  }
  return success;
}


#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P006_BMP085.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P006






# include "src/PluginStructs/P006_data_struct.h"

#define PLUGIN_006 
#define PLUGIN_ID_006 6
#define PLUGIN_NAME_006 "Environment - BMP085/180"
#define PLUGIN_VALUENAME1_006 "Temperature"
#define PLUGIN_VALUENAME2_006 "Pressure"


boolean Plugin_006(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_006;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_BARO;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_006);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_006));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_006));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x77);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x77;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Altitude [m]"), F("elev"), PCONFIG(1));
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(1) = getFormItemInt(F("elev"));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P006_data_struct());
      P006_data_struct *P006_data =
        static_cast<P006_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P006_data);
      break;
    }

    case PLUGIN_READ:
    {
      P006_data_struct *P006_data =
        static_cast<P006_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P006_data) {
        if (P006_data->begin())
        {
          UserVar.setFloat(event->TaskIndex, 0, P006_data->readTemperature());
          int elev = PCONFIG(1);
          float pressure = static_cast<float>(P006_data->readPressure()) / 100.0f;

          if (elev != 0)
          {
            pressure = pressureElevation(pressure, elev);
          }
          UserVar.setFloat(event->TaskIndex, 1, pressure);

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log = F("BMP  : Temperature: ");
            log += formatUserVarNoCheck(event->TaskIndex, 0);
            addLogMove(LOG_LEVEL_INFO, log);
            log = F("BMP  : Barometric Pressure: ");
            log += formatUserVarNoCheck(event->TaskIndex, 1);
            addLogMove(LOG_LEVEL_INFO, log);
          }
          success = true;
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P007_PCF8591.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P007
# 19 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P007_PCF8591.ino"
#define PLUGIN_007 
#define PLUGIN_ID_007 7
#define PLUGIN_NAME_007 "Analog input - PCF8591"
#define PLUGIN_VALUENAME1_007 "Analog"

#define P007_SENSOR_TYPE_INDEX 2
#define P007_NR_OUTPUT_VALUES getValueCountFromSensorType(static_cast<Sensor_VType>(PCONFIG(P007_SENSOR_TYPE_INDEX)))
#define P007_INPUT_MODE PCONFIG_LONG(0)
#define P007_OUTPUT_MODE PCONFIG_LONG(1)
#define P007_OUTPUT_ENABLED (0b01000000)


boolean Plugin_007(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_007;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].I2CMax100kHz = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_007);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      ExtraTaskSettings.populateDeviceValueNamesSeq(F(PLUGIN_VALUENAME1_007), P007_NR_OUTPUT_VALUES, 2, true);
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      if (PCONFIG(P007_SENSOR_TYPE_INDEX) == 0) {
        PCONFIG(P007_SENSOR_TYPE_INDEX) = static_cast<uint8_t>(Sensor_VType::SENSOR_TYPE_SINGLE);
      }
      event->Par1 = P007_NR_OUTPUT_VALUES;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(P007_SENSOR_TYPE_INDEX));
      event->idx = P007_SENSOR_TYPE_INDEX;
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG(P007_SENSOR_TYPE_INDEX) = static_cast<uint8_t>(Sensor_VType::SENSOR_TYPE_SINGLE);

      success = true;
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        String portNames[4];
        int portValues[4];
        const uint8_t unit = (CONFIG_PORT - 1) / 4;
        const uint8_t port = CONFIG_PORT - (unit * 4);
        const uint8_t address = 0x48 + unit;

        for (uint8_t x = 0; x < 4; x++) {
          portValues[x] = x + 1;
          portNames[x] = 'A';
          portNames[x] += x;
        }
        addFormSelectorI2C(F("pi2c"), 8, i2cAddressValues, address);
        addFormSelector(F("Port"), F("pport"), 4, portNames, portValues, port);
        addFormNote(F("Selected Port value will be stored in first 'Values' field and consecutively for 'Number Output Values' &gt; Single."));
      } else {
        success = intArrayContains(8, i2cAddressValues, event->Par1);
      }

      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      const uint8_t unit = (CONFIG_PORT - 1) / 4;
      event->Par1 = 0x48 + unit;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Hardware configuration"));

      const __FlashStringHelper *inputModeOptions[] = {
        F("4 single-ended inputs"),
        F("3 differential inputs, A0/A1/A2 differential with AIN3"),
        F("2 single-ended, A0, A1, AIN2/AIN3 differential -&gt; A2"),
        F("AIN0/AIN1 differential -&gt; A0, AIN2/AIN3 differential -&gt; A1"),
      };
      const int inputModeValues[] = {
        0b00000000,
        0b00010000,
        0b00100000,
        0b00110000,
      };
      addFormSelector(F("Input mode"), F("input_mode"), 4, inputModeOptions, inputModeValues, P007_INPUT_MODE);

      addFormCheckBox(F("Enable Analog output (AOUT)"), F("output_mode"), P007_OUTPUT_MODE == P007_OUTPUT_ENABLED);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      if (PCONFIG(P007_SENSOR_TYPE_INDEX) == 0) {
        PCONFIG(P007_SENSOR_TYPE_INDEX) = static_cast<uint8_t>(Sensor_VType::SENSOR_TYPE_SINGLE);
      }
      uint8_t i2c = getFormItemInt(F("pi2c"));
      uint8_t port = getFormItemInt(F("pport"));
      CONFIG_PORT = (((i2c - 0x48) << 2) + port);

      P007_INPUT_MODE = getFormItemInt(F("input_mode"));
      P007_OUTPUT_MODE = isFormItemChecked(F("output_mode")) ? P007_OUTPUT_ENABLED : 0;

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      const uint8_t unit = (CONFIG_PORT - 1) / 4;
      uint8_t port = CONFIG_PORT - (unit * 4);
      const uint8_t address = 0x48 + unit;

      uint8_t var = 0;
      const uint8_t valueCount = P007_NR_OUTPUT_VALUES;

      for (; var < valueCount; ++port, ++var) {
        if (port <= 4) {

          uint8_t configRegister = port - 1;
          configRegister |= P007_INPUT_MODE;
          configRegister |= P007_OUTPUT_MODE;


          I2C_write8(address, configRegister);

          Wire.requestFrom(address, (uint8_t)0x2);

          if (Wire.available())
          {
            Wire.read();
            UserVar.setFloat(event->TaskIndex, var, Wire.read());

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              addLog(LOG_LEVEL_INFO, strformat(
                F("PCF  : Analog port: A%d value %d: %s"),
                port - 1,
                var + 1,
                formatUserVarNoCheck(event->TaskIndex, var).c_str()));
            }
            success = true;
          }
        } else {
          UserVar.setFloat(event->TaskIndex, var, 0);
        }
      }

      for (; var < VARS_PER_TASK; ++var) {
        UserVar.setFloat(event->TaskIndex, var, 0);
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      String command = parseString(string, 1);

      if ((P007_OUTPUT_MODE == P007_OUTPUT_ENABLED) &&
          equals(command, F("analogout")) &&
          (event->Par1 >= 0) && (event->Par1 <= 255)) {
        uint8_t unit = (CONFIG_PORT - 1) / 4;
        uint8_t address = 0x48 + unit;


        uint8_t configRegister = 0;
        configRegister |= P007_INPUT_MODE;
        configRegister |= P007_OUTPUT_MODE;

        I2C_write8_reg(address, configRegister, static_cast<uint8_t>(event->Par1));

        success = true;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P008_RFID.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P008
# 34 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P008_RFID.ino"
#define PLUGIN_008 
#define PLUGIN_ID_008 8
#define PLUGIN_NAME_008 "RFID - Wiegand"
#define PLUGIN_VALUENAME1_008 "Tag"

# include "src/PluginStructs/P008_data_struct.h"


boolean Plugin_008(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_008;
      Device[deviceCount].Type = DEVICE_TYPE_DUAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_ULONG;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_008);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_008));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_input(F("D0 (Green, 5V)"));
      event->String2 = formatGpioName_input(F("D1 (White, 5V)"));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P008_DATA_BITS = 26;
      P008_COMPATIBILITY = 1;
      P008_REMOVE_TIMEOUT = 500;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P008_data_struct(event));
      P008_data_struct *P008_data = static_cast<P008_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P008_data) {
        success = P008_data->plugin_init(event);
      }
      break;
    }

    case PLUGIN_TASKTIMER_IN:
    {
      P008_data_struct *P008_data = static_cast<P008_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P008_data) {
        success = P008_data->plugin_timer_in(event);
      }
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P008_data_struct *P008_data = static_cast<P008_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P008_data) {
        success = P008_data->plugin_once_a_second(event);
      }
      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      P008_data_struct *P008_data = static_cast<P008_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P008_data) {
        success = P008_data->plugin_get_config(event, string);
      }
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormCheckBox(F("Enable backward compatibility mode"), F("comp"), P008_COMPATIBILITY == 0);
      # ifndef BUILD_NO_DEBUG
      addFormNote(F("Earlier versions of this plugin have used GPIO pins inverted, giving different Tag results."));
      # endif

      addFormNumericBox(F("Wiegand Type (bits)"), F("ptype"), P008_DATA_BITS, 26, 64);
      addUnit(F("26..64 bits"));
      # ifdef BUILD_NO_DEBUG
      addFormNote(F("Select the number of bits to be received, f.e. 26, 34, 37."));
      # endif

      addFormCheckBox(F("Present hex as decimal value"), F("hdec"), P008_HEX_AS_DEC == 1);
      # ifndef BUILD_NO_DEBUG
      addFormNote(F("Useful only for numeric keypad input!"));
      # endif

      addFormCheckBox(F("Automatic Tag removal"), F("autormv"), P008_AUTO_REMOVE == 0);

      if (P008_REMOVE_TIMEOUT == 0) { P008_REMOVE_TIMEOUT = 500; }
      addFormNumericBox(F("Automatic Tag removal after"), F("rmvtime"), P008_REMOVE_TIMEOUT, 250, 60000);
      addUnit(F("mSec."));


      addFormNumericBox(F("Value to set on Tag removal"), F("rmvval"), P008_REMOVE_VALUE, 0);

      addFormCheckBox(F("Event on Tag removal"), F("rstevt"), P008_REMOVE_EVENT == 1);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P008_DATA_BITS = getFormItemInt(F("ptype"));
      P008_HEX_AS_DEC = isFormItemChecked(F("hdec")) ? 1 : 0;
      P008_AUTO_REMOVE = isFormItemChecked(F("autormv")) ? 0 : 1;
      P008_REMOVE_EVENT = isFormItemChecked(F("rstevt")) ? 1 : 0;
      P008_COMPATIBILITY = isFormItemChecked(F("comp")) ? 0 : 1;
      P008_REMOVE_VALUE = getFormItemInt(F("rmvval"));
      P008_REMOVE_TIMEOUT = getFormItemInt(F("rmvtime"));
# 184 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P008_RFID.ino"
      success = true;
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P009_MCP.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P009


# include "src/DataStructs/PinMode.h"
# include "src/ESPEasyCore/ESPEasyGPIO.h"
# include "src/Helpers/_Plugin_Helper_webform.h"
# 38 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P009_MCP.ino"
#define PLUGIN_009 
#define PLUGIN_ID_009 9
#define PLUGIN_NAME_009 "Switch input - MCP23017"
#define PLUGIN_VALUENAME1_009 "State"


#define P009_BOOTSTATE PCONFIG(0)
#define P009_DEBOUNCE PCONFIG_FLOAT(0)
#define P009_DOUBLECLICK PCONFIG(4)
#define P009_DC_MAX_INT PCONFIG_FLOAT(1)
#define P009_LONGPRESS PCONFIG(5)
#define P009_LP_MIN_INT PCONFIG_FLOAT(2)
#define P009_SAFE_BTN PCONFIG_FLOAT(3)


boolean Plugin_009(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;



  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_009;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = true;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_009);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_009));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        String portNames[16];
        int portValues[16];
        const uint8_t unit = (CONFIG_PORT - 1) / 16;
        const uint8_t port = CONFIG_PORT - (unit * 16);
        const uint8_t address = 0x20 + unit;

        for (uint8_t x = 0; x < 16; x++) {
          portValues[x] = x + 1;
          portNames[x] = 'P';
          portNames[x] += (x < 8 ? 'A' : 'B');
          portNames[x] += (x < 8 ? x : x - 8);
        }
        addFormSelectorI2C(F("pi2c"), 8, i2cAddressValues, address);
        addFormSelector(F("Port"), F("pport"), 16, portNames, portValues, port);
      } else {
        success = intArrayContains(8, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      const uint8_t unit = (CONFIG_PORT - 1) / 16;
      event->Par1 = 0x20 + unit;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {

      const uint32_t key = createKey(PLUGIN_MCP, CONFIG_PORT);

      auto it = globalMapPortStatus.find(key);

      if (it != globalMapPortStatus.end()) {
        it->second.previousTask = event->TaskIndex;
      }

      SwitchWebformLoad(
        P009_BOOTSTATE,
        P009_DEBOUNCE,
        P009_DOUBLECLICK,
        P009_DC_MAX_INT,
        P009_LONGPRESS,
        P009_LP_MIN_INT,
        P009_SAFE_BTN);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      uint8_t i2c = getFormItemInt(F("pi2c"));
      uint8_t port = getFormItemInt(F("pport"));
      CONFIG_PORT = (((i2c - 0x20) << 4) + port);

      SwitchWebformSave(
        event->TaskIndex,
        PLUGIN_MCP,
        P009_BOOTSTATE,
        P009_DEBOUNCE,
        P009_DOUBLECLICK,
        P009_DC_MAX_INT,
        P009_LONGPRESS,
        P009_LP_MIN_INT,
        P009_SAFE_BTN);

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {

      setMCPInputAndPullupMode(CONFIG_PORT, true);


      if (CONFIG_PORT >= 0)
      {
        portStatusStruct newStatus;
        const uint32_t key = createKey(PLUGIN_MCP, CONFIG_PORT);


        newStatus = globalMapPortStatus[key];



        newStatus.state = GPIO_MCP_Read(CONFIG_PORT);

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("MCP INIT=");
          log += newStatus.state;
          addLogMove(LOG_LEVEL_INFO, log);
        }
        newStatus.output = newStatus.state;
        newStatus.mode = (newStatus.state == -1) ? PIN_MODE_OFFLINE : PIN_MODE_INPUT_PULLUP;


        newStatus.task++;


        if ((newStatus.state != -1) && Settings.TaskDevicePin1Inversed[event->TaskIndex]) {
          UserVar.setFloat(event->TaskIndex, 0, !newStatus.state);
        } else {
          UserVar.setFloat(event->TaskIndex, 0, newStatus.state);
        }



        if (P009_BOOTSTATE) {
          newStatus.state = !newStatus.state;
        }


        PCONFIG(7) = 0;
        PCONFIG_LONG(3) = 0;


        PCONFIG(6) = false;


        PCONFIG_LONG(0) = millis();
        PCONFIG_LONG(1) = millis();
        PCONFIG_LONG(2) = millis();


        if (P009_DC_MAX_INT < SWITCH_DOUBLECLICK_MIN_INTERVAL) {
          P009_DC_MAX_INT = SWITCH_DOUBLECLICK_MIN_INTERVAL;
        }


        if (P009_LP_MIN_INT < SWITCH_LONGPRESS_MIN_INTERVAL) {
          P009_LP_MIN_INT = SWITCH_LONGPRESS_MIN_INTERVAL;
        }


        savePortStatus(key, newStatus);
        success = true;
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      # if FEATURE_I2C_DEVICE_CHECK

      const uint8_t unit = (CONFIG_PORT - 1) / 16;
      const uint8_t address = 0x20 + unit;

      if (!I2C_deviceCheck(address, event->TaskIndex, 10, PLUGIN_I2C_GET_ADDRESS)) {
        break;
      }
      # endif
      const int8_t state = GPIO_MCP_Read(CONFIG_PORT);
      const __FlashStringHelper *monitorEventString = F("MCP");
# 269 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P009_MCP.ino"
      portStatusStruct currentStatus;
      const uint32_t key = createKey(PLUGIN_MCP, CONFIG_PORT);


      currentStatus = globalMapPortStatus[key];


      if ((state != -1) && (CONFIG_PORT >= 0)) {

        if (lround(P009_SAFE_BTN) && (state != currentStatus.state) && (PCONFIG_LONG(3) == 0))
        {
          # ifndef BUILD_NO_DEBUG
          addLog(LOG_LEVEL_DEBUG, F("MCP :SafeButton 1st click."));
          # endif
          PCONFIG_LONG(3) = 1;
        }


        else if ((state != currentStatus.state) || currentStatus.forceEvent)
        {

          PCONFIG_LONG(3) = 0;


          PCONFIG_LONG(2) = millis();
          PCONFIG(6) = false;

          const unsigned long debounceTime = timePassedSince(PCONFIG_LONG(0));

          if (debounceTime >= (unsigned long)lround(P009_DEBOUNCE))
          {
            const unsigned long deltaDC = timePassedSince(PCONFIG_LONG(1));

            if ((deltaDC >= (unsigned long)lround(P009_DC_MAX_INT)) ||
                (PCONFIG(7) == 3))
            {

              PCONFIG(7) = 0;
              PCONFIG_LONG(1) = millis();
            }


#define COUNTER PCONFIG(7)
#define DC P009_DOUBLECLICK


            if ((COUNTER != 0) || ((COUNTER == 0) && ((DC == 3) || ((DC == 1) && (state == 0)) || ((DC == 2) && (state == 1))))) {
              PCONFIG(7)++;
            }
#undef DC
#undef COUNTER


            if ((currentStatus.mode == PIN_MODE_OFFLINE) ||
                (currentStatus.mode == PIN_MODE_UNDEFINED)) { currentStatus.mode = PIN_MODE_INPUT_PULLUP;
            }
            currentStatus.state = state;

            uint8_t output_value;


            boolean sendState = currentStatus.state;

            if (Settings.TaskDevicePin1Inversed[event->TaskIndex]) {
              sendState = !sendState;
            }

            if ((PCONFIG(7) == 3) && (P009_DOUBLECLICK > 0))
            {
              output_value = 3;
            } else {
              output_value = sendState ? 1 : 0;
            }

            UserVar.setFloat(event->TaskIndex, 0, output_value);

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("MCP  : Port=");
              log += CONFIG_PORT;
              log += F(" State=");
              log += state;
              log += output_value == 3 ? F(" Doubleclick=") : F(" Output value=");
              log += output_value;
              addLogMove(LOG_LEVEL_INFO, log);
            }


            sendData(event);


            if (currentStatus.monitor) { sendMonitorEvent(monitorEventString, CONFIG_PORT, output_value); }


            currentStatus.forceEvent = 0;

            savePortStatus(key, currentStatus);
          }
          savePortStatus(key, currentStatus);
        }


#define LP P009_LONGPRESS
#define FIRED PCONFIG(6)


        else if (!FIRED && ((LP == 3) || ((LP == 1) && (state == 0)) || ((LP == 2) && (state == 1)))) {
#undef LP
#undef FIRED
# 392 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P009_MCP.ino"
          PCONFIG_LONG(3) = 0;

          const unsigned long deltaLP = timePassedSince(PCONFIG_LONG(2));

          if (deltaLP >= (unsigned long)lround(P009_LP_MIN_INT))
          {
            uint8_t output_value;
            PCONFIG(6) = true;

            boolean sendState = state;

            if (Settings.TaskDevicePin1Inversed[event->TaskIndex]) {
              sendState = !sendState;
            }

            output_value = sendState ? 1 : 0;
            output_value = output_value + 10;

            UserVar.setFloat(event->TaskIndex, 0, output_value);

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("MCP  : LongPress: Port=");
              log += CONFIG_PORT;
              log += F(" State=");
              log += state ? '1' : '0';
              log += F(" Output value=");
              log += output_value;
              addLogMove(LOG_LEVEL_INFO, log);
            }


            sendData(event);


            if (currentStatus.monitor) { sendMonitorEvent(monitorEventString, CONFIG_PORT, output_value); }


            UserVar.setFloat(event->TaskIndex, 0, sendState ? 1 : 0);
          }
        } else {
          if (PCONFIG_LONG(3) == 1) {

            PCONFIG_LONG(3) = 0;


            const int tempUserVar = lround(UserVar[event->BaseVarIndex]);
            UserVar.setFloat(event->TaskIndex, 0, 4);

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("MCP : SafeButton: false positive detected. GPIO= ");
              log += CONFIG_PORT;
              log += F(" State=");
              log += tempUserVar;
              addLogMove(LOG_LEVEL_INFO, log);
            }




            if (currentStatus.monitor) { sendMonitorEvent(monitorEventString, CONFIG_PORT, 4); }


            UserVar.setFloat(event->TaskIndex, 0, tempUserVar);
          }
        }
      } else if ((state != currentStatus.state) && (state == -1)) {

        UserVar.setFloat(event->TaskIndex, 0, state);
        currentStatus.mode = PIN_MODE_OFFLINE;


        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("MCP  : Port=");
          log += CONFIG_PORT;
          log += F(" is offline (EVENT= -1)");
          addLogMove(LOG_LEVEL_INFO, log);
        }


        sendData(event);


        if (currentStatus.monitor) { sendMonitorEvent(monitorEventString, CONFIG_PORT, -1); }

        savePortStatus(key, currentStatus);
      }
      success = true;
      break;
    }


    case PLUGIN_EXIT:
    {
      removeTaskFromPort(createKey(PLUGIN_MCP, CONFIG_PORT));
      break;
    }

    case PLUGIN_READ:
    {


      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log = F("MCP   : Port=");
        log += CONFIG_PORT;
        log += F(" State=");
        log += UserVar[event->BaseVarIndex];
        addLogMove(LOG_LEVEL_INFO, log);
      }
      success = true;
      break;
    }

    case PLUGIN_REQUEST:
    {





      if ((string.length() >= 16) && string.substring(0, 16).equalsIgnoreCase(F("mcpgpio,pinstate")))
      {
        int32_t par1;

        if (validIntFromString(parseString(string, 3), par1)) {
          string = GPIO_MCP_Read(par1);
        }
        success = true;
      }
      break;
    }

    case PLUGIN_WRITE:
    {



      break;
    }

    case PLUGIN_TASKTIMER_IN:
    case PLUGIN_DEVICETIMER_IN:
    {
      Scheduler.clearGPIOTimer(PLUGIN_MCP, event->Par1);
      GPIO_MCP_Write(event->Par1, event->Par2);


      portStatusStruct tempStatus;


      const uint32_t key = createKey(PLUGIN_MCP, event->Par1);
      tempStatus = globalMapPortStatus[key];

      tempStatus.state = event->Par2;
      tempStatus.mode = PIN_MODE_OUTPUT;
      tempStatus.forceMonitor = (tempStatus.monitor) ? 1 : 0;
      savePortStatus(key, tempStatus);
      break;
    }
  }
  return success;
}
# 700 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P009_MCP.ino"
#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P010_BH1750.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P010






# include <AS_BH1750.h>

#define PLUGIN_010 
#define PLUGIN_ID_010 10
#define PLUGIN_NAME_010 "Light/Lux - BH1750"
#define PLUGIN_VALUENAME1_010 "Lux"


boolean Plugin_010(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_010;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_010);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_010));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { BH1750_DEFAULT_I2CADDR, BH1750_SECOND_I2CADDR };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, PCONFIG(0));
        addFormNote(F("ADDR Low=0x23, High=0x5c"));
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      const __FlashStringHelper *optionsMode[] = {
        F("RESOLUTION_LOW"),
        F("RESOLUTION_NORMAL"),
        F("RESOLUTION_HIGH"),
        F("RESOLUTION_AUTO_HIGH"),
      };
      const int optionValuesMode[] = {
        RESOLUTION_LOW,
        RESOLUTION_NORMAL,
        RESOLUTION_HIGH,
        RESOLUTION_AUTO_HIGH,
      };
      addFormSelector(F("Measurement mode"), F("pmode"), 4, optionsMode, optionValuesMode, PCONFIG(1));

      addFormCheckBox(F("Send sensor to sleep"), F("psleep"), PCONFIG(2));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("i2c_addr"));
      PCONFIG(1) = getFormItemInt(F("pmode"));
      PCONFIG(2) = isFormItemChecked(F("psleep"));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      AS_BH1750 sensor = AS_BH1750(PCONFIG(0));


      sensors_resolution_t mode = static_cast<sensors_resolution_t>(PCONFIG(1));
# 129 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P010_BH1750.ino"
      sensor.begin(mode, PCONFIG(2) == 1);

      float lux = sensor.readLightLevel();

      if (lux != -1) {
        UserVar.setFloat(event->TaskIndex, 0, lux);

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("BH1750 Address: ");
          log += formatToHex(PCONFIG(0), 2);
          log += F(" Mode: ");
          log += formatToHex(PCONFIG(1), 2);
          log += F(" : Light intensity: ");
          log += formatUserVarNoCheck(event->TaskIndex, 0);
          addLogMove(LOG_LEVEL_INFO, log);
        }
        success = true;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P011_PME.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P011







#define PLUGIN_011 
#define PLUGIN_ID_011 11
#define PLUGIN_NAME_011 "Extra IO - ProMini Extender"
#define PLUGIN_VALUENAME1_011 "Value"

#define PLUGIN_011_I2C_ADDRESS 0x7f

constexpr pluginID_t P011_PLUGIN_ID{PLUGIN_ID_011};

boolean Plugin_011(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_011;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].Ports = 14;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_011);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_011));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x7f);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x7f;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      const __FlashStringHelper * options[2] = { F("Digital"), F("Analog") };
      addFormSelector(F("Port Type"), F("p011"), 2, options, nullptr, PCONFIG(0));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("p011"));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      UserVar.setFloat(event->TaskIndex, 0, Plugin_011_Read(PCONFIG(0), CONFIG_PORT));
      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        addLogMove(LOG_LEVEL_INFO, concat(F("PME  : PortValue: "), formatUserVarNoCheck(event->TaskIndex, 0)));
      }
      success = true;
      break;
    }

    case PLUGIN_WRITE:
    {
      String log;
      String command = parseString(string, 1);

      if (equals(command, F("extgpio")))
      {
        success = true;
        portStatusStruct tempStatus;
        const uint32_t key = createKey(P011_PLUGIN_ID, event->Par1);



        tempStatus = globalMapPortStatus[key];

        tempStatus.mode = PIN_MODE_OUTPUT;
        tempStatus.state = event->Par2;
        tempStatus.command = 1;
        savePortStatus(key, tempStatus);

        Plugin_011_Write(event->Par1, event->Par2);


        log = F("PME  : GPIO ");
        log += event->Par1;
        log += F(" Set to ");
        log += event->Par2;
        addLog(LOG_LEVEL_INFO, log);


        SendStatusOnlyIfNeeded(event, SEARCH_PIN_STATE, key, log, 0);
      }

      if (equals(command, F("extpwm")))
      {
        success = true;
        uint8_t address = PLUGIN_011_I2C_ADDRESS;
        Wire.beginTransmission(address);
        Wire.write(3);
        Wire.write(event->Par1);
        Wire.write(event->Par2 & 0xff);
        Wire.write((event->Par2 >> 8));
        Wire.endTransmission();

        portStatusStruct tempStatus;
        const uint32_t key = createKey(P011_PLUGIN_ID, event->Par1);



        tempStatus = globalMapPortStatus[key];
        tempStatus.mode = PIN_MODE_PWM;
        tempStatus.state = event->Par2;
        tempStatus.command = 1;
        savePortStatus(key, tempStatus);


        log = F("PME  : GPIO ");
        log += event->Par1;
        log += F(" Set PWM to ");
        log += event->Par2;
        addLog(LOG_LEVEL_INFO, log);


        SendStatusOnlyIfNeeded(event, SEARCH_PIN_STATE, key, log, 0);
      }

      if (equals(command, F("extpulse")))
      {
        success = true;

        if ((event->Par1 >= 0) && (event->Par1 <= 13))
        {
          Plugin_011_Write(event->Par1, event->Par2);
          delay(event->Par3);
          Plugin_011_Write(event->Par1, !event->Par2);

          portStatusStruct tempStatus;
          const uint32_t key = createKey(P011_PLUGIN_ID, event->Par1);



          tempStatus = globalMapPortStatus[key];
          tempStatus.mode = PIN_MODE_OUTPUT;
          tempStatus.state = event->Par2;
          tempStatus.command = 1;
          savePortStatus(key, tempStatus);


          log = F("PME  : GPIO ");
          log += event->Par1;
          log += F(" Pulsed for ");
          log += event->Par3;
          log += F(" mS");
          addLog(LOG_LEVEL_INFO, log);


          SendStatusOnlyIfNeeded(event, SEARCH_PIN_STATE, key, log, 0);
        }
      }

      if (equals(command, F("extlongpulse")))
      {
        success = true;

        if ((event->Par1 >= 0) && (event->Par1 <= 13))
        {
          Plugin_011_Write(event->Par1, event->Par2);
          Scheduler.setPluginTaskTimer(event->Par3 * 1000, event->TaskIndex, event->Par1, !event->Par2);

          portStatusStruct tempStatus;
          const uint32_t key = createKey(P011_PLUGIN_ID, event->Par1);



          tempStatus = globalMapPortStatus[key];
          tempStatus.mode = PIN_MODE_OUTPUT;
          tempStatus.state = event->Par2;
          tempStatus.command = 1;
          savePortStatus(key, tempStatus);


          log = F("PME  : GPIO ");
          log += event->Par1;
          log += F(" Pulse set for ");
          log += event->Par3;
          log += F(" S");
          addLog(LOG_LEVEL_INFO, log);


          SendStatusOnlyIfNeeded(event, SEARCH_PIN_STATE, key, log, 0);
        }
      }

      if (equals(command, F("status"))) {
        if (equals(parseString(string, 2), F("ext")))
        {
          success = true;
          const uint32_t key = createKey(P011_PLUGIN_ID, event->Par2);
          String dummyString;

          if (!existPortStatus(key)) {
            SendStatusOnlyIfNeeded(event, SEARCH_PIN_STATE, key, dummyString, 0);
          }
          else
          {
            uint8_t port = event->Par2;
            uint8_t type = 0;

            if (port > 13)
            {
              type = 1;
              port -= 20;
            }
            int state = Plugin_011_Read(type, port);

            if (state != -1) {
              SendStatusOnlyIfNeeded(event, NO_SEARCH_PIN_STATE, key, dummyString, state);
            }


          }
        }
      }
      break;
    }

    case PLUGIN_TASKTIMER_IN:
    {
      Plugin_011_Write(event->Par1, event->Par2);
      portStatusStruct tempStatus;


      const uint32_t key = createKey(P011_PLUGIN_ID, event->Par1);
      tempStatus = globalMapPortStatus[key];

      tempStatus.state = event->Par2;
      tempStatus.mode = PIN_MODE_OUTPUT;
      savePortStatus(key, tempStatus);


      break;
    }
  }
  return success;
}




int Plugin_011_Read(uint8_t Par1, uint8_t Par2)
{
  int value = -1;
  uint8_t address = PLUGIN_011_I2C_ADDRESS;

  Wire.beginTransmission(address);

  if (Par1 == 0) {
    Wire.write(2);
  }
  else {
    Wire.write(4);
  }
  Wire.write(Par2);
  Wire.write(0);
  Wire.write(0);
  Wire.endTransmission();
  delay(1);
  Wire.requestFrom(address, (uint8_t)0x4);
  uint8_t buffer[4];

  if (Wire.available() == 4)
  {
    for (uint8_t x = 0; x < 4; x++) {
      buffer[x] = Wire.read();
    }
    value = buffer[0] + 256 * buffer[1];
  }
  return value;
}




void Plugin_011_Write(uint8_t Par1, uint8_t Par2)
{
  uint8_t address = 0x7f;

  Wire.beginTransmission(address);
  Wire.write(1);
  Wire.write(Par1);
  Wire.write(Par2 & 0xff);
  Wire.write((Par2 >> 8));
  Wire.endTransmission();
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P012_LCD.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P012

# include "src/Helpers/StringParser.h"
# include "src/PluginStructs/P012_data_struct.h"
# 25 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P012_LCD.ino"
#define PLUGIN_012 
#define PLUGIN_ID_012 12
#define PLUGIN_NAME_012 "Display - LCD2004"
#define PLUGIN_VALUENAME1_012 "LCD"

#define P12_Nlines 4
#define P12_Nchars 80

#define P012_I2C_ADDR PCONFIG(0)
#define P012_SIZE PCONFIG(1)
#define P012_TIMER PCONFIG(2)
#define P012_MODE PCONFIG(3)
#define P012_INVERSE_BTN PCONFIG(4)

boolean Plugin_012(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_012;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_012);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_012));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 16, i2cAddressValues, P012_I2C_ADDR);
      } else {
        success = intArrayContains(16, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P012_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *options2[] = {
          F("2 x 16"),
          F("4 x 20"),
        };
        const int optionValues2[2] = { 1, 2 };
        addFormSelector(F("Display Size"), F("psize"), 2, options2, optionValues2, P012_SIZE);
      }

      {
        String strings[P12_Nlines];
        LoadCustomTaskSettings(event->TaskIndex, strings, P12_Nlines, P12_Nchars);

        for (int varNr = 0; varNr < P12_Nlines; varNr++)
        {
          addFormTextBox(concat(F("Line "), varNr + 1), getPluginCustomArgName(varNr), strings[varNr], P12_Nchars);
        }
      }

      addRowLabel(F("Display button"));
      addPinSelect(PinSelectPurpose::Generic_input, F("taskdevicepin3"), CONFIG_PIN3);

      addFormCheckBox(F("Inversed logic"), F("pinv_btn"), P012_INVERSE_BTN == 1, false);

      addFormNumericBox(F("Display Timeout"), F("ptimer"), P012_TIMER);

      {
        const __FlashStringHelper *options3[] {
          F("Continue to next line (as in v1.4)"),
          F("Truncate exceeding message"),
          F("Clear then truncate exceeding message"),
        };
        const int optionValues3[] = { 0, 1, 2 };
        addFormSelector(F("LCD command Mode"), F("pmode"), 3, options3, optionValues3, P012_MODE);
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P012_I2C_ADDR = getFormItemInt(F("i2c_addr"));
      P012_SIZE = getFormItemInt(F("psize"));
      P012_TIMER = getFormItemInt(F("ptimer"));
      P012_MODE = getFormItemInt(F("pmode"));
      P012_INVERSE_BTN = isFormItemChecked(F("pinv_btn")) ? 1 : 0;


      char deviceTemplate[P12_Nlines][P12_Nchars] = {};
      String error;

      for (uint8_t varNr = 0; varNr < P12_Nlines; varNr++)
      {
        if (!safe_strncpy(deviceTemplate[varNr], webArg(getPluginCustomArgName(varNr)), P12_Nchars)) {
          error += getCustomTaskSettingsError(varNr);
        }
      }

      if (error.length() > 0) {
        addHtmlError(error);
      }
      SaveCustomTaskSettings(event->TaskIndex, reinterpret_cast<const uint8_t *>(&deviceTemplate), sizeof(deviceTemplate));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P012_data_struct(P012_I2C_ADDR, P012_SIZE, P012_MODE, P012_TIMER));
      P012_data_struct *P012_data =
        static_cast<P012_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P012_data) {
        P012_data->init();

        if (validGpio(CONFIG_PIN3)) {
          pinMode(CONFIG_PIN3, INPUT_PULLUP);
        }
        success = true;
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      if (validGpio(CONFIG_PIN3))
      {
        if (digitalRead(CONFIG_PIN3) == P012_INVERSE_BTN)
        {
          P012_data_struct *P012_data =
            static_cast<P012_data_struct *>(getPluginTaskData(event->TaskIndex));

          if (nullptr != P012_data) {
            P012_data->setBacklightTimer(P012_TIMER);
          }
        }
      }
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P012_data_struct *P012_data =
        static_cast<P012_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P012_data) {
        P012_data->checkTimer();
      }
      break;
    }

    case PLUGIN_READ:
    {
      P012_data_struct *P012_data =
        static_cast<P012_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P012_data) {

        char deviceTemplate[P12_Nlines][P12_Nchars];
        LoadCustomTaskSettings(event->TaskIndex, reinterpret_cast<uint8_t *>(&deviceTemplate), sizeof(deviceTemplate));

        for (uint8_t x = 0; x < P012_data->Plugin_012_rows; x++)
        {
          String tmpString = deviceTemplate[x];

          if (tmpString.length())
          {
            String newString = P012_data->P012_parseTemplate(tmpString, P012_data->Plugin_012_cols);
            P012_data->lcdWrite(newString, 0, x);
          }
        }
        success = false;
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P012_data_struct *P012_data =
        static_cast<P012_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P012_data) {
        String cmd = parseString(string, 1);

        if (cmd.equalsIgnoreCase(F("LCDCMD")))
        {
          success = true;
          String arg1 = parseString(string, 2);

          if (arg1.equalsIgnoreCase(F("Off"))) {
            P012_data->lcd.noBacklight();
          }
          else if (arg1.equalsIgnoreCase(F("On"))) {
            P012_data->lcd.backlight();
          }
          else if (arg1.equalsIgnoreCase(F("Clear"))) {
            P012_data->lcd.clear();
          }
        }
        else if (cmd.equalsIgnoreCase(F("LCD")))
        {
          success = true;
          int colPos = event->Par2 - 1;
          int rowPos = event->Par1 - 1;
          String text = parseStringKeepCaseNoTrim(string, 4);
          text = P012_data->P012_parseTemplate(text, P012_data->Plugin_012_cols);

          P012_data->lcdWrite(text, colPos, rowPos);
        }
        break;
      }
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P013_HCSR04.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P013
# 26 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P013_HCSR04.ino"
#define PLUGIN_013 
#define PLUGIN_ID_013 13
#define PLUGIN_NAME_013 "Position - HC-SR04, RCW-0001, etc."
#define PLUGIN_VALUENAME1_013 "Distance"
#define PLUGIN_VALUENAME2_013 "State"

# include "src/PluginStructs/P013_data_struct.h"


std::map<unsigned int, std::shared_ptr<NewPing> > P_013_sensordefs;


float Plugin_013_read(struct EventStruct *event);
const __FlashStringHelper* Plugin_013_getErrorStatusString(struct EventStruct *event);

boolean Plugin_013(uint8_t function, struct EventStruct *event, String& string)
{
  static uint8_t switchstate[TASKS_MAX];
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_013;
      Device[deviceCount].Type = DEVICE_TYPE_DUAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_013);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_013));
      # if P013_FEATURE_COMBINED_MODE
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_013));
      # endif
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("Trigger"));
      event->String2 = formatGpioName_input(F("Echo, 5V"));
      break;
    }

    # if P013_FEATURE_COMBINED_MODE
    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P013_OPERATINGMODE == OPMODE_COMBINED ? 2 : 1;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(P013_OPERATINGMODE == OPMODE_COMBINED ? 2 : 1);
      event->idx = P013_OPERATINGMODE == OPMODE_COMBINED ? 2 : 1;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      P013_FILTER_SIZE = P013_DEFAULT_FILTER_SIZE;
      # if P013_FEATURE_TRIGGERWIDTH
      P013_TRIGGER_WIDTH = P013_DEFAULT_TRIGGER_WIDTH;
      # endif

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      const __FlashStringHelper *strUnit = (P013_MEASURINGUNIT == UNIT_CM) ? F("cm") : F("inch");

      {
        const int optionValuesOpMode[] = {
          OPMODE_VALUE,
          OPMODE_STATE,
          # if P013_FEATURE_COMBINED_MODE
          OPMODE_COMBINED,
          # endif
        };
        const __FlashStringHelper *optionsOpMode[] {
          F("Value"),
          F("State"),
          # if P013_FEATURE_COMBINED_MODE
          F("Combined"),
          # endif
        };
        addFormSelector(F("Mode"), F("pmode"),
                        # if P013_FEATURE_COMBINED_MODE
                        3
                        # else
                        2
                        # endif
                        , optionsOpMode, optionValuesOpMode, P013_OPERATINGMODE);
      }

      if ((P013_OPERATINGMODE == OPMODE_STATE)
          # if P013_FEATURE_COMBINED_MODE
          || (P013_OPERATINGMODE == OPMODE_COMBINED)
          # endif
          ) {
        # if P013_FEATURE_INTERVALEVENT
        addFormCheckBox(F("State event (also) on Interval"), F("pevent"), P013_SEND_STATE_VALUE == 0);
        # endif
        addFormNumericBox(F("Threshold"), F("thres"), P013_THRESHOLD);
        addUnit(strUnit);
      }
      addFormNumericBox(F("Max Distance"), F("max_d"), P013_MAX_DISTANCE, 0, 500);
      addUnit(strUnit);

      {
        const int optionValuesUnit[2] = { UNIT_CM, UNIT_INCH };
        const __FlashStringHelper *optionsUnit[] {
          F("Metric"),
          F("Imperial"),
        };
        addFormSelector(F("Unit"), F("pUnit"), 2, optionsUnit, optionValuesUnit, P013_MEASURINGUNIT);
      }

      {
        const int optionValuesFilter[2] = { FILTER_NONE, FILTER_MEDIAN };
        const __FlashStringHelper *optionsFilter[] {
          F("None"),
          F("Median"),
        };
        addFormSelector(F("Filter"), F("fltr"), 2, optionsFilter, optionValuesFilter, P013_FILTERTYPE);
      }


      if (P013_FILTERTYPE != FILTER_NONE) {
        addFormNumericBox(F("Number of Pings"), F("size"), P013_FILTER_SIZE, 2, 20);
        # if P013_EXTENDED_LOG
        addUnit(F("2..20"));
        # endif
      }

      # if P013_FEATURE_TRIGGERWIDTH
      addFormNumericBox(F("Trigger width"), F("wdth"), P013_TRIGGER_WIDTH, 10, 20);
      addUnit(F("10..20 &micro;sec"));
      # endif

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      int16_t prevOperatingMode = P013_OPERATINGMODE;
      int16_t prevFilterType = P013_FILTERTYPE;

      P013_OPERATINGMODE = getFormItemInt(F("pmode"));

      if ((prevOperatingMode == OPMODE_STATE)
          # if P013_FEATURE_COMBINED_MODE
          || (prevOperatingMode == OPMODE_COMBINED)
          # endif
          ) {
        # if P013_FEATURE_INTERVALEVENT
        P013_SEND_STATE_VALUE = isFormItemChecked(F("pevent")) ? 0 : 1;
        # endif
        P013_THRESHOLD = getFormItemInt(F("thres"));
      }
      # if P013_FEATURE_COMBINED_MODE

      if ((P013_OPERATINGMODE == OPMODE_COMBINED) && (ExtraTaskSettings.TaskDeviceValueNames[1][0] == '\0')) {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_013));
      }
      # endif
      P013_MAX_DISTANCE = getFormItemInt(F("max_d"));

      P013_MEASURINGUNIT = getFormItemInt(F("pUnit"));
      P013_FILTERTYPE = getFormItemInt(F("fltr"));

      if (prevFilterType != FILTER_NONE) {
        P013_FILTER_SIZE = getFormItemInt(F("size"));
      }
      # if P013_FEATURE_TRIGGERWIDTH
      P013_TRIGGER_WIDTH = getFormItemInt(F("wdth"));
      # endif

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      if (P013_FILTER_SIZE == 0) { P013_FILTER_SIZE = P013_DEFAULT_FILTER_SIZE; }

      # if P013_FEATURE_TRIGGERWIDTH

      if (P013_TRIGGER_WIDTH == 0) { P013_TRIGGER_WIDTH = P013_DEFAULT_TRIGGER_WIDTH; }
      # endif

      int16_t max_distance_cm = (P013_MEASURINGUNIT == UNIT_CM) ? P013_MAX_DISTANCE : static_cast<float>(P013_MAX_DISTANCE) * 2.54f;


      P_013_sensordefs.erase(event->TaskIndex);
      P_013_sensordefs[event->TaskIndex] = std::shared_ptr<NewPing>(new NewPing(P013_TRIGGER_PIN,
                                                                                P013_ECHO_PIN,
                                                                                max_distance_cm,
                                                                                P013_TRIGGER_WIDTH));
      success = true;

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log = F("ULTRASONIC : TaskNr: ");
        log += event->TaskIndex + 1;
        log += F(" TrigPin: ");
        log += P013_TRIGGER_PIN;
        log += F(" IRQ_Pin: ");
        log += P013_ECHO_PIN;

        if (nullptr != P_013_sensordefs[event->TaskIndex]) {
          # if P013_EXTENDED_LOG
          log += F(" width [usec]: ");
          log += P013_TRIGGER_WIDTH;
          log += F(" max dist ");
          log += (P013_MEASURINGUNIT == UNIT_CM) ? F("[cm]: ") : F("[inch]: ");
          log += P013_MAX_DISTANCE;

          log += F(" max echo: ");
          log += P_013_sensordefs[event->TaskIndex]->getMaxEchoTime();
          log += F(" Filter: ");

          if (P013_FILTERTYPE == FILTER_NONE) {
            log += F("none");
          }
          else if (P013_FILTERTYPE == FILTER_MEDIAN) {
            log += F("Median size: ");
            log += P013_FILTER_SIZE;
          } else {
            log += F("invalid!");
          }

          log += F(" nr_tasks: ");
          log += P_013_sensordefs.size();
          # endif
        } else {
          log += F(" CONSTRUCTOR FAILED!");
          success = false;
        }
        addLogMove(LOG_LEVEL_INFO, log);
      }

      break;
    }

    case PLUGIN_EXIT:
    {
      P_013_sensordefs.erase(event->TaskIndex);
      break;
    }

    case PLUGIN_READ:
    {
      if ((P013_OPERATINGMODE == OPMODE_VALUE)
          # if P013_FEATURE_COMBINED_MODE
          || (P013_OPERATINGMODE == OPMODE_COMBINED)
          # endif
          ) {
        const float value = Plugin_013_read(event);
        UserVar.setFloat(event->TaskIndex, 0, value);

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("ULTRASONIC : TaskNr: ");
          log += event->TaskIndex + 1;
          # if P013_EXTENDED_LOG
          log += F(" Distance: ");
          log += formatUserVarNoCheck(event->TaskIndex, 0);
          log += ' ';
          log += (P013_MEASURINGUNIT == UNIT_CM) ? F("cm") : F("inch");
          # endif

          if (essentiallyEqual(value, NO_ECHO)) {
            log += F(" Error: ");
            log += Plugin_013_getErrorStatusString(event);
          }

          addLogMove(LOG_LEVEL_INFO, log);
        }
        success = true;
      } else {
        # if P013_FEATURE_INTERVALEVENT

        if (P013_SEND_STATE_VALUE == 0) {
          success = true;
        }
        # else
        success = true;
        # endif
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      if ((P013_OPERATINGMODE == OPMODE_STATE)
          # if P013_FEATURE_COMBINED_MODE
          || (P013_OPERATINGMODE == OPMODE_COMBINED)
          # endif
          ) {
        uint8_t state = 0;
        const float value = Plugin_013_read(event);

        if (!essentiallyEqual(value, NO_ECHO) && definitelyLessThan(value, P013_THRESHOLD)) {
          state = 1;
        }

        if (state != switchstate[event->TaskIndex]) {
          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log = F("ULTRASONIC : TaskNr: ");
            log += event->TaskIndex + 1;

            if (value != NO_ECHO) {
              log += F(" state: ");
              log += state;
            } else {
              log += F(" Error: ");
              log += Plugin_013_getErrorStatusString(event);
            }
            addLogMove(LOG_LEVEL_INFO, log);
          }
          switchstate[event->TaskIndex] = state;
          UserVar.setFloat(event->TaskIndex, 0, state);
          event->sensorType = Sensor_VType::SENSOR_TYPE_SWITCH;
          sendData(event);
        }
      }
      success = true;

      break;
    }
  }
  return success;
}


float Plugin_013_read(struct EventStruct *event)


{
  if (P_013_sensordefs.count(event->TaskIndex) == 0u) {
    return 0.0f;
  }

  int16_t max_distance_cm = (P013_MEASURINGUNIT == UNIT_CM) ? P013_MAX_DISTANCE : static_cast<float>(P013_MAX_DISTANCE) * 2.54f;

  unsigned int echoTime = 0;

  switch (P013_FILTERTYPE) {
    case FILTER_NONE:
      echoTime = (P_013_sensordefs[event->TaskIndex])->ping();
      break;
    case FILTER_MEDIAN:
      echoTime = (P_013_sensordefs[event->TaskIndex])->ping_median(P013_FILTER_SIZE, max_distance_cm);
      break;
    # if P013_EXTENDED_LOG
    default:
      addLog(LOG_LEVEL_ERROR, F("invalid Filter Type setting!"));
    # endif
  }

  if (P013_MEASURINGUNIT == UNIT_CM) {
    return NewPing::convert_cm_F(echoTime);
  }
  else {
    return NewPing::convert_in_F(echoTime);
  }
}


const __FlashStringHelper* Plugin_013_getErrorStatusString(struct EventStruct *event)


{
  if (P_013_sensordefs.count(event->TaskIndex) == 0) {
    return F("invalid taskindex");
  }

  switch ((P_013_sensordefs[event->TaskIndex])->getErrorState()) {
    case NewPing::STATUS_SENSOR_READY: {
      # if P013_EXTENDED_LOG
      return F("Sensor ready");
      # endif
    }

    case NewPing::STATUS_MEASUREMENT_VALID: {
      # if P013_EXTENDED_LOG
      return F("no error, measurement valid");
      # endif
    }

    case NewPing::STATUS_ECHO_TRIGGERED: {
      # if P013_EXTENDED_LOG
      return F("Echo triggered, waiting for Echo end");
      # else
      return F("Ok");
      # endif
    }

    case NewPing::STATUS_ECHO_STATE_ERROR: {
      return F("Error, Echopin not low on trigger");
    }

    case NewPing::STATUS_ECHO_START_TIMEOUT_50ms: {
      return F("Error, no echo start whithin 50 ms");
    }

    case NewPing::STATUS_ECHO_START_TIMEOUT_DISTANCE: {
      return F("Error, no echo start whithin time for max. distance");
    }

    case NewPing::STATUS_MAX_DISTANCE_EXCEEDED: {
      return F("Echo too late, maximum distance exceeded");
    }

    default: {
      return F("unknown error");
    }
  }
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P014_SI70xx.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P014
# 24 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P014_SI70xx.ino"
# include "src/PluginStructs/P014_data_struct.h"

#define PLUGIN_014 
#define PLUGIN_ID_014 14
#define PLUGIN_NAME_014 "Environment - SI70xx/HTU21D"
#define PLUGIN_VALUENAME1_014 "Temperature"
#define PLUGIN_VALUENAME2_014 "Humidity"
#define PLUGIN_VALUENAME3_014 "ADC"

#define P014_I2C_ADDRESS PCONFIG(1)
#define P014_RESOLUTION PCONFIG(0)
#define P014_FILTER_POWER PCONFIG(2)
#define P014_ERROR_STATE_OUTPUT PCONFIG(3)
#define P014_VALUES_COUNT PCONFIG(4)

boolean Plugin_014(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_014;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_HUM;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].I2CNoDeviceCheck = true;


      Device[deviceCount].PluginStats = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::All;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_014);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_014));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_014));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_014));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P014_VALUES_COUNT = getValueCountFromSensorType(Sensor_VType::SENSOR_TYPE_TEMP_HUM);
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { SI70xx_I2C_ADDRESS, SI7013_I2C_ADDRESS_AD0_1 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, P014_I2C_ADDRESS);
        addFormNote(F("ADO Low=0x40, High=0x41"));
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }

      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P014_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      # define P014_RESOLUTION_OPTIONS 4

      const __FlashStringHelper *options[P014_RESOLUTION_OPTIONS] = {
        F("Temp 14 bits / RH 12 bits"),
        F("Temp 13 bits / RH 10 bits"),
        F("Temp 12 bits / RH  8 bits"),
        F("Temp 11 bits / RH 11 bits"),
      };
      const int optionValues[P014_RESOLUTION_OPTIONS] = {
        SI70xx_RESOLUTION_14T_12RH,
        SI70xx_RESOLUTION_13T_10RH,
        SI70xx_RESOLUTION_12T_08RH,
        SI70xx_RESOLUTION_11T_11RH,
      };
      addFormSelector(F("Resolution"), F("pres"), P014_RESOLUTION_OPTIONS, options, optionValues, P014_RESOLUTION);

      addFormNumericBox("ADC Filter Power", F("pfilter"), P014_FILTER_POWER, 0, 4);



      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P014_I2C_ADDRESS = getFormItemInt(F("i2c_addr"));
      P014_RESOLUTION = getFormItemInt(F("pres"));
      P014_FILTER_POWER = getFormItemInt(F("pfilter"));







      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = getValueCountFromSensorType(static_cast<Sensor_VType>(P014_VALUES_COUNT));
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(P014_VALUES_COUNT);
      event->idx = 4;
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P014_data_struct());
      UserVar.setFloat(event->TaskIndex, 0, NAN);
      UserVar.setFloat(event->TaskIndex, 1, NAN);
      UserVar.setFloat(event->TaskIndex, 2, NAN);
      break;
    }


    case PLUGIN_READ:
    {
      if (P014_I2C_ADDRESS == 0) {
        P014_I2C_ADDRESS = SI70xx_I2C_ADDRESS;
      }

      event->sensorType = static_cast<Sensor_VType>(P014_VALUES_COUNT);

      P014_data_struct *P014_data = static_cast<P014_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P014_data) {
        if (P014_data->state == P014_state::Error) {
          UserVar.setFloat(event->TaskIndex, 0, NAN);
          UserVar.setFloat(event->TaskIndex, 1, NAN);
          UserVar.setFloat(event->TaskIndex, 2, NAN);

          addLog(LOG_LEVEL_ERROR, F("SI70xx: in Error!"));

          return false;
        }

        if (P014_data->state != P014_state::New_Values_Available) {
          P014_data->update(P014_I2C_ADDRESS, P014_RESOLUTION, P014_FILTER_POWER);
          Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + SI70xx_DELAY);

          return false;
        }

        UserVar.setFloat(event->TaskIndex, 0, P014_data->temperature / 100.0f);
        UserVar.setFloat(event->TaskIndex, 1, P014_data->humidity / 10.0f);

        if (P014_data->chip_id == CHIP_ID_SI7013) {
          UserVar.setFloat(event->TaskIndex, 2, (P014_data->adc) >> P014_FILTER_POWER);
        }

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("P014: Temperature: ");
          log += UserVar[event->BaseVarIndex + 0];
          log += F(" Humidity: ");
          log += UserVar[event->BaseVarIndex + 1];

          if (P014_data->chip_id == CHIP_ID_SI7013) {
            log += F(" ADC: ");
            log += UserVar[event->BaseVarIndex + 2];
          }
          addLog(LOG_LEVEL_INFO, log);
        }

        P014_data->state = P014_state::Ready;
        success = true;
      }
      break;
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P015_TSL2561.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P015
# 14 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P015_TSL2561.ino"
# include "src/PluginStructs/P015_data_struct.h"

#define PLUGIN_015 
#define PLUGIN_ID_015 15
#define PLUGIN_NAME_015 "Light/Lux - TSL2561"
#define PLUGIN_VALUENAME1_015 "Lux"
#define PLUGIN_VALUENAME2_015 "Infrared"
#define PLUGIN_VALUENAME3_015 "Broadband"
#define PLUGIN_VALUENAME4_015 "Ratio"


#define P015_I2C_ADDR PCONFIG(0)
#define P015_INTEGRATION PCONFIG(1)
#define P015_SLEEP PCONFIG(2)
#define P015_GAIN PCONFIG(3)


boolean Plugin_015(uint8_t function, struct EventStruct *event, String& string)
{
  bool success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_015;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_015);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_015));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_015));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_015));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_015));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { TSL2561_ADDR, TSL2561_ADDR_1, TSL2561_ADDR_0 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 3, i2cAddressValues, P015_I2C_ADDR);
      } else {
        success = intArrayContains(3, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P015_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        # define TSL2561_INTEGRATION_OPTION 3
        const __FlashStringHelper * options[TSL2561_INTEGRATION_OPTION] = {
          F("13.7 ms"),
          F("101 ms"),
          F("402 ms"),
        };
        const int optionValues[TSL2561_INTEGRATION_OPTION] = {
          0x00,
          0x01,
          0x02,
        };
        addFormSelector(F("Integration time"), F("pintegration"), TSL2561_INTEGRATION_OPTION, options, optionValues, P015_INTEGRATION);
      }

      addFormCheckBox(F("Send sensor to sleep:"), F("psleep"),
                      P015_SLEEP);

      {
        # define TSL2561_GAIN_OPTION 4
        const __FlashStringHelper *options[TSL2561_GAIN_OPTION] = {
          F("No Gain"),
          F("16x Gain"),
          F("Auto Gain"),
          F("Extended Auto Gain"),
        };
        const int optionValues[TSL2561_GAIN_OPTION] = {
          P015_NO_GAIN,
          P015_16X_GAIN,
          P015_AUTO_GAIN,
          P015_EXT_AUTO_GAIN,
        };
        addFormSelector(F("Gain"), F("pgain"), TSL2561_GAIN_OPTION, options, optionValues, P015_GAIN);
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P015_I2C_ADDR = getFormItemInt(F("i2c_addr"));
      P015_INTEGRATION = getFormItemInt(F("pintegration"));
      P015_SLEEP = isFormItemChecked(F("psleep"));
      P015_GAIN = getFormItemInt(F("pgain"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P015_data_struct(P015_I2C_ADDR, P015_GAIN, P015_INTEGRATION));
      break;
    }

    case PLUGIN_READ:
    {
      P015_data_struct *P015_data =
        static_cast<P015_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P015_data) {
        P015_data->begin();

        float luxVal, infraredVal, broadbandVal, ir_broadband_ratio{};

        success = P015_data->performRead(
          luxVal, infraredVal, broadbandVal, ir_broadband_ratio);
        UserVar.setFloat(event->TaskIndex, 0, luxVal);
        UserVar.setFloat(event->TaskIndex, 1, infraredVal);
        UserVar.setFloat(event->TaskIndex, 2, broadbandVal);
        UserVar.setFloat(event->TaskIndex, 3, ir_broadband_ratio);

        if (P015_SLEEP) {
          # ifndef BUILD_NO_DEBUG
          addLog(LOG_LEVEL_DEBUG, F("TSL2561: sleeping..."));
          # endif
          P015_data->setPowerDown();
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P016_IR.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P016
# 31 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P016_IR.ino"
# include <ArduinoJson.h>
# include <IRremoteESP8266.h>
# include <IRutils.h>
# include <IRrecv.h>
# include "src/Helpers/Memory.h"

# include <vector>
# include "src/PluginStructs/P016_data_struct.h"

# include "src/ESPEasyCore/Serial.h"

# ifdef P016_P035_Extended_AC
# include <IRac.h>
# endif

#define PLUGIN_016 
#define PLUGIN_ID_016 16
#define PLUGIN_NAME_016 "Communication - IR Receive (TSOP4838)"
#define PLUGIN_VALUENAME1_016 "IR"
#define P016_CMDINHIBIT PCONFIG(1)
#define P016_BUFFERSIZE PCONFIG(2)
#define P016_SETTINGS_VERSION PCONFIG(7)

# ifndef P016_SEND_IR_TO_CONTROLLER
#define P016_SEND_IR_TO_CONTROLLER false
# endif
# 111 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P016_IR.ino"
const uint8_t P016_TIMEOUT = 50;
# 142 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P016_IR.ino"
const uint16_t kMinUnknownSize = 12;



IRrecv *irReceiver = nullptr;
bool bEnableIRcodeAdding = false;
# ifdef P016_P035_USE_RAW_RAW2


boolean displayRawToReadableB32Hex(String& outputStr, decode_results results);

# endif

# ifdef PLUGIN_016_DEBUG
void P016_infoLogMemory(const __FlashStringHelper *text) {
  if (loglevelActiveFor(LOG_LEVEL_INFO)) {
    String log;

    if (log.reserve(40 + strlen_P((PGM_P)text))) {
      log += F("P016: Free memory ");
      log += text;
      log += F(": ");
      log += FreeMem();
      log += F(" stack: ");
      log += getCurrentFreeStack();
      addLogMove(LOG_LEVEL_INFO, log);
    }
  }
}

# endif

boolean Plugin_016(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_016;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
#if P016_SEND_IR_TO_CONTROLLER
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_STRING;
#else
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_ULONG;
#endif
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = true;
      Device[deviceCount].InverseLogicOption = true;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].TimerOptional = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_016);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_016));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_input(F("IR"));
      break;
    }

    case PLUGIN_INIT:
    {
      # ifdef PLUGIN_016_DEBUG
      addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_INIT ..."));
      # endif

      initPluginTaskData(event->TaskIndex, new (std::nothrow) P016_data_struct());
      P016_data_struct *P016_data =
        static_cast<P016_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P016_data) {
        return success;
      }
      P016_data->init(event, P016_CMDINHIBIT);

      int irPin = CONFIG_PIN1;

      if ((irReceiver == nullptr) && validGpio(irPin))
      {
        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          addLog(LOG_LEVEL_INFO, F("INIT: IR RX"));
          addLog(LOG_LEVEL_INFO, F("IR lib Version: " _IRREMOTEESP8266_VERSION_));
        }

        uint16_t bufsize = P016_BUFFERSIZE;

        if ((bufsize < P016_MIN_BUFFERSIZE) || (bufsize > P016_MAX_BUFFERSIZE)) { bufsize = P016_DEFAULT_BUFFERSIZE; }

        irReceiver = new (std::nothrow) IRrecv(irPin, bufsize, P016_TIMEOUT, true);
        # ifdef PLUGIN_016_DEBUG
        addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_INIT IR receiver created"));
        # endif

        if (nullptr != irReceiver) {
          irReceiver->setUnknownThreshold(kMinUnknownSize);
          irReceiver->enableIRIn();
          # ifdef PLUGIN_016_DEBUG
          addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_INIT IR receiver initialized"));
          # endif
        }
      }
# 270 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P016_IR.ino"
      # ifdef PLUGIN_016_DEBUG
      addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_INIT done"));
      # endif

      success = true;
      break;
    }
    case PLUGIN_EXIT:
    {
      # ifdef PLUGIN_016_DEBUG
      addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_EXIT ..."));
      # endif

      if (nullptr != irReceiver)
      {
        irReceiver->disableIRIn();
        delete irReceiver;
        irReceiver = nullptr;
        # ifdef PLUGIN_016_DEBUG
        addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_EXIT IR receiver destroyed"));
        # endif
      }

      # ifdef PLUGIN_016_DEBUG
      addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_EXIT done"));
      # endif
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      # ifdef PLUGIN_016_DEBUG
      addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_SET_DEFAULTS ..."));
      # endif

      P016_BUFFERSIZE = P016_DEFAULT_BUFFERSIZE;
      P016_SETTINGS_VERSION = P16_SETTINGS_LATEST;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      # ifdef PLUGIN_016_DEBUG
      addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_WEBFORM_LOAD ..."));
      P016_infoLogMemory(F("before load"));
      # endif

      addRowLabel(F("Info"));
      addHtml(F("Check serial or web log for replay solutions via Communication - IR Transmit plugin"));

      addFormNumericBox(F("Receiver buffer size"), F("pbuffersize"), P016_BUFFERSIZE * 2, P016_MIN_BUFFERSIZE * 2, P016_MAX_BUFFERSIZE * 2);
      String unit;
      unit += P016_MIN_BUFFERSIZE * 2;
      unit += F("..");
      unit += P016_MAX_BUFFERSIZE * 2;
      unit += F(" bytes");
      addUnit(unit);
      addFormNote(F("Increase buffer size if IR commands are received incomplete."));


      addFormSubHeader(F("Content"));

      # if P016_FEATURE_COMMAND_HANDLING
      bool bAddNewCode = bitRead(PCONFIG_LONG(0), P016_BitAddNewCode);
      addFormCheckBox(F("Add new received code to command lines"), F("pAddNewCode"), bAddNewCode);
      bool bExecuteCmd = bitRead(PCONFIG_LONG(0), P016_BitExecuteCmd);
      addFormCheckBox(F("Execute commands"), F("pExecuteCmd"), bExecuteCmd);
      # endif
      bool bAcceptUnknownType = bitRead(PCONFIG_LONG(0), P016_BitAcceptUnknownType);
      addFormCheckBox(F("Accept DecodeType UNKNOWN"), F("pAcceptUnknownType"), bAcceptUnknownType);
      # if P016_FEATURE_COMMAND_HANDLING
      addFormNumericBox(F("Inhibit time for the same command [ms]"),
                        F("pcmdinhibit"),
                        P016_CMDINHIBIT,
                        1,
                        2000);

      {
        {
          addFormSubHeader(F("Code - command map"));

          int size = static_cast<int>(decode_type_t::kLastDecodeType) + 1;


          std::vector<String>decodeTypes;
          std::vector<int>decodeTypeOptions;

          int protocolCount = 0;

          for (int i = 0; i < size; i++) {
            const String protocol = typeToString(static_cast<decode_type_t>(i), false);

            if (protocol.length() > 1) {
              decodeTypeOptions.push_back(i);
              decodeTypes.push_back(protocol);
              protocolCount++;
            }


            delay(0);
          }

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log;

            if (log.reserve(30)) {
              log += F("IR: available decodetypes: ");
              log += protocolCount;
              addLogMove(LOG_LEVEL_INFO, log);
            }
          }

          const String P016_HEX_INPUT_PATTERN = F("(0x)?[0-9a-fA-F]{0,16}");

          addRowLabel(F("Code"));
          html_table(F("sub tworow"));
          html_table_header(F("&nbsp;#&nbsp;"));
          html_table_header(F("Decode type"));
          html_table_header(F("Repeat"));
          html_table_header(F("Code [Hex]"));
          html_table_header(F("Alt. Decode type"));
          html_table_header(F("Repeat"));
          html_table_header(F("Alt. Code [Hex]"));
          html_TR();

          int rowCnt = 0;

          String strCode;
          strCode.reserve(20);

          for (uint8_t varNr = 0; varNr < P16_Nlines; varNr++) {
            tCommandLinesV2 line;
            P016_data_struct::loadCommandLine(event, line, varNr);

            html_TR_TD();

            if (varNr < 9) {
              addHtml(F("&nbsp;"));
            }
            addHtmlInt(varNr + 1);
            html_TD();
            {
              addSelector(getPluginCustomArgName(rowCnt + 0), protocolCount, &decodeTypes[0], &decodeTypeOptions[0], nullptr,
                          static_cast<int>(line.CodeDecodeType), false, true, F(""));
            }
            html_TD();
            addCheckBox(getPluginCustomArgName(rowCnt + 1), bitRead(line.CodeFlags, P16_FLAGS_REPEAT));
            html_TD();
            strCode.clear();

            if (line.Code > 0) {
              strCode = uint64ToString(line.Code, 16);
            }
            addTextBox(getPluginCustomArgName(rowCnt + 2), strCode, P16_Cchars - 1, false, false, P016_HEX_INPUT_PATTERN, F(""));

            html_TD();
            {
              addSelector(getPluginCustomArgName(rowCnt + 3), protocolCount, &decodeTypes[0], &decodeTypeOptions[0], nullptr,
                          static_cast<int>(line.AlternativeCodeDecodeType), false, true, F(""));
            }
            html_TD();
            addCheckBox(getPluginCustomArgName(rowCnt + 4), bitRead(line.AlternativeCodeFlags, P16_FLAGS_REPEAT));
            html_TD();
            strCode.clear();

            if (line.AlternativeCode > 0) {
              strCode = uint64ToString(line.AlternativeCode, 16);
            }
            addTextBox(getPluginCustomArgName(rowCnt + 5), strCode, P16_Cchars - 1, false, false, P016_HEX_INPUT_PATTERN, F(""));

            html_TR();

            addHtml(F("<TD colspan=\"2\" style=\"text-align:right\">"));
            addHtml(F("Command "));
            addHtmlInt(varNr + 1);
            addHtml(':');
            addHtml(F("<TD colspan=\"5\">"));
            addTextBox(getPluginCustomArgName(rowCnt + 6), String(line.Command), P16_Nchars - 1);

            rowCnt += 7;
            delay(0);
          }
          html_end_table();
        }

        if (P016_SETTINGS_VERSION != P16_SETTINGS_LATEST) {
          addFormNote(F("These settings are converted from a previous version and will be stored in updated format when submitted."));
        }
      }

      # endif

      # ifdef PLUGIN_016_DEBUG
      P016_infoLogMemory(F("after load"));
      addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_WEBFORM_LOAD done"));
      # endif

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      # ifdef PLUGIN_016_DEBUG
      addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_WEBFORM_SAVE ..."));
      # endif

      P016_SETTINGS_VERSION = P16_SETTINGS_LATEST;


      Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 10);

      uint32_t lSettings = 0;
      # if P016_FEATURE_COMMAND_HANDLING
      bitWrite(lSettings, P016_BitAddNewCode, isFormItemChecked(F("pAddNewCode")));
      bitWrite(lSettings, P016_BitExecuteCmd, isFormItemChecked(F("pExecuteCmd")));
      # endif
      bitWrite(lSettings, P016_BitAcceptUnknownType, isFormItemChecked(F("pAcceptUnknownType")));

      bEnableIRcodeAdding = true;
      PCONFIG_LONG(0) = lSettings;
      # if P016_FEATURE_COMMAND_HANDLING
      P016_CMDINHIBIT = getFormItemInt(F("pcmdinhibit"));
      # endif
      P016_BUFFERSIZE = (getFormItemInt(F("pbuffersize")) + 1) >> 1;

      # if P016_FEATURE_COMMAND_HANDLING

      {
        # ifdef PLUGIN_016_DEBUG
        P016_infoLogMemory(F("before save"));
        # endif

        String strError;
        strError.reserve(30);

        int rowCnt = 0;

        for (uint8_t varNr = 0; varNr < P16_Nlines; varNr++) {
          tCommandLinesV2 line;

          strError.clear();


          line.CodeDecodeType = static_cast<decode_type_t>(getFormItemIntCustomArgName(rowCnt + 0));
          bitWrite(line.CodeFlags, P16_FLAGS_REPEAT, isFormItemChecked(getPluginCustomArgName(rowCnt + 1)));
          line.Code = 0;

          char strCode[P16_Cchars] = { 0 };

          if (!safe_strncpy(strCode, webArg(getPluginCustomArgName(rowCnt + 2)), P16_Cchars)) {
            strError += F("Code ");
            strError += (varNr + 1);
            strError += ' ';
          } else {
            line.Code = hexToULL(strCode);
          }

          delay(0);


          line.AlternativeCodeDecodeType =
            static_cast<decode_type_t>(getFormItemIntCustomArgName(rowCnt + 3));
          bitWrite(line.AlternativeCodeFlags, P16_FLAGS_REPEAT,
                   isFormItemChecked(getPluginCustomArgName(rowCnt + 4)));
          line.AlternativeCode = 0;

          if (!safe_strncpy(strCode, webArg(getPluginCustomArgName(rowCnt + 5)), P16_Cchars)) {
            strError += F("Alt.Code ");
            strError += (varNr + 1);
            strError += ' ';
          } else {
            line.AlternativeCode = hexToULL(strCode);
          }


          if (!safe_strncpy(line.Command, webArg(getPluginCustomArgName(rowCnt + 6)), P16_Nchars)) {
            strError += F("Command ");
            strError += (varNr + 1);
          }
          line.Command[P16_Nchars - 1] = 0;

          if (!strError.isEmpty()) {
            addHtmlError(strError);
          }

          rowCnt += 7;
          delay(0);

          P016_data_struct::saveCommandLine(event, line, varNr);
        }

        # ifdef PLUGIN_016_DEBUG
        P016_infoLogMemory(F("after save"));
        # endif
      }
      # endif

      # ifdef PLUGIN_016_DEBUG
      addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_WEBFORM_SAVE Done"));
      # endif
      success = true;
      break;
    }

    # if P016_FEATURE_COMMAND_HANDLING
    case PLUGIN_ONCE_A_SECOND:
    {
      P016_data_struct *P016_data =
        static_cast<P016_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P016_data) {
        if (P016_data->bCodeChanged) {
          P016_data->saveCommandLines(event);
          P016_data->bCodeChanged = false;
          # ifdef PLUGIN_016_DEBUG
          addLog(LOG_LEVEL_INFO, F("P016_PLUGIN_ONCE_A_SECOND CustomTaskSettings Saved"));
          # endif
        }
      }
      success = true;
      break;
    }
    # endif

    case PLUGIN_TEN_PER_SECOND:
    {
      decode_results results;

      if (irReceiver->decode(&results))
      {
        yield();

        if (results.overflow)
        {
          addLog(LOG_LEVEL_ERROR, F("IR: WARNING, IR code is too big for buffer. Try pressing the transmiter button only momenteraly"));
          success = false;
          break;
        }


        if ((results.decode_type != decode_type_t::UNKNOWN) || (bitRead(PCONFIG_LONG(0), P016_BitAcceptUnknownType)))
        {
          {
            String output;
            output.reserve(100);






            output += F("{\"protocol\":\"");
            output += typeToString(results.decode_type, results.repeat);
            output += F("\",\"data\":\"");
            output += resultToHexidecimal(&results);
            output += F("\",\"bits\":");
            output += uint64ToString(results.bits);
            output += '}';

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String Log;

              if (Log.reserve(output.length() + 22)) {
                Log += F("IRSEND,\'");
                Log += output;
                Log += F("\' type: 0x");
                Log += uint64ToString(results.decode_type);
                addLogMove(LOG_LEVEL_INFO, Log);
              }
            }
            event->String2 = std::move(output);
          }

          # if P016_FEATURE_COMMAND_HANDLING


          P016_data_struct *P016_data =
            static_cast<P016_data_struct *>(getPluginTaskData(event->TaskIndex));

          if (nullptr != P016_data) {

            uint64_t iCode = 0;
            decode_type_t iCodeDecodeType = results.decode_type;
            uint16_t iCodeFlags = 0;
            bitWrite(iCodeFlags, P16_FLAGS_REPEAT, results.repeat);
            String strCode = resultToHexidecimal(&results);

            if (strCode.length() <= P16_Cchars) {
              iCode += hexToULL(strCode);

              if (iCodeDecodeType == decode_type_t::UNKNOWN) {

                iCodeDecodeType = decode_type_t::RAW;
              }

              if (bitRead(PCONFIG_LONG(0), P016_BitAddNewCode) && bEnableIRcodeAdding) {
                P016_data->AddCode(iCode, iCodeDecodeType, iCodeFlags);
              }

              if (bitRead(PCONFIG_LONG(0), P016_BitExecuteCmd)) {
                P016_data->ExecuteCode(iCode, iCodeDecodeType, iCodeFlags);
              }
            }
          }
          # endif
        }

        if (!bitRead(PCONFIG_LONG(0), P016_BitAcceptUnknownType)) {


          # ifdef P016_P035_USE_RAW_RAW2

          if ((results.decode_type == decode_type_t::UNKNOWN) && !displayRawToReadableB32Hex(event->String2, results))
          # else

          if (results.decode_type == decode_type_t::UNKNOWN)
          # endif
          {
            addLog(LOG_LEVEL_INFO,
                   F("IR: No replay solutions found! Press button again or try RAW encoding (timings are in the serial output)"));
            serialPrint(F("IR: RAW TIMINGS: "));
            serialPrint(resultToSourceCode(&results));
            event->String2 = F("NaN");
            yield();



          }
        }

        # ifdef P016_P035_Extended_AC



        stdAc::state_t state;


        state.protocol = decode_type_t::UNKNOWN;
        state.model = -1;
        state.power = false;
        state.mode = stdAc::opmode_t::kAuto;
        state.celsius = true;
        state.degrees = 22;
        state.fanspeed = stdAc::fanspeed_t::kAuto;
        state.swingv = stdAc::swingv_t::kAuto;
        state.swingh = stdAc::swingh_t::kAuto;
        state.quiet = false;
        state.turbo = false;
        state.econo = false;
        state.light = false;
        state.filter = false;
        state.clean = false;
        state.beep = false;
        state.sleep = -1;
        state.clock = -1;

        String description = IRAcUtils::resultAcToString(&results);

        if (!description.isEmpty()) {
          if (loglevelActiveFor(LOG_LEVEL_INFO)) {

            String log;

            if (log.reserve(10 + description.length())) {
              log += F("AC State: ");
              log += description;
              addLogMove(LOG_LEVEL_INFO, log);
            }
          }
        }

        if (IRac::isProtocolSupported(results.decode_type) &&
            (typeToString(results.decode_type).length() > 1))
        {
          IRAcUtils::decodeToState(&results, &state);
          DynamicJsonDocument doc(300);


          doc[F("protocol")] = typeToString(state.protocol);

          if (state.model >= 0) {
            doc[F("model")] = irutils::modelToStr(state.protocol, state.model);
          }
          doc[F("power")] = IRac::boolToString(state.power);
          doc[F("mode")] = IRac::opmodeToString(state.mode);

          doc[F("temp")] = state.degrees;

          if (!state.celsius) {
            doc[F("use_celsius")] = IRac::boolToString(state.celsius);
          }

          if (state.fanspeed != stdAc::fanspeed_t::kAuto) {
            doc[F("fanspeed")] = IRac::fanspeedToString(state.fanspeed);
          }

          if (state.swingv != stdAc::swingv_t::kAuto) {
            doc[F("swingv")] = IRac::swingvToString(state.swingv);
          }

          if (state.swingh != stdAc::swingh_t::kAuto) {
            doc[F("swingh")] = IRac::swinghToString(state.swingh);
          }

          if (state.quiet) {
            doc[F("quiet")] = IRac::boolToString(state.quiet);
          }

          if (state.turbo) {
            doc[F("turbo")] = IRac::boolToString(state.turbo);
          }

          if (state.econo) {
            doc[F("econo")] = IRac::boolToString(state.econo);
          }

          if (!state.light) {
            doc[F("light")] = IRac::boolToString(state.light);
          }

          if (state.filter) {
            doc[F("filter")] = IRac::boolToString(state.filter);
          }

          if (state.clean) {
            doc[F("clean")] = IRac::boolToString(state.clean);
          }

          if (state.beep) {
            doc[F("beep")] = IRac::boolToString(state.beep);
          }

          if (state.sleep > 0) {
            doc[F("sleep")] = state.sleep;
          }

          if (state.clock >= 0) {
            doc[F("clock")] = state.clock;
          }
          serializeJson(doc, event->String2);

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {

            String log;

            if (log.reserve(12 + event->String2.length())) {
              log += F("IRSENDAC,'");
              log += event->String2;
              log += '\'';
              addLogMove(LOG_LEVEL_INFO, log);
            }
          }
        }
        # endif

#if !P016_SEND_IR_TO_CONTROLLER
        {
          unsigned long IRcode = results.value;
          UserVar.setSensorTypeLong(event->TaskIndex, IRcode);
        }
#endif
        sendData(event);
      }
      success = true;
      break;
    }
  }
  return success;
}

# ifdef P016_P035_USE_RAW_RAW2
#define PCT_TOLERANCE 8u
#define pct_tolerance(v) ((v) / (100u / PCT_TOLERANCE))



#define get_tolerance(v) (pct_tolerance(v))
#define MIN_VIABLE_DIV 40u
#define to_32hex(c) ((c) < 10 ? (c) + '0' : (c) + 'A' - 10)
# 861 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P016_IR.ino"
boolean displayRawToReadableB32Hex(String& outputStr, decode_results results)
{
  uint16_t div[2];

  # ifndef BUILD_NO_DEBUG


  if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
    String line;

    for (uint16_t i = 1; i < results.rawlen; i++) {
      line += uint64ToString(results.rawbuf[i] * RAWTICK, 10) + ",";
    }
    addLogMove(LOG_LEVEL_DEBUG, line);
  }
  # endif


  for (uint16_t p = 0; p < 2; p++)
  {
    uint16_t cd = 0xFFFFU;


    for (uint16_t i = 1 + p; i < results.rawlen; i += 2)
    {
      uint16_t val = results.rawbuf[i] * RAWTICK;

      if (cd > val) {
        cd = val;
      }
    }

    uint16_t bstDiv = -1, bstAvg = 0xFFFFU;
    float bstMul = 5000;
    cd += get_tolerance(cd) + 1;



    while (--cd >= MIN_VIABLE_DIV)
    {
      uint32_t avg = 0;
      uint16_t totTms = 0;


      for (uint16_t i = 1 + p; i < results.rawlen; i += 2)
      {
        uint16_t val = results.rawbuf[i] * RAWTICK;
        uint16_t rmdr = val >= cd ? val % cd : cd - val;

        if (rmdr > get_tolerance(val))
        {
          avg = 0xFFFFU;
          break;
        }
        avg += rmdr;
        totTms += val / cd + (cd > val ? 1 : 0);
      }

      if (avg == 0xFFFFU) {
        continue;
      }
      avg /= results.rawlen / 2;
      float avgTms = static_cast<float>(totTms) / (results.rawlen / 2);

      if ((avgTms <= bstMul) && (avg < bstAvg))
      {
        bstMul = avgTms;
        bstAvg = avg;
        bstDiv = cd;



      }
    }

    if (bstDiv == 0xFFFFU)
    {

      return false;
    }
    div[p] = bstDiv;

    # ifndef BUILD_NO_DEBUG

    if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
      String line;
      line = p ? F("Blank: ") : F("Pulse: ");
      line += F(" divisor=");
      line += uint64ToString(bstDiv, 10);
      line += F("  avgErr=");
      line += uint64ToString(bstAvg, 10);
      line += F(" avgMul=");
      line += uint64ToString((uint16_t)bstMul, 10);
      line += '.';
      line += ((char)((bstMul - (uint16_t)bstMul) * 10) + '0');
      addLogMove(LOG_LEVEL_DEBUG, line);
    }
    # endif
  }


  uint16_t total = results.rawlen - 1, tmOut[total];



  for (unsigned int i = 0; i < total; i++)
  {
    uint16_t val = results.rawbuf[i + 1] * RAWTICK;
    unsigned int dv = div[(i) & 1];
    unsigned int tm = val / dv + (val % dv > dv / 2 ? 1 : 0);
    tmOut[i] = tm;


  }



  char out[total];
  unsigned int iOut = 0, s = 2, d = 0;

  for (; s + 1 < total; d = s, s += 2)
  {
    unsigned int vals = 2;

    while (s + 1 < total && tmOut[s] == tmOut[d] && tmOut[s + 1] == tmOut[d + 1])
    {
      vals += 2;
      s += 2;
    }

    if ((iOut + 5 > sizeof(out)) || (tmOut[d] >= 32 * 32) || (tmOut[d + 1] >= 32 * 32) || (vals >= 64))
    {

      return false;
    }

    if ((vals > 4) || ((vals == 4) && ((tmOut[d] >= 32) || (tmOut[d + 1] >= 32))))
    {
      out[iOut++] = '*';
      out[iOut++] = to_32hex(vals / 2);
      vals = 2;
    }

    while (vals--) {
      iOut = storeB32Hex(out, iOut, tmOut[d++]);
    }
  }

  while (d < total) {
    iOut = storeB32Hex(out, iOut, tmOut[d++]);
  }

  out[iOut] = 0;

  outputStr.reserve(32 + iOut);
  outputStr += F("IRSEND,RAW2,");
  outputStr += out;
  outputStr += F(",38,");
  outputStr += uint64ToString(div[0], 10);
  outputStr += ',';
  outputStr += uint64ToString(div[1], 10);
  addLog(LOG_LEVEL_INFO, outputStr);
  return true;
}

unsigned int storeB32Hex(char out[], unsigned int iOut, unsigned int val)
{
  if (val >= 32)
  {
    out[iOut++] = '^';
    out[iOut++] = to_32hex(val / 32);
    val %= 32;
  }
  out[iOut++] = to_32hex(val);
  return iOut;
}

# endif

#endif

void enableIR_RX(boolean enable)
{
#ifdef PLUGIN_016

  if (irReceiver == 0) { return; }

  if (enable) {
    irReceiver->enableIRIn();
  } else {
    irReceiver->disableIRIn();
  }
#endif
}
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P017_PN532.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P017
# 15 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P017_PN532.ino"
#define PLUGIN_017 
#define PLUGIN_ID_017 17
#define PLUGIN_NAME_017 "RFID - PN532"
#define PLUGIN_VALUENAME1_017 "Tag"

#define PN532_I2C_ADDRESS 0x24

#define PN532_PREAMBLE (0x00)
#define PN532_STARTCODE1 (0x00)
#define PN532_STARTCODE2 (0xFF)
#define PN532_POSTAMBLE (0x00)
#define PN532_HOSTTOPN532 (0xD4)
#define PN532_PN532TOHOST (0xD5)
#define PN532_ACK_WAIT_TIME (5)
#define PN532_INVALID_ACK (-1)
#define PN532_TIMEOUT (-2)
#define PN532_INVALID_FRAME (-3)
#define PN532_NO_SPACE (-4)

#define PN532_COMMAND_GETFIRMWAREVERSION (0x02)
#define PN532_COMMAND_SAMCONFIGURATION (0x14)
#define PN532_COMMAND_INLISTPASSIVETARGET (0x4A)
#define PN532_RESPONSE_INLISTPASSIVETARGET (0x4B)
#define PN532_MIFARE_ISO14443A (0x00)
#define PN532_COMMAND_POWERDOWN (0x16)



#define PN532_TIMER_TYPE_REMOVE_TAG 1
#define PN532_TIMER_TYPE_START_READ_TAG 2
#define PN532_TIMER_TYPE_READ_TAG_RESPONSE 3

#define PN532_INTERVAL_BETWEEN_READS 300


#define PN532_DELAY_READ_TAG_RESPONSE 30

#define P017_AUTO_TAG_REMOVAL PCONFIG(0)
#define P017_EVENT_ON_TAG_REMOVAL PCONFIG(1)
#define P017_NO_TAG_DETECTED_VALUE PCONFIG_LONG(0)
#define P017_REMOVAL_TIMEOUT PCONFIG_LONG(1)






# include <GPIO_Direct_Access.h>



bool P017_handle_timer_in(struct EventStruct *event);
boolean Plugin_017_Init(int8_t resetPin);
uint8_t Plugin_017_readPassiveTargetID(uint8_t *uid,
                                        uint8_t *uidLength);
uint8_t Plugin_017_StartReadPassiveTargetID(uint8_t cardbaudrate);
uint32_t getFirmwareVersion(void);
void Plugin_017_powerDown(void);
int8_t Plugin_017_writeCommand(const uint8_t *header,
                                 uint8_t hlen);
int16_t Plugin_017_readResponse(uint8_t command,
                                 uint8_t buf[],
                                 uint8_t len);

boolean Plugin_017(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_017;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_ULONG;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_017);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_017));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x24);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x24;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      string = F("RST: ");
      string += formatGpioLabel(CONFIG_PIN3, false);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {

      addFormPinSelect(PinSelectPurpose::Generic, F("Reset Pin"), F("taskdevicepin3"), CONFIG_PIN3);

      const bool autoTagRemoval = P017_AUTO_TAG_REMOVAL == 0;
      addFormCheckBox(F("Automatic Tag removal"), F("tagremove"), autoTagRemoval);

      if (P017_REMOVAL_TIMEOUT == 0) {
        P017_REMOVAL_TIMEOUT = 500;
      }

      addFormNumericBox(F("Automatic Tag removal after"), F("removetime"), P017_REMOVAL_TIMEOUT, 250, 60000);
      addUnit(F("mSec."));


      addFormNumericBox(F("Value to set on Tag removal"), F("removevalue"), P017_NO_TAG_DETECTED_VALUE, 0, 2147483647);




      const bool eventOnRemoval = P017_EVENT_ON_TAG_REMOVAL == 1;
      addFormCheckBox(F("Event on Tag removal"), F("eventremove"), eventOnRemoval);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P017_AUTO_TAG_REMOVAL = isFormItemChecked(F("tagremove")) ? 0 : 1;
      P017_EVENT_ON_TAG_REMOVAL = isFormItemChecked(F("eventremove")) ? 1 : 0;
      P017_NO_TAG_DETECTED_VALUE = getFormItemInt(F("removevalue"));
      P017_REMOVAL_TIMEOUT = getFormItemInt(F("removetime"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {





      # ifdef P017_DEBUG_LOGIC_ANALYZER_PIN


      pinMode(P017_DEBUG_LOGIC_ANALYZER_PIN, OUTPUT);
      # endif
      # ifdef P017_DEBUG_LOGIC_ANALYZER_PIN_INIT


      pinMode(P017_DEBUG_LOGIC_ANALYZER_PIN_INIT, OUTPUT);
      # endif


      for (uint8_t x = 0; x < 3; x++)
      {
        if (Plugin_017_Init(CONFIG_PIN3)) {
          success = true;
          break;
        }
        delay(100);
      }
      Scheduler.setPluginTaskTimer(PN532_INTERVAL_BETWEEN_READS, event->TaskIndex, PN532_TIMER_TYPE_START_READ_TAG);
      break;
    }

    case PLUGIN_TASKTIMER_IN:
    {
      success = P017_handle_timer_in(event);
      break;
    }
  }
  return success;
}

bool P017_handle_timer_in(struct EventStruct *event)
{
  bool success = false;

  static unsigned long tempcounter = 0;
  static uint8_t errorCount = 0;

  switch (event->Par1) {
    case PN532_TIMER_TYPE_REMOVE_TAG:
    {
# ifdef P017_DEBUG_LOGIC_ANALYZER_PIN_INIT



      DIRECT_pinWrite(P017_DEBUG_LOGIC_ANALYZER_PIN_INIT, 0);
# endif


      if (P017_AUTO_TAG_REMOVAL == 0) {
        UserVar.setSensorTypeLong(event->TaskIndex, P017_NO_TAG_DETECTED_VALUE);
        addLog(LOG_LEVEL_INFO, F("RFID : Removed Tag"));

        if (P017_EVENT_ON_TAG_REMOVAL == 1) {
          sendData(event);
        }
        success = true;
      }
      break;
    }
    case PN532_TIMER_TYPE_START_READ_TAG:
    {
        # ifdef P017_DEBUG_LOGIC_ANALYZER_PIN


      DIRECT_pinWrite(P017_DEBUG_LOGIC_ANALYZER_PIN, 1);
        # endif


      if (Settings.isI2CEnabled()
          && ((DIRECT_pinRead(Settings.Pin_i2c_sda) == 0) || (DIRECT_pinRead(Settings.Pin_i2c_scl) == 0)))
      {
        addLog(LOG_LEVEL_ERROR, F("PN532: BUS error"));
        Plugin_017_Init(CONFIG_PIN3);
      }

      if (Plugin_017_StartReadPassiveTargetID(PN532_MIFARE_ISO14443A) == 0) {


        Scheduler.setPluginTaskTimer(PN532_DELAY_READ_TAG_RESPONSE, event->TaskIndex, PN532_TIMER_TYPE_READ_TAG_RESPONSE);
      }


      Scheduler.setPluginTaskTimer(PN532_INTERVAL_BETWEEN_READS, event->TaskIndex, PN532_TIMER_TYPE_START_READ_TAG);

      # ifdef P017_DEBUG_LOGIC_ANALYZER_PIN


      DIRECT_pinWrite(P017_DEBUG_LOGIC_ANALYZER_PIN, 0);
      # endif

      break;
    }
    case PN532_TIMER_TYPE_READ_TAG_RESPONSE:
    {
              # ifdef P017_DEBUG_LOGIC_ANALYZER_PIN


      DIRECT_pinWrite(P017_DEBUG_LOGIC_ANALYZER_PIN, 1);
        # endif

      uint8_t uid[] = { 0, 0, 0, 0, 0, 0, 0 };
      uint8_t uidLength;
      uint8_t error = Plugin_017_readPassiveTargetID(uid, &uidLength);

      # ifdef P017_DEBUG_LOGIC_ANALYZER_PIN


      DIRECT_pinWrite(P017_DEBUG_LOGIC_ANALYZER_PIN, 0);
      # endif


      if (error == 1)
      {
        errorCount++;

        if (loglevelActiveFor(LOG_LEVEL_ERROR)) {
          String log = F("PN532: Read error: ");
          log += errorCount;
          addLogMove(LOG_LEVEL_ERROR, log);
        }
      }
      else {
        errorCount = 0;
      }

      if (errorCount > 2)
      {
        Plugin_017_Init(CONFIG_PIN3);
      }


      if (error == 0) {
# ifdef P017_DEBUG_LOGIC_ANALYZER_PIN_INIT



        DIRECT_pinWrite(P017_DEBUG_LOGIC_ANALYZER_PIN_INIT, 1);
# endif

        unsigned long key = uid[0];

        for (uint8_t i = 1; i < 4; i++) {
          key <<= 8;
          key += uid[i];
        }
        unsigned long old_key = UserVar.getSensorTypeLong(event->TaskIndex);
        bool new_key = false;

        if (old_key != key) {
          UserVar.setSensorTypeLong(event->TaskIndex, key);
          new_key = true;
        }

        tempcounter++;

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("PN532: ");

          if (new_key) {
            log += F("New Tag: ");
          } else {
            log += F("Old Tag: ");
          }
          log += key;
          log += ' ';
          log += tempcounter;
          addLogMove(LOG_LEVEL_INFO, log);
        }

        if (new_key) { sendData(event); }
        uint32_t resetTimer = P017_REMOVAL_TIMEOUT;

        if (resetTimer < 250) { resetTimer = 250; }
        Scheduler.setPluginTaskTimer(resetTimer, event->TaskIndex, PN532_TIMER_TYPE_REMOVE_TAG);
      } else {
# ifdef P017_DEBUG_LOGIC_ANALYZER_PIN_INIT



        DIRECT_pinWrite(P017_DEBUG_LOGIC_ANALYZER_PIN_INIT, 0);
# endif
      }
      break;
    }
  }

  return success;
}




boolean Plugin_017_Init(int8_t resetPin)
{
# ifdef P017_DEBUG_LOGIC_ANALYZER_PIN_INIT


  DIRECT_pinWrite(P017_DEBUG_LOGIC_ANALYZER_PIN_INIT, 1);
# endif

  if (validGpio(resetPin))
  {
    if (loglevelActiveFor(LOG_LEVEL_INFO)) {
      String log = F("PN532: Reset on pin: ");
      log += resetPin;
      addLogMove(LOG_LEVEL_INFO, log);
    }
    pinMode(resetPin, OUTPUT);
    digitalWrite(resetPin, LOW);
    delay(100);
    digitalWrite(resetPin, HIGH);
    pinMode(resetPin, INPUT_PULLUP);
    delay(10);
  }

  I2C_wakeup(PN532_I2C_ADDRESS);
  delay(5);

  uint32_t versiondata = getFirmwareVersion();

  if (versiondata) {
    if (loglevelActiveFor(LOG_LEVEL_INFO)) {
      String log = F("PN532: Found chip PN5");
      log += formatToHex_no_prefix((versiondata >> 24) & 0xFF, 2);
      log += F(" FW: ");
      log += formatToHex_no_prefix((versiondata >> 16) & 0xFF, 2);
      log += '.';
      log += formatToHex_no_prefix((versiondata >> 8) & 0xFF, 2);
      addLogMove(LOG_LEVEL_INFO, log);
    }
  }
  else {
# ifdef P017_DEBUG_LOGIC_ANALYZER_PIN_INIT


    DIRECT_pinWrite(P017_DEBUG_LOGIC_ANALYZER_PIN_INIT, 0);
# endif

    return false;
  }

  uint8_t Plugin_017_pn532_packetbuffer[64] = { 0 };

  Plugin_017_pn532_packetbuffer[0] = PN532_COMMAND_SAMCONFIGURATION;
  Plugin_017_pn532_packetbuffer[1] = 0x01;
  Plugin_017_pn532_packetbuffer[2] = 0x2;
  Plugin_017_pn532_packetbuffer[3] = 0x01;

  if (Plugin_017_writeCommand(Plugin_017_pn532_packetbuffer, 4)) {
# ifdef P017_DEBUG_LOGIC_ANALYZER_PIN_INIT


    DIRECT_pinWrite(P017_DEBUG_LOGIC_ANALYZER_PIN_INIT, 0);
# endif

    return false;
  }


  I2C_wakeup(PN532_I2C_ADDRESS);
  delay(1);
# ifdef P017_DEBUG_LOGIC_ANALYZER_PIN_INIT


  DIRECT_pinWrite(P017_DEBUG_LOGIC_ANALYZER_PIN_INIT, 0);
# endif

  return true;
}




uint32_t getFirmwareVersion(void)
{
  uint32_t response;
  uint8_t Plugin_017_pn532_packetbuffer[64] = { 0 };

  Plugin_017_pn532_packetbuffer[0] = PN532_COMMAND_GETFIRMWAREVERSION;

  if (Plugin_017_writeCommand(Plugin_017_pn532_packetbuffer, 1)) {
    return 0;
  }


  int16_t status = Plugin_017_readResponse(
    PN532_COMMAND_GETFIRMWAREVERSION,
    Plugin_017_pn532_packetbuffer,
    sizeof(Plugin_017_pn532_packetbuffer));

  if (0 > status) {
    return 0;
  }

  response = Plugin_017_pn532_packetbuffer[0];
  response <<= 8;
  response |= Plugin_017_pn532_packetbuffer[1];
  response <<= 8;
  response |= Plugin_017_pn532_packetbuffer[2];
  response <<= 8;
  response |= Plugin_017_pn532_packetbuffer[3];

  return response;
}

void Plugin_017_powerDown(void)
{
  uint8_t Plugin_017_pn532_packetbuffer[64] = { 0 };

  Plugin_017_pn532_packetbuffer[0] = PN532_COMMAND_POWERDOWN;
  Plugin_017_pn532_packetbuffer[1] = 1 << 7;

  if (Plugin_017_writeCommand(Plugin_017_pn532_packetbuffer, 2)) {
    return;
  }


  Plugin_017_readResponse(
    PN532_COMMAND_POWERDOWN,
    Plugin_017_pn532_packetbuffer,
    sizeof(Plugin_017_pn532_packetbuffer));
}




uint8_t Plugin_017_StartReadPassiveTargetID(uint8_t cardbaudrate)
{
  uint8_t Plugin_017_pn532_packetbuffer[64] = { 0 };

  Plugin_017_pn532_packetbuffer[0] = PN532_COMMAND_INLISTPASSIVETARGET;
  Plugin_017_pn532_packetbuffer[1] = 1;
  Plugin_017_pn532_packetbuffer[2] = cardbaudrate;

  if (Plugin_017_writeCommand(Plugin_017_pn532_packetbuffer, 3)) {
    return 0x1;
  }
  return 0;
}

uint8_t Plugin_017_readPassiveTargetID(uint8_t *uid, uint8_t *uidLength)
{
  uint8_t Plugin_017_pn532_packetbuffer[64] = { 0 };


  const int16_t read_code = Plugin_017_readResponse(
    PN532_COMMAND_INLISTPASSIVETARGET,
    Plugin_017_pn532_packetbuffer,
    sizeof(Plugin_017_pn532_packetbuffer));

  if (read_code < 0) {




    I2C_wakeup(PN532_I2C_ADDRESS);

    return 0x2;
  }

  if (Plugin_017_pn532_packetbuffer[0] != 1) {
    return 0x3;
  }

  uint16_t sens_res = Plugin_017_pn532_packetbuffer[2];

  sens_res <<= 8;
  sens_res |= Plugin_017_pn532_packetbuffer[3];


  *uidLength = Plugin_017_pn532_packetbuffer[5];

  for (uint8_t i = 0; i < Plugin_017_pn532_packetbuffer[5]; i++) {
    uid[i] = Plugin_017_pn532_packetbuffer[6 + i];
  }





  return 0;
}




int8_t Plugin_017_writeCommand(const uint8_t *header, uint8_t hlen)
{
  Wire.beginTransmission(PN532_I2C_ADDRESS);

  Wire.write(PN532_PREAMBLE);
  Wire.write(PN532_STARTCODE1);
  Wire.write(PN532_STARTCODE2);

  uint8_t length = hlen + 1;

  Wire.write(length);
  Wire.write(~length + 1);

  Wire.write(PN532_HOSTTOPN532);
  uint8_t sum = PN532_HOSTTOPN532;

  for (uint8_t i = 0; i < hlen; i++) {
    if (Wire.write(header[i])) {
      sum += header[i];
    } else {
      return PN532_INVALID_FRAME;
    }
  }

  uint8_t checksum = ~sum + 1;

  Wire.write(checksum);
  Wire.write(PN532_POSTAMBLE);
  uint8_t status = Wire.endTransmission();

  if (status != 0) {
    return PN532_INVALID_FRAME;
  }

  return Plugin_017_readAckFrame();
}




int16_t Plugin_017_readResponse(uint8_t command, uint8_t buf[], uint8_t len)
{
  delay(1);

  if (!Wire.requestFrom(PN532_I2C_ADDRESS, len + 2)) {
    return -1;
  }


  if (!(Wire.read() & 1)) {
    return -1;
  }

  if ((0x00 != Wire.read()) ||
      (0x00 != Wire.read()) ||
      (0xFF != Wire.read())
      ) {
    return PN532_INVALID_FRAME;
  }

  uint8_t length = Wire.read();

  if (0 != (uint8_t)(length + Wire.read())) {
    return PN532_INVALID_FRAME;
  }

  uint8_t cmd = command + 1;

  if ((PN532_PN532TOHOST != Wire.read()) || ((cmd) != Wire.read())) {
    return PN532_INVALID_FRAME;
  }

  length -= 2;

  if (length > len) {
    return PN532_NO_SPACE;
  }

  uint8_t sum = PN532_PN532TOHOST + cmd;

  for (uint8_t i = 0; i < length; i++) {
    buf[i] = Wire.read();
    sum += buf[i];
  }

  uint8_t checksum = Wire.read();

  if (0 != (uint8_t)(sum + checksum)) {
    return PN532_INVALID_FRAME;
  }
  Wire.read();

  return length;
}




int8_t Plugin_017_readAckFrame()
{
  delay(1);

  const uint8_t PN532_ACK[] = { 0, 0, 0xFF, 0, 0xFF, 0 };
  uint8_t ackBuf[sizeof(PN532_ACK)];

  uint16_t time = 0;

  do {
    if (Wire.requestFrom(PN532_I2C_ADDRESS, sizeof(PN532_ACK) + 1)) {
      if (Wire.read() & 1) {
        break;
      }
    }

    delay(1);
    time++;

    if (time > PN532_ACK_WAIT_TIME) {
      return PN532_TIMEOUT;
    }
  } while (1);


  for (uint8_t i = 0; i < sizeof(PN532_ACK); i++) {
    ackBuf[i] = Wire.read();
  }

  if (memcmp(ackBuf, PN532_ACK, sizeof(PN532_ACK))) {
    return PN532_INVALID_ACK;
  }

  return 0;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P018_Dust.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P018

#include "src/Helpers/Hardware.h"
# include <GPIO_Direct_Access.h>





#define PLUGIN_018 
#define PLUGIN_ID_018 18
#define PLUGIN_NAME_018 "Dust - Sharp GP2Y10"
#define PLUGIN_VALUENAME1_018 "Dust"

boolean Plugin_018_init = false;

boolean Plugin_018(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_018;
        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = true;
        Device[deviceCount].ValueCount = 1;
        Device[deviceCount].SendDataOption = true;
        Device[deviceCount].TimerOption = true;
        Device[deviceCount].GlobalSyncOption = true;
        Device[deviceCount].PluginStats = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_018);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_018));
        break;
      }

    case PLUGIN_GET_DEVICEGPIONAMES:
      {
        event->String1 = formatGpioName_output(F("LED"));
        break;
      }

    case PLUGIN_INIT:
      {
        Plugin_018_init = true;
        pinMode(CONFIG_PIN1, OUTPUT);
        DIRECT_pinWrite(CONFIG_PIN1, HIGH);
        success = true;
        break;
      }


    case PLUGIN_READ:
      {
        ISR_noInterrupts();
        int value = 0;

        for (uint8_t x = 0; x < 25; x++) {
          DIRECT_pinWrite(CONFIG_PIN1, LOW);
          delayMicroseconds(280);
          value = value + espeasy_analogRead(A0);
          delayMicroseconds(40);
          DIRECT_pinWrite(CONFIG_PIN1, HIGH);
          delayMicroseconds(9680);
        }
        ISR_interrupts();
        UserVar.setFloat(event->TaskIndex, 0, value);

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          addLogMove(LOG_LEVEL_INFO, concat(F("GPY  : Dust value: "), value));
        }

        success = true;
        break;
      }
  }
  return success;
}
#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P019_PCF8574.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P019

# include "src/DataStructs/PinMode.h"
# include "src/ESPEasyCore/ESPEasyGPIO.h"
# include "src/Helpers/_Plugin_Helper_webform.h"
# 37 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P019_PCF8574.ino"
#define PLUGIN_019 
#define PLUGIN_ID_019 19
#define PLUGIN_NAME_019 "Switch input - PCF8574"
#define PLUGIN_VALUENAME1_019 "State"


#define P019_BOOTSTATE PCONFIG(0)
#define P019_DEBOUNCE PCONFIG_FLOAT(0)
#define P019_DOUBLECLICK PCONFIG(4)
#define P019_DC_MAX_INT PCONFIG_FLOAT(1)
#define P019_LONGPRESS PCONFIG(5)
#define P019_LP_MIN_INT PCONFIG_FLOAT(2)
#define P019_SAFE_BTN PCONFIG_FLOAT(3)


boolean Plugin_019(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_019;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = true;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_019);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_019));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        String portNames[8];
        int portValues[8];
        const uint8_t unit = (CONFIG_PORT - 1) / 8;
        const uint8_t port = CONFIG_PORT - (unit * 8);
        uint8_t address = 0x20 + unit;

        if (unit > 7) { address += 0x10; }

        for (uint8_t x = 0; x < 8; x++) {
          portValues[x] = x + 1;
          portNames[x] = 'P';
          portNames[x] += x;
        }
        addFormSelectorI2C(F("pi2c"), 16, i2cAddressValues, address);
        addFormSelector(F("Port"), F("pport"), 8, portNames, portValues, port);
        addFormNote(F("PCF8574 uses addresses 0x20..0x27, PCF8574<b>A</b> uses addresses 0x38..0x3F."));
      } else {
        success = intArrayContains(16, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      const uint8_t unit = (CONFIG_PORT - 1) / 8;
      uint8_t address = 0x20 + unit;

      if (unit > 7) { address += 0x10; }

      event->Par1 = address;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {

      const uint32_t key = createKey(PLUGIN_PCF, CONFIG_PORT);

      auto it = globalMapPortStatus.find(key);

      if (it != globalMapPortStatus.end()) {
        it->second.previousTask = event->TaskIndex;
      }
      SwitchWebformLoad(
        P019_BOOTSTATE,
        P019_DEBOUNCE,
        P019_DOUBLECLICK,
        P019_DC_MAX_INT,
        P019_LONGPRESS,
        P019_LP_MIN_INT,
        P019_SAFE_BTN);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      uint8_t i2c = getFormItemInt(F("pi2c"));

      if (i2c > 0x27) { i2c -= 0x10; }

      uint8_t port = getFormItemInt(F("pport"));
      CONFIG_PORT = (((i2c - 0x20) << 3) + port);

      SwitchWebformSave(
        event->TaskIndex,
        PLUGIN_PCF,
        P019_BOOTSTATE,
        P019_DEBOUNCE,
        P019_DOUBLECLICK,
        P019_DC_MAX_INT,
        P019_LONGPRESS,
        P019_LP_MIN_INT,
        P019_SAFE_BTN);

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {

      if (CONFIG_PORT >= 0)
      {
        portStatusStruct newStatus;
        const uint32_t key = createKey(PLUGIN_PCF, CONFIG_PORT);


        newStatus = globalMapPortStatus[key];



        newStatus.state = Plugin_019_Read(CONFIG_PORT);
        newStatus.output = newStatus.state;
        newStatus.mode = (newStatus.state == -1) ? PIN_MODE_OFFLINE : PIN_MODE_INPUT;


        newStatus.task++;


        if ((newStatus.state != -1) && Settings.TaskDevicePin1Inversed[event->TaskIndex]) {
          UserVar.setFloat(event->TaskIndex, 0, !newStatus.state);
        } else {
          UserVar.setFloat(event->TaskIndex, 0, newStatus.state);
        }



        if (P019_BOOTSTATE) {
          newStatus.state = !newStatus.state;
        }


        PCONFIG(7) = 0;
        PCONFIG_LONG(3) = 0;


        PCONFIG(6) = false;


        PCONFIG_LONG(0) = millis();
        PCONFIG_LONG(1) = millis();
        PCONFIG_LONG(2) = millis();


        if (P019_DC_MAX_INT < SWITCH_DOUBLECLICK_MIN_INTERVAL) {
          P019_DC_MAX_INT = SWITCH_DOUBLECLICK_MIN_INTERVAL;
        }


        if (P019_LP_MIN_INT < SWITCH_LONGPRESS_MIN_INTERVAL) {
          P019_LP_MIN_INT = SWITCH_LONGPRESS_MIN_INTERVAL;
        }


        savePortStatus(key, newStatus);
        success = true;
      }
      break;
    }
# 300 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P019_PCF8574.ino"
    case PLUGIN_TEN_PER_SECOND:
    {
      # if FEATURE_I2C_DEVICE_CHECK

      const uint8_t unit = (CONFIG_PORT - 1) / 8;
      uint8_t address = 0x20 + unit;

      if (unit > 7) { address += 0x10; }

      if (!I2C_deviceCheck(address, event->TaskIndex, 10, PLUGIN_I2C_GET_ADDRESS)) {
        break;
      }
      # endif
      const int8_t state = Plugin_019_Read(CONFIG_PORT);
      const __FlashStringHelper *monitorEventString = F("PCF");
# 329 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P019_PCF8574.ino"
      portStatusStruct currentStatus;
      const uint32_t key = createKey(PLUGIN_PCF, CONFIG_PORT);


      currentStatus = globalMapPortStatus[key];


      if ((state != -1) && (CONFIG_PORT >= 0)) {


        if (lround(P019_SAFE_BTN) && (state != currentStatus.state) && (PCONFIG_LONG(3) == 0))
        {
          # ifndef BUILD_NO_DEBUG
          addLog(LOG_LEVEL_DEBUG, F("PCF :SafeButton 1st click."));
          # endif
          PCONFIG_LONG(3) = 1;
        }


        else if ((state != currentStatus.state) || currentStatus.forceEvent)
        {

          currentStatus.forceEvent = 0;


          PCONFIG_LONG(3) = 0;


          PCONFIG_LONG(2) = millis();
          PCONFIG(6) = false;

          const unsigned long debounceTime = timePassedSince(PCONFIG_LONG(0));

          if (debounceTime >= (unsigned long)lround(P019_DEBOUNCE))
          {
            const unsigned long deltaDC = timePassedSince(PCONFIG_LONG(1));

            if ((deltaDC >= (unsigned long)lround(P019_DC_MAX_INT)) ||
                (PCONFIG(7) == 3))
            {

              PCONFIG(7) = 0;
              PCONFIG_LONG(1) = millis();
            }


#define COUNTER PCONFIG(7)
#define DC P019_DOUBLECLICK


            if ((COUNTER != 0) || ((COUNTER == 0) && ((DC == 3) || ((DC == 1) && (state == 0)) || ((DC == 2) && (state == 1))))) {
              PCONFIG(7)++;
            }
#undef DC
#undef COUNTER


            if ((currentStatus.mode == PIN_MODE_OFFLINE) || (currentStatus.mode == PIN_MODE_UNDEFINED)) {
              currentStatus.mode = PIN_MODE_INPUT;
            }
            currentStatus.state = state;

            uint8_t output_value;


            boolean sendState = currentStatus.state;

            if (Settings.TaskDevicePin1Inversed[event->TaskIndex]) {
              sendState = !sendState;
            }

            if ((PCONFIG(7) == 3) && (P019_DOUBLECLICK > 0))
            {
              output_value = 3;
            } else {
              output_value = sendState ? 1 : 0;
            }

            UserVar.setFloat(event->TaskIndex, 0, output_value);

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("PCF  : Port=");
              log += CONFIG_PORT;
              log += F(" State=");
              log += state;
              log += output_value == 3 ? F(" Doubleclick=") : F(" Output value=");
              log += output_value;
              addLogMove(LOG_LEVEL_INFO, log);
            }


            sendData(event);


            if (currentStatus.monitor) { sendMonitorEvent(monitorEventString, CONFIG_PORT, output_value); }


            currentStatus.forceEvent = 0;

            savePortStatus(key, currentStatus);
          }
          savePortStatus(key, currentStatus);
        }


#define LP P019_LONGPRESS
#define FIRED PCONFIG(6)


        else if (!FIRED && ((LP == 3) || ((LP == 1) && (state == 0)) || ((LP == 2) && (state == 1)))) {
#undef LP
#undef FIRED
# 456 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P019_PCF8574.ino"
          PCONFIG_LONG(3) = 0;

          const unsigned long deltaLP = timePassedSince(PCONFIG_LONG(2));

          if (deltaLP >= (unsigned long)lround(P019_LP_MIN_INT))
          {
            uint8_t output_value;
            PCONFIG(6) = true;

            boolean sendState = state;

            if (Settings.TaskDevicePin1Inversed[event->TaskIndex]) {
              sendState = !sendState;
            }

            output_value = sendState ? 1 : 0;
            output_value = output_value + 10;

            UserVar.setFloat(event->TaskIndex, 0, output_value);

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("PCF  : LongPress: Port= ");
              log += CONFIG_PORT;
              log += F(" State=");
              log += state ? '1' : '0';
              log += F(" Output value=");
              log += output_value;
              addLogMove(LOG_LEVEL_INFO, log);
            }


            sendData(event);


            if (currentStatus.monitor) { sendMonitorEvent(monitorEventString, CONFIG_PORT, output_value); }


            UserVar.setFloat(event->TaskIndex, 0, sendState ? 1 : 0);
          }
        } else {
          if (PCONFIG_LONG(3) == 1) {
            const uint8_t SAFE_BUTTON_EVENT = 4;


            PCONFIG_LONG(3) = 0;


            const int tempUserVar = lround(UserVar[event->BaseVarIndex]);
            UserVar.setFloat(event->TaskIndex, 0, 4);

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("PCF : SafeButton: false positive detected. GPIO= ");
              log += CONFIG_PORT;
              log += F(" State=");
              log += tempUserVar;
              addLogMove(LOG_LEVEL_INFO, log);
            }




            if (currentStatus.monitor) { sendMonitorEvent(monitorEventString, CONFIG_PORT, SAFE_BUTTON_EVENT); }


            UserVar.setFloat(event->TaskIndex, 0, tempUserVar);
          }
        }
      } else if ((state != currentStatus.state) && (state == -1)) {

        UserVar.setFloat(event->TaskIndex, 0, state);


        currentStatus.state = state;
        currentStatus.mode = PIN_MODE_OFFLINE;

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("PCF  : Port=");
          log += CONFIG_PORT;
          log += F(" is offline (EVENT= -1)");
          addLogMove(LOG_LEVEL_INFO, log);
        }


        sendData(event);


        if (currentStatus.monitor) { sendMonitorEvent(monitorEventString, CONFIG_PORT, -1); }

        savePortStatus(key, currentStatus);
      }
      success = true;
      break;
    }


    case PLUGIN_EXIT:
    {
      removeTaskFromPort(createKey(PLUGIN_PCF, CONFIG_PORT));
      break;
    }

    case PLUGIN_READ:
    {


      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log = F("PCF  : Port= ");
        log += CONFIG_PORT;
        log += F(" State=");
        log += UserVar[event->BaseVarIndex];
        addLogMove(LOG_LEVEL_INFO, log);
      }
      success = true;
      break;
    }
# 592 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P019_PCF8574.ino"
    case PLUGIN_WRITE:
    {



      break;
    }

    case PLUGIN_TASKTIMER_IN:
    case PLUGIN_DEVICETIMER_IN:
    {

      portStatusStruct tempStatus;


      const uint32_t key = createKey(PLUGIN_PCF, event->Par1);
      tempStatus = globalMapPortStatus[key];

      tempStatus.state = event->Par2;
      tempStatus.mode = PIN_MODE_OUTPUT;

      if (function == PLUGIN_TASKTIMER_IN) {

        tempStatus.forceMonitor = 1;
      } else {
        tempStatus.forceMonitor = (tempStatus.monitor) ? 1 : 0;
      }
      savePortStatus(key, tempStatus);
      Scheduler.clearGPIOTimer(PLUGIN_PCF, event->Par1);

      if (function == PLUGIN_TASKTIMER_IN) {
        GPIO_PCF_Write(event->Par1, event->Par2);
      } else {
        Plugin_019_Write(event->Par1, event->Par2);
      }

      break;
    }
  }
  return success;
}





int8_t Plugin_019_Read(uint8_t Par1)
{
  int8_t state = -1;
  uint8_t unit = (Par1 - 1) / 8;
  uint8_t port = Par1 - (unit * 8);
  uint8_t address = 0x20 + unit;

  if (unit > 7) { address += 0x10; }


  bool is_ok = false;
  const uint8_t rawState = I2C_read8(address, &is_ok);
  if (is_ok)
  {
    state = ((rawState & _BV(port - 1)) >> (port - 1));
  }
  return state;
}

uint8_t Plugin_019_ReadAllPins(uint8_t address)
{
  bool is_ok = false;
  const uint8_t rawState = I2C_read8(address, &is_ok);
  return is_ok ? rawState : 0u;
}




boolean Plugin_019_Write(uint8_t Par1, uint8_t Par2)
{
  uint8_t unit = (Par1 - 1) / 8;
  uint8_t port = Par1 - (unit * 8);
  uint8_t address = 0x20 + unit;

  if (unit > 7) { address += 0x10; }


  int i = 0;
  uint8_t portmask = 255;

  unit = unit * 8 + 1;

  uint32_t key;

  for (i = 0; i < 8; i++) {
    key = createKey(PLUGIN_PCF, unit + i);

    auto it = globalMapPortStatus.find(key);

    if (it != globalMapPortStatus.end()) {
      if ((it->second.mode == PIN_MODE_OUTPUT) && (it->second.state == 0)) {
        portmask &= ~(1 << i);
      }
    }
  }

  key = createKey(PLUGIN_PCF, Par1);

  if (Par2 == 1) {
    portmask |= (1 << (port - 1));
  }
  else {
    portmask &= ~(1 << (port - 1));
  }

  I2C_write8(address, portmask);

  return true;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P020_Ser2Net.ino"
#include "_Plugin_Helper.h"
#if defined(USES_P020) || defined(USES_P044)
# 31 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P020_Ser2Net.ino"
# include "src/Helpers/_Plugin_Helper_serial.h"
# include "src/PluginStructs/P020_data_struct.h"
# include <ESPeasySerial.h>


#define PLUGIN_020 
#define PLUGIN_ID_020 20
#define PLUGIN_NAME_020 "Communication - Serial Server"
#define PLUGIN_VALUENAME1_020 "Ser2Net"

#define PLUGIN_ID_020_044 44
#define PLUGIN_NAME_020_044 "Communication - P1 Wifi Gateway"

bool P020_Emulate_P044 = false;
# if defined(USES_P044) && !defined(USES_P044_ORG)


boolean Plugin_044(uint8_t function, struct EventStruct *event, String& string) {
  P020_Emulate_P044 = true;

  boolean result = Plugin_020(function, event, string);

  P020_Emulate_P044 = false;
  return result;
}

bool P020_ConvertP044Settings(struct EventStruct *event) {
  if (P020_Emulate_P044 && !P020_GET_P044_MODE_SAVED) {

    P020_RX_WAIT = PCONFIG(0);

    P020_RESET_TARGET_PIN = CONFIG_PIN1;


    CONFIG_PORT = static_cast<int>(ESPEasySerialPort::serial0);
    CONFIG_PIN1 = 3;
    CONFIG_PIN2 = 1;


    P020_FLAGS = 0u;
    bitSet(P020_FLAGS, P020_FLAG_LED_ENABLED);
    P020_LED_PIN = P020_STATUS_LED;
    P020_SERIAL_PROCESSING = static_cast<int>(P020_Events::P1WiFiGateway);
    return true;
  }
  return false;
}

# endif

boolean Plugin_020(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      if (P020_Emulate_P044) {
        Device[++deviceCount].Number = PLUGIN_ID_020_044;
        Device[deviceCount].SendDataOption = false;
      } else {
        Device[++deviceCount].Number = PLUGIN_ID_020;
        Device[deviceCount].SendDataOption = true;
      }
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_STRING;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].GlobalSyncOption = false;
      break;
    }
    case PLUGIN_GET_DEVICENAME:
    {
      string = P020_Emulate_P044 ? F(PLUGIN_NAME_020_044) : F(PLUGIN_NAME_020);
      break;
    }


    case PLUGIN_SET_DEFAULTS:
    {
      if (P020_Emulate_P044) {
        CONFIG_PORT = static_cast<int>(ESPEasySerialPort::serial0);
        CONFIG_PIN1 = 3;
        CONFIG_PIN2 = 1;
        P020_SET_BAUDRATE = P020_DEFAULT_P044_BAUDRATE;
        P020_SET_SERVER_PORT = P020_DEFAULT_P044_SERVER_PORT;
        P020_RESET_TARGET_PIN = P020_DEFAULT_RESET_TARGET_PIN;
        P020_SERIAL_PROCESSING = static_cast<int>(P020_Events::P1WiFiGateway);
        P020_LED_PIN = P020_STATUS_LED;
        P020_RX_WAIT = 50;
        P020_REPLACE_SPACE = 0;
        P020_REPLACE_NEWLINE = 0;
        P020_FLAGS = 0u;
        bitSet(P020_FLAGS, P020_FLAG_LED_ENABLED);
        bitSet(P020_FLAGS, P020_FLAG_P044_MODE_SAVED);
      } else {
        P020_SET_BAUDRATE = P020_DEFAULT_BAUDRATE;
        P020_SET_SERVER_PORT = P020_DEFAULT_SERVER_PORT;
        P020_RESET_TARGET_PIN = P020_DEFAULT_RESET_TARGET_PIN;
        P020_RX_BUFFER = P020_DEFAULT_RX_BUFFER;
        P020_LED_PIN = -1;
      }
      success = true;
      break;
    }


    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      serialHelper_getGpioNames(event);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      string = F("RST: ");
      string += formatGpioLabel(P020_RESET_TARGET_PIN, false);
      string += event->String1;
      string += F("LED: ");
      string += formatGpioLabel(P020_GET_LED_ENABLED ? P020_LED_PIN : -1, false);

      if ((P020_GET_LED_INVERTED == 1) && (P020_GET_LED_ENABLED)) {
        string += F(" (inv)");
      }
      success = true;
      break;
    }

    # ifdef USES_P044
    case PLUGIN_WEBFORM_PRE_SERIAL_PARAMS:
    {

      if (P020_Emulate_P044 && P020_ConvertP044Settings(event)) {
        addFormNote(F("Settings migrated from previous plugin version."));
      }
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("TCP Port"), F("pport"), P020_GET_SERVER_PORT, 0);
      # ifndef LIMIT_BUILD_SIZE
      addUnit(F("0..65535"));
      # endif

      addFormNumericBox(F("Baud Rate"), F("pbaud"), P020_GET_BAUDRATE, 0);
      uint8_t serialConfChoice = serialHelper_convertOldSerialConfig(P020_SERIAL_CONFIG);
      serialHelper_serialconfig_webformLoad(event, serialConfChoice);
      {
        if (!P020_Emulate_P044) {
          const __FlashStringHelper *options[] = {
            F("None"),
            F("Generic"),
            F("RFLink"),
            F("P1 WiFi Gateway")
          };
          const int optionValues[] = {
            static_cast<int>(P020_Events::None),
            static_cast<int>(P020_Events::Generic),
            static_cast<int>(P020_Events::RFLink),
            static_cast<int>(P020_Events::P1WiFiGateway),
          };
          constexpr int optionCount = NR_ELEMENTS(optionValues);
          addFormSelector(F("Event processing"), F("pevents"),
                          optionCount, options, optionValues,
                          P020_SERIAL_PROCESSING);
        }
        addFormCheckBox(F("P1 #data event with message"), F("pp1event"), P020_GET_P1_EVENT_DATA);
        # ifndef LIMIT_BUILD_SIZE
        addFormNote(F("When enabled, passes the entire message in the event. <B>Warning:</B> can cause memory overflow issues!"));
        # endif

        if (P020_Events::Generic == static_cast<P020_Events>(P020_SERIAL_PROCESSING)) {
          addFormCheckBox(F("Use Serial Port as eventname"), F("pevtname"), P020_GET_EVENT_SERIAL_ID);
          # ifndef LIMIT_BUILD_SIZE
          addFormNote(F("(Event processing: Generic only!)"));
          # endif
        }

        if (P020_Events::P1WiFiGateway != static_cast<P020_Events>(P020_SERIAL_PROCESSING)) {
          addFormCheckBox(F("Append Task Number to eventname"), F("papptask"), P020_GET_APPEND_TASK_ID);
          # ifndef LIMIT_BUILD_SIZE
          addFormNote(F("(Event processing: Generic and RFLink only!)"));
          # endif
        }

        if (!P020_Emulate_P044) {
          addFormSeparatorCharInput(F("Replace spaces in event by"), F("replspace"),
                                    P020_REPLACE_SPACE, F(P020_REPLACE_CHAR_SET), F(""));

          addFormSeparatorCharInput(F("Replace newlines in event by"), F("replcrlf"),
                                    P020_REPLACE_NEWLINE, F(P020_REPLACE_CHAR_SET), F(""));
        }

        addFormCheckBox(F("Process events without client"), F("pignoreclient"), P020_IGNORE_CLIENT_CONNECTED);
        # ifndef LIMIT_BUILD_SIZE
        addFormNote(F("When enabled, will process serial data without a network client connected."));
        # endif

        if (!P020_Emulate_P044) {
          addFormCheckBox(F("Multiple lines processing"), F("pmultiline"), P020_HANDLE_MULTI_LINE);
        }
      }
      {
        addFormNumericBox(F("RX Receive Timeout (mSec)"), F("prxwait"), P020_RX_WAIT, 0, 200);
        addFormPinSelect(PinSelectPurpose::Generic_output, F("Reset target after init"), F("presetpin"), P020_RESET_TARGET_PIN);

        if (!P020_Emulate_P044) {
          addFormNumericBox(F("RX buffer size (bytes)"), F("prx_buffer"), P020_RX_BUFFER, 256, 2048);
          # ifndef LIMIT_BUILD_SIZE
          addFormNote(F("Standard RX buffer 256B; higher values could be unstable; energy meters could require 1024B"));
          # endif
        }
      }
      {
        addFormSubHeader(F("Led"));

        addFormCheckBox(F("Led enabled"), F("pled"), P020_GET_LED_ENABLED);
        addFormPinSelect(PinSelectPurpose::Generic_output, F("Led pin"), F("pledpin"), P020_LED_PIN);
        addFormCheckBox(F("Led inverted"), F("pledinv"), P020_GET_LED_INVERTED == 1);
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P020_SET_SERVER_PORT = getFormItemInt(F("pport"));
      P020_SET_BAUDRATE = getFormItemInt(F("pbaud"));
      P020_SERIAL_CONFIG = serialHelper_serialconfig_webformSave();
      P020_RX_WAIT = getFormItemInt(F("prxwait"));
      P020_RESET_TARGET_PIN = getFormItemInt(F("presetpin"));

      if (P020_Emulate_P044) {
        P020_SERIAL_PROCESSING = static_cast<int>(P020_Events::P1WiFiGateway);
      } else {
        P020_SERIAL_PROCESSING = getFormItemInt(F("pevents"));
        P020_RX_BUFFER = getFormItemInt(F("prx_buffer"));
        P020_REPLACE_SPACE = getFormItemInt(F("replspace"));
        P020_REPLACE_NEWLINE = getFormItemInt(F("replcrlf"));
      }
      P020_LED_PIN = getFormItemInt(F("pledpin"));

      uint32_t lSettings = 0u;
      bitWrite(lSettings, P020_FLAG_IGNORE_CLIENT, isFormItemChecked(F("pignoreclient")));
      bitWrite(lSettings, P020_FLAG_LED_ENABLED, isFormItemChecked(F("pled")));
      bitWrite(lSettings, P020_FLAG_LED_INVERTED, isFormItemChecked(F("pledinv")));
      bitWrite(lSettings, P020_FLAG_P1_EVENT_DATA, isFormItemChecked(F("pp1event")));

      if (P020_Events::Generic == static_cast<P020_Events>(P020_SERIAL_PROCESSING)) {
        bitWrite(lSettings, P020_FLAG_EVENT_SERIAL_ID, isFormItemChecked(F("pevtname")));
      }

      if (P020_Events::P1WiFiGateway != static_cast<P020_Events>(P020_SERIAL_PROCESSING)) {
        bitWrite(lSettings, P020_FLAG_APPEND_TASK_ID, isFormItemChecked(F("papptask")));
      }

      if (P020_Emulate_P044) {
        bitSet(lSettings, P020_FLAG_P044_MODE_SAVED);
      } else {
        bitWrite(lSettings, P020_FLAG_MULTI_LINE, isFormItemChecked(F("pmultiline")));
      }

      P020_FLAGS = lSettings;

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      # ifdef USES_P044


      if (P020_Emulate_P044 && P020_ConvertP044Settings(event)) {
        addLog(LOG_LEVEL_INFO, F("P1   : Automatic settings conversion, please save settings manually."));
        bitSet(P020_FLAGS, P020_FLAG_P044_MODE_SAVED);
      }
      # endif

      if (P020_GET_LED_ENABLED && validGpio(P020_LED_PIN)) {
        pinMode(P020_LED_PIN, OUTPUT);
        digitalWrite(P020_LED_PIN, P020_GET_LED_INVERTED ? 1 : 0);
      }

      if ((P020_GET_SERVER_PORT == 0) || (P020_GET_BAUDRATE == 0)) {
        clearPluginTaskData(event->TaskIndex);
        break;
      }


      P020_Task *task = static_cast<P020_Task *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != task) && task->isInit()) {


      } else {
        initPluginTaskData(event->TaskIndex, new (std::nothrow) P020_Task(event));
        task = static_cast<P020_Task *>(getPluginTaskData(event->TaskIndex));
      }

      if (nullptr == task) {
        break;
      }
      task->handleMultiLine = P020_HANDLE_MULTI_LINE && static_cast<P020_Events>(P020_SERIAL_PROCESSING) != P020_Events::P1WiFiGateway;

      int rxPin = CONFIG_PIN1;
      int txPin = CONFIG_PIN2;
      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);

      if ((rxPin < 0) && (txPin < 0)) {
        ESPeasySerialType::getSerialTypePins(port, rxPin, txPin);
        CONFIG_PIN1 = rxPin;
        CONFIG_PIN2 = txPin;
      }

      # ifndef LIMIT_BUILD_SIZE

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        addLog(LOG_LEVEL_INFO, strformat(F("Ser2Net: TaskIndex=%d port=%d rxPin=%d txPin=%d BAUDRATE=%d SERVER_PORT=%d SERIAL_PROCESSING=%d"),
                                         event->TaskIndex + 1,
                                         CONFIG_PORT,
                                         rxPin,
                                         txPin,
                                         P020_GET_BAUDRATE,
                                         P020_GET_SERVER_PORT,
                                         P020_SERIAL_PROCESSING));
      }
      # endif



      uint8_t serialconfig = serialHelper_convertOldSerialConfig(P020_SERIAL_CONFIG);
      task->serialBegin(port, rxPin, txPin, P020_GET_BAUDRATE, serialconfig);
      task->startServer(P020_GET_SERVER_PORT);

      if (!task->isInit()) {
        clearPluginTaskData(event->TaskIndex);
        break;
      }

      if (validGpio(P020_RESET_TARGET_PIN)) {
        # ifndef BUILD_NO_DEBUG

        if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
          addLogMove(LOG_LEVEL_DEBUG, strformat(
            F("Ser2net  : P020_RESET_TARGET_PIN : %d"),
            P020_RESET_TARGET_PIN));
        }
        # endif
        pinMode(P020_RESET_TARGET_PIN, OUTPUT);
        digitalWrite(P020_RESET_TARGET_PIN, LOW);
        delay(500);
        digitalWrite(P020_RESET_TARGET_PIN, HIGH);
        pinMode(P020_RESET_TARGET_PIN, INPUT_PULLUP);
      }

      task->serial_processing = static_cast<P020_Events>(P020_SERIAL_PROCESSING);
      task->_P1EventData = P020_GET_P1_EVENT_DATA;

      task->blinkLED();

      if (task->serial_processing == P020_Events::P1WiFiGateway) {
        task->_CRCcheck = P020_GET_BAUDRATE == 115200;
        # ifndef BUILD_NO_DEBUG

        if (task->_CRCcheck) {
          addLog(LOG_LEVEL_DEBUG, F("P1   : DSMR version 5 meter, CRC on"));
        } else {
          addLog(LOG_LEVEL_DEBUG, F("P1   : DSMR version 4 meter, CRC off"));
        }
        # endif
      }

      success = true;
      break;
    }

    case PLUGIN_EXIT:
    {
      P020_Task *task = static_cast<P020_Task *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != task) {
        task->stopServer();
        task->serialEnd();
      }
      success = true;
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P020_Task *task = static_cast<P020_Task *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != task) {
        task->checkServer();
        success = true;
      }
      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P020_Task *task = static_cast<P020_Task *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != task) {
        bool hasClient = task->hasClientConnected();

        if (P020_IGNORE_CLIENT_CONNECTED || hasClient) {
          if (hasClient) {
            task->handleClientIn(event);
          }
          task->handleSerialIn(event);
        }
        task->checkBlinkLED();
        success = true;
      }
      break;
    }

    case PLUGIN_SERIAL_IN:
    {
      P020_Task *task = static_cast<P020_Task *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != task) {
        if (P020_IGNORE_CLIENT_CONNECTED || task->hasClientConnected()) {
          task->handleSerialIn(event);
        } else {
          task->discardSerialIn();
        }
        success = true;
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P020_Task *task = static_cast<P020_Task *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != task) {
        String command = parseString(string, 1);

        if (equals(command, F("serialsend"))) {
          task->ser2netSerial->write(string.substring(11).c_str());
          task->ser2netSerial->flush();
          success = true;
        } else if (equals(command, F("serialsendmix"))) {
          std::vector<uint8_t> argument = parseHexTextData(string);
          task->ser2netSerial->write(&argument[0], argument.size());
          task->ser2netSerial->flush();
          success = true;
        } else if ((equals(command, F("ser2netclientsend"))) && (task->hasClientConnected())) {
          task->ser2netClient.print(string.substring(18));
          task->ser2netClient.flush();
          success = true;
        }
        break;
      }
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P021_Level.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P021
# 17 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P021_Level.ino"
# include "src/Helpers/ESPEasy_math.h"
# include "src/Globals/RulesCalculate.h"
# include "src/WebServer/ESPEasy_WebServer.h"

#define PLUGIN_021 
#define PLUGIN_ID_021 21
#define PLUGIN_NAME_021 "Regulator - Level Control"
#define PLUGIN_VALUENAME1_021 "Output"

#define P021_CHECK_TASK PCONFIG(0)
#define P021_CHECK_VALUE PCONFIG(1)
#define P021_DONT_ALWAYS_SAVE PCONFIG(2)
#define P021_INVERT_OUTPUT PCONFIG(3)
#define P021_TRIGGER_LEVEL PCONFIG_FLOAT(0)
#define P021_TRIGGER_HYSTERESIS PCONFIG_FLOAT(1)
#define P021_TRIGGER_LAST_STORED PCONFIG_FLOAT(2)
#define P021_AUTOSAVE_TIMER PCONFIG_ULONG(0)

boolean Plugin_021(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;
  static uint8_t switchstate[TASKS_MAX];

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_021;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_021);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_021));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("Level low"));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P021_DONT_ALWAYS_SAVE = 1;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addRowLabel(F("Check Task"));
      addTaskSelect(F("ptask"), P021_CHECK_TASK);

      if (validTaskIndex(P021_CHECK_TASK)) {
        addRowLabel(F("Check Value"));
        addTaskValueSelect(F("pvalue"), P021_CHECK_VALUE, P021_CHECK_TASK);
      }

      addFormTextBox(F("Set Level"), F("psetvalue"), toString(P021_TRIGGER_LEVEL), 8);

      addFormTextBox(F("Hysteresis"), F("physt"), toString(P021_TRIGGER_HYSTERESIS), 8);

      addFormCheckBox(F("Invert Output"),
                      F("inv"),
                      P021_INVERT_OUTPUT == 1);


      addFormCheckBox(F("Save 'Set Level'/'Hysteresis' after change via <pre>config</pre> command"),
                      F("psave_always"),
                      P021_DONT_ALWAYS_SAVE == 0);

      addFormNote(F("Saving settings too often can wear out the flash chip on your ESP!"));


      addFormNumericBox(F("Auto-save interval"), F("pautosave"), P021_AUTOSAVE_TIMER / 60, 0, 1440);
      addUnit(F("minutes"));

      addFormNote(F("Interval to check if settings are changed via <pre>config</pre> command and saves that. Max. 24h, 0 = Off"));


      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P021_CHECK_TASK = getFormItemInt(F("ptask"));
      P021_CHECK_VALUE = getFormItemInt(F("pvalue"));
      P021_DONT_ALWAYS_SAVE = isFormItemChecked(F("psave_always")) ? 0 : 1;
      P021_TRIGGER_LEVEL = getFormItemFloat(F("psetvalue"));
      P021_TRIGGER_LAST_STORED = P021_TRIGGER_LEVEL;
      P021_TRIGGER_HYSTERESIS = getFormItemFloat(F("physt"));
      P021_AUTOSAVE_TIMER = getFormItemInt(F("pautosave")) * 60;
      P021_INVERT_OUTPUT = isFormItemChecked(F("inv")) ? 1 : 0;

      success = true;
      break;
    }

    case PLUGIN_SET_CONFIG:
    {
      const String command = parseString(string, 1);
      const bool isHysteresis = equals(command, F("sethysteresis"));

      if (equals(command, F("setlevel")) || isHysteresis) {
        String value = parseString(string, 2);
        ESPEASY_RULES_FLOAT_TYPE result{};

        if (!isError(Calculate(value, result))) {
          bool isChanged = false;

          if (!isHysteresis &&
              !essentiallyEqual(static_cast<ESPEASY_RULES_FLOAT_TYPE>(P021_TRIGGER_LEVEL), result)) {
            P021_TRIGGER_LEVEL = result;
            isChanged = true;
          }

          if (isHysteresis &&
              !essentiallyEqual(static_cast<ESPEASY_RULES_FLOAT_TYPE>(P021_TRIGGER_HYSTERESIS), result)) {
            P021_TRIGGER_HYSTERESIS = result;
            isChanged = true;
          }

          if (isChanged) {
            if (P021_DONT_ALWAYS_SAVE == 0) {
              P021_TRIGGER_LAST_STORED = P021_TRIGGER_LEVEL;
              SaveSettings();
            } else {
              UserVar.setUint32(event->TaskIndex, 2, 1);

              if ((P021_AUTOSAVE_TIMER > 0) &&
                  (P021_DONT_ALWAYS_SAVE != 0) &&
                  ((UserVar.getUint32(event->TaskIndex, 3) == 0u) ||
                   (UserVar.getUint32(event->TaskIndex, 3) > P021_AUTOSAVE_TIMER))) {
                UserVar.setUint32(event->TaskIndex, 3, P021_AUTOSAVE_TIMER);
                # ifndef LIMIT_BUILD_SIZE
                addLogMove(LOG_LEVEL_INFO, F("LEVEL: Auto-save timer started."));
                # endif
              }
            }
          }
          success = true;
        }
      }
      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      String command = parseString(string, 1);

      if (equals(command, F("getlevel"))) {
        string = toString(P021_TRIGGER_LEVEL);
        success = true;
      }
      else
      if (equals(command, F("gethysteresis"))) {
        string = toString(P021_TRIGGER_HYSTERESIS);
        success = true;
      }
      break;
    }

    case PLUGIN_INIT:
    {
      if (validGpio(CONFIG_PIN1)) {
        pinMode(CONFIG_PIN1, OUTPUT);
      }
      success = true;
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {

      taskIndex_t TaskIndex = P021_CHECK_TASK;

      if (!validTaskIndex(TaskIndex)) {
        break;
      }
      uint8_t BaseVarIndex = TaskIndex * VARS_PER_TASK + P021_CHECK_VALUE;
      float value = UserVar[BaseVarIndex];
      uint8_t state = switchstate[event->TaskIndex];


      bool isZero = essentiallyZero(P021_TRIGGER_HYSTERESIS);
      float valueLowThreshold = P021_TRIGGER_LEVEL - (isZero ? 0.0f : (P021_TRIGGER_HYSTERESIS / 2.0f));
      float valueHighThreshold = P021_TRIGGER_LEVEL + (isZero ? 1.0f : (P021_TRIGGER_HYSTERESIS / 2.0f));


      if (!definitelyGreaterThan(value, valueLowThreshold)) {
        state = P021_INVERT_OUTPUT == 0 ? 1 : 0;
      }

      if (!definitelyLessThan(value, valueHighThreshold)) {
        state = P021_INVERT_OUTPUT == 0 ? 0 : 1;
      }

      if (state != switchstate[event->TaskIndex])
      {
        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("LEVEL: State ");
          log += state;
          addLogMove(LOG_LEVEL_INFO, log);
        }
        switchstate[event->TaskIndex] = state;

        if (validGpio(CONFIG_PIN1)) {
          digitalWrite(CONFIG_PIN1, state);
        }
        UserVar.setFloat(event->TaskIndex, 0, state);
        sendData(event);
      }

      success = true;
      break;
    }
    case PLUGIN_ONCE_A_SECOND:
    {

      if ((P021_AUTOSAVE_TIMER > 0) && (P021_DONT_ALWAYS_SAVE != 0) &&
          (0 != UserVar.getUint32(event->TaskIndex, 3)) &&
          (UserVar.getUint32(event->TaskIndex, 3) <= P021_AUTOSAVE_TIMER)) {
        UserVar.setUint32(event->TaskIndex, 3, UserVar.getUint32(event->TaskIndex, 3) - 1u);

        if (UserVar.getUint32(event->TaskIndex, 3) == 0) {
          if ((UserVar.getUint32(event->TaskIndex, 2) != 0) &&
              !essentiallyEqual(P021_TRIGGER_LEVEL, P021_TRIGGER_LAST_STORED)) {
            addLogMove(LOG_LEVEL_INFO, F("LEVEL: Auto-saving changed 'Set Level'."));
            P021_TRIGGER_LAST_STORED = P021_TRIGGER_LEVEL;
            SaveSettings();
            UserVar.setUint32(event->TaskIndex, 2, 0);
          }
        }
      }
      success = true;
      break;
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P022_PCA9685.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P022

# include "src/DataStructs/PinMode.h"
# include "src/Helpers/PortStatus.h"
# include "src/PluginStructs/P022_data_struct.h"

# include "ESPEasy-Globals.h"







#define PLUGIN_022 
#define PLUGIN_ID_022 22
#define PLUGIN_NAME_022 "Extra IO - PCA9685"
#define PLUGIN_VALUENAME1_022 "PWM"

constexpr pluginID_t P022_PLUGIN_ID{PLUGIN_ID_022};



boolean Plugin_022(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;
  int address = 0;
  int mode2 = 0x10;
  uint16_t freq = PCA9685_MAX_FREQUENCY;
  uint16_t range = PCA9685_MAX_PWM;

  if ((event != nullptr) && (event->TaskIndex >= 0))
  {
    address = CONFIG_PORT;
    mode2 = PCONFIG(0);
    freq = PCONFIG(1);
    range = PCONFIG(2);
  }

  if ((address < PCA9685_ADDRESS) || (address > PCA9685_MAX_ADDRESS)) {
    address = PCA9685_ADDRESS;
  }

  if (freq == 0) {
    freq = PCA9685_MAX_FREQUENCY;
  }

  if (range == 0) {
    range = PCA9685_MAX_PWM;
  }

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_022;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 1;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].Custom = true;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].ExitTaskBeforeSave = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_022);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_022));
      break;
    }

    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      uint8_t optionValues[PCA9685_NUMS_ADDRESS];

      for (uint8_t i = 0; i < PCA9685_NUMS_ADDRESS; i++)
      {
        optionValues[i] = PCA9685_ADDRESS + i;
      }
      addFormSelectorI2C(F("i2c_addr"), PCA9685_NUMS_ADDRESS, optionValues, address);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = address;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG(0) = 0x10;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {


      {
        String m2Options[PCA9685_MODE2_VALUES];
        int m2Values[PCA9685_MODE2_VALUES];

        for (int i = 0; i < PCA9685_MODE2_VALUES; i++)
        {
          m2Values[i] = i;
          m2Options[i] = formatToHex_decimal(i);

          if (i == 0x10) {
            m2Options[i] += F(" - (default)");
          }
        }
        addFormSelector(F("MODE2"), F("pmode2"), PCA9685_MODE2_VALUES, m2Options, m2Values, mode2);
      }
      addFormNumericBox(
        strformat(F("Frequency (%d-%d)"), PCA9685_MIN_FREQUENCY, PCA9685_MAX_FREQUENCY),
        F("pfreq"),
        freq,
        PCA9685_MIN_FREQUENCY,
        PCA9685_MAX_FREQUENCY);
      addFormNote(concat(F("default "), PCA9685_MAX_FREQUENCY));
      addFormNumericBox(F("Range (1-10000)"), F("prange"), range, 1, 10000);
      addFormNote(concat(F("default "), PCA9685_MAX_PWM));
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      const uint8_t oldAddress = CONFIG_PORT;

      CONFIG_PORT = getFormItemInt(F("i2c_addr"));
      PCONFIG(0) = getFormItemInt(F("pmode2"));
      PCONFIG(1) = getFormItemInt(F("pfreq"));
      PCONFIG(2) = getFormItemInt(F("prange"));

      P022_data_struct *P022_data =
        static_cast<P022_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P022_data) {
        P022_data->p022_clear_init(oldAddress);

        if (!P022_data->p022_is_init(CONFIG_PORT))
        {
          P022_data->Plugin_022_initialize(address);

          if (PCONFIG(0) != mode2) {
            P022_data->Plugin_022_writeRegister(address, PCA9685_MODE2, PCONFIG(0));
          }

          if (PCONFIG(1) != freq) {
            P022_data->Plugin_022_Frequency(address, PCONFIG(1));
          }
        }
      }
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P022_data_struct());
      break;
    }

    case PLUGIN_WRITE:
    {
      # if FEATURE_I2C_DEVICE_CHECK

      if (!I2C_deviceCheck(address, event->TaskIndex, 10, PLUGIN_I2C_GET_ADDRESS)) {
        break;
      }
      # endif
      P022_data_struct *P022_data =
        static_cast<P022_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P022_data) {
        break;
      }
      String log;
      bool instanceCommand = false;
      String command = parseString(string, 1);
      int8_t dotPos = command.indexOf('.');

      if (dotPos > -1)
      {
        String name = command.substring(0, dotPos);
        removeChar(name, '[');
        removeChar(name, ']');

        if (name.equalsIgnoreCase(getTaskDeviceName(event->TaskIndex))) {
          command = command.substring(dotPos + 1);
          instanceCommand = true;
        } else {
          break;
        }
      }

      if ((equals(command, F("pcapwm"))) || (instanceCommand && (equals(command, F("pwm")))))
      {
        success = true;


        log = P022_data_struct::P022_logPrefix(address, F("PWM "));
        log += event->Par1;
        const uint32_t dutyCycle = event->Par2;
        const uint32_t fadeDuration_ms = event->Par3;

        if ((event->Par1 >= 0) && (event->Par1 <= PCA9685_MAX_PINS))
        {
          if ((dutyCycle >= 0) && (dutyCycle <= range))
          {
            P022_data->initModeFreq(address, mode2, freq);


            portStatusStruct newStatus;
            const uint32_t key = createKey(P022_PLUGIN_ID, event->Par1);


            newStatus = globalMapPortStatus[key];


            if (fadeDuration_ms != 0)
            {
              const int32_t resolution_factor = (1 << 12);
              const uint8_t prev_mode = newStatus.mode;
              int32_t prev_value = newStatus.getDutyCycle();


              if (prev_mode != PIN_MODE_PWM) {
                prev_value = 0;
              }

              const int32_t step_value = ((static_cast<int32_t>(dutyCycle) - prev_value) * resolution_factor) /
                                         static_cast<int32_t>(fadeDuration_ms);
              int32_t curr_value = prev_value * resolution_factor;

              log += strformat(F(", fade: %d ms"), fadeDuration_ms);

              int i = fadeDuration_ms;

              while (i--) {
                curr_value += step_value;
                const int16_t new_value = curr_value / resolution_factor;

                P022_data->Plugin_022_Write(address, event->Par1, map(new_value, 0, range, 0, PCA9685_MAX_PWM));
                delay(1);
              }
            }
            P022_data->Plugin_022_Write(address, event->Par1, map(dutyCycle, 0, range, 0, PCA9685_MAX_PWM));

            newStatus.command = 1;
            newStatus.mode = PIN_MODE_PWM;
            newStatus.dutyCycle = dutyCycle;
            savePortStatus(key, newStatus);

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              addLog(LOG_LEVEL_INFO, log);
            }


            SendStatusOnlyIfNeeded(event, SEARCH_PIN_STATE, key, log, 0);
          }
          else {
            if (loglevelActiveFor(LOG_LEVEL_ERROR)) {
              addLog(LOG_LEVEL_ERROR, concat(log, strformat(F(" the pwm value %d  is invalid value."), event->Par2)));
            }
          }
        }
        else {
          if (loglevelActiveFor(LOG_LEVEL_ERROR)) {
            addLog(LOG_LEVEL_ERROR, concat(log, F(" is invalid value.")));
          }
        }
      }

      if ((equals(command, F("pcafrq"))) || (instanceCommand && (equals(command, F("frq")))))
      {
        success = true;

        if ((event->Par1 >= PCA9685_MIN_FREQUENCY) && (event->Par1 <= PCA9685_MAX_FREQUENCY))
        {
          if (!P022_data->p022_is_init(address))
          {
            P022_data->Plugin_022_initialize(address);
            P022_data->Plugin_022_writeRegister(address, PCA9685_MODE2, mode2);
          }
          P022_data->Plugin_022_Frequency(address, event->Par1);


          portStatusStruct newStatus;
          const uint32_t key = createKey(P022_PLUGIN_ID, 99);


          newStatus = globalMapPortStatus[key];
          newStatus.command = 1;
          newStatus.mode = PIN_MODE_UNDEFINED;
          newStatus.state = event->Par1;
          savePortStatus(key, newStatus);

          log = P022_data_struct::P022_logPrefix(address, F("FREQ "));
          log += event->Par1;
          addLog(LOG_LEVEL_INFO, log);


          SendStatusOnlyIfNeeded(event, SEARCH_PIN_STATE, key, log, 0);
        }
        else {
          if (loglevelActiveFor(LOG_LEVEL_ERROR))
            addLog(LOG_LEVEL_ERROR,
                  P022_data_struct::P022_logPrefix(address) +
                  strformat(F("frequency %d out of range."),
                    event->Par1));
        }
      }

      if (instanceCommand && (equals(command, F("mode2"))))
      {
        success = true;

        if ((event->Par1 >= 0) && (event->Par1 < PCA9685_MODE2_VALUES))
        {
          if (!P022_data->p022_is_init(address))
          {
            P022_data->Plugin_022_initialize(address);
            P022_data->Plugin_022_Frequency(address, freq);
          }
          P022_data->Plugin_022_writeRegister(address, PCA9685_MODE2, event->Par1);

          addLog(LOG_LEVEL_INFO, concat(
            P022_data_struct::P022_logPrefix(address, F("MODE2 0x")),
            formatToHex(event->Par1, 2)));
        }
        else {
          addLog(LOG_LEVEL_ERROR,
                 strformat(F("%s%s is out of range"),
                 P022_data_struct::P022_logPrefix(address, F("MODE2 0x")).c_str(),
                 formatToHex(event->Par1, 2).c_str()));
        }
      }

      if (equals(command, F("status")))
      {
        if (equals(parseString(string, 2), F("pca")))
        {
          P022_data->initModeFreq(address, mode2, freq);
          success = true;
          String dummyString;


          SendStatusOnlyIfNeeded(event, SEARCH_PIN_STATE, createKey(P022_PLUGIN_ID, event->Par2), dummyString, 0);
        }
      }

      if (instanceCommand && (equals(command, F("gpio"))))
      {
        success = true;
        log = P022_data_struct::P022_logPrefix(address, F("GPIO "));
        const bool allPins = equals(parseString(string, 2), F("all"));

        if (((event->Par1 >= 0) && (event->Par1 <= PCA9685_MAX_PINS)) ||
            allPins)
        {
          P022_data->initModeFreq(address, mode2, freq);
          int pin = event->Par1;

          if (allPins)
          {
            pin = -1;
            log += F("all");
          }
          else
          {
            log += pin;
          }

          if (event->Par2 == 0)
          {
            log += F(" off");
            P022_data->Plugin_022_Off(address, pin);
          }
          else
          {
            log += F(" on");
            P022_data->Plugin_022_On(address, pin);
          }
          addLog(LOG_LEVEL_INFO, log);


          portStatusStruct newStatus;
          const uint32_t key = createKey(P022_PLUGIN_ID, pin);


          newStatus = globalMapPortStatus[key];
          newStatus.command = 1;
          newStatus.mode = PIN_MODE_OUTPUT;
          newStatus.state = event->Par2;
          savePortStatus(key, newStatus);


          SendStatusOnlyIfNeeded(event, SEARCH_PIN_STATE, key, log, 0);
        }
        else {
          addLog(LOG_LEVEL_ERROR, concat(log, F(" is invalid value.")));
        }
      }

      if (instanceCommand && (equals(command, F("pulse"))))
      {
        success = true;
        log = P022_data_struct::P022_logPrefix(address, F("GPIO "));
        log += event->Par1;

        if ((event->Par1 >= 0) && (event->Par1 <= PCA9685_MAX_PINS))
        {
          P022_data->initModeFreq(address, mode2, freq);

          if (event->Par2 == 0)
          {
            log += F(" off");
            P022_data->Plugin_022_Off(address, event->Par1);
          }
          else
          {
            log += F(" on");
            P022_data->Plugin_022_On(address, event->Par1);
          }
          log += strformat(F(" Pulse set for %dms"), event->Par3);
          int autoreset = 0;

          if (event->Par3 > 0)
          {
            if (equals(parseString(string, 5), F("auto")))
            {
              autoreset = -1;
              log += F(" with autoreset infinity");
            }
            else
            {
              autoreset = event->Par4;

              if (autoreset > 0)
              {
                log += F(" for ");
                log += autoreset;
              }
            }
          }
          Scheduler.setPluginTaskTimer(event->Par3
                                       , event->TaskIndex
                                       , event->Par1
                                       , !event->Par2
                                       , event->Par3
                                       , autoreset);


          portStatusStruct newStatus;
          const uint32_t key = createKey(P022_PLUGIN_ID, event->Par1);


          newStatus = globalMapPortStatus[key];
          newStatus.command = 1;
          newStatus.mode = PIN_MODE_OUTPUT;
          newStatus.state = event->Par2;
          savePortStatus(key, newStatus);

          addLog(LOG_LEVEL_INFO, log);


          SendStatusOnlyIfNeeded(event, SEARCH_PIN_STATE, key, log, 0);
        }
        else {
          addLog(LOG_LEVEL_ERROR, concat(log, F(" is invalid value.")));
        }
      }

      break;
    }
    case PLUGIN_TASKTIMER_IN:
    {
      P022_data_struct *P022_data =
        static_cast<P022_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P022_data) {
        String log = P022_data_struct::P022_logPrefix(address, F("GPIO "));
        log += event->Par1;
        int autoreset = event->Par4;

        if (event->Par2 == 0)
        {
          log += F(" off");
          P022_data->Plugin_022_Off(address, event->Par1);
        }
        else
        {
          log += F(" on");
          P022_data->Plugin_022_On(address, event->Par1);
        }

        if ((autoreset > 0) || (autoreset == -1))
        {
          if (autoreset > -1)
          {
            log += F(" Pulse auto restart for ");
            log += autoreset;
            autoreset--;
          }
          Scheduler.setPluginTaskTimer(event->Par3
                                       , event->TaskIndex
                                       , event->Par1
                                       , !event->Par2
                                       , event->Par3
                                       , autoreset);
        }


        portStatusStruct newStatus;
        const uint32_t key = createKey(P022_PLUGIN_ID, event->Par1);


        newStatus = globalMapPortStatus[key];
        newStatus.command = 1;
        newStatus.mode = PIN_MODE_OUTPUT;
        newStatus.state = event->Par2;
        savePortStatus(key, newStatus);


        SendStatusOnlyIfNeeded(event, SEARCH_PIN_STATE, key, log, 0);
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P023_OLED.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P023
# 21 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P023_OLED.ino"
# include "src/PluginStructs/P023_data_struct.h"







#define PLUGIN_023 
#define PLUGIN_ID_023 23
#define PLUGIN_NAME_023 "Display - OLED SSD1306"
#define PLUGIN_VALUENAME1_023 "OLED"

boolean Plugin_023(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_023;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_023);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_023));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      success = OLedI2CAddressCheck(function, event->Par1, F("i2c_addr"), PCONFIG(0));

      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      string = F("Btn: ");
      string += formatGpioLabel(CONFIG_PIN3, false);
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG(4) = 1;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      const int controllerValues[2] = { 0, 1 };
      OLedFormController(F("use_sh1106"), controllerValues, PCONFIG(5));

      OLedFormRotation(F("rotate"), PCONFIG(1));

      {
        const int optionValues3[3] = { 1, 3, 2 };
        OLedFormSizes(F("size"), optionValues3, PCONFIG(3));
      }
      {
        const __FlashStringHelper *options4[2] = { F("Normal"), F("Optimized") };
        const int optionValues4[2] = { 1, 2 };
        addFormSelector(F("Font Width"), F("font_spacing"), 2, options4, optionValues4, PCONFIG(4));
      }
      {
        String strings[P23_Nlines];
        LoadCustomTaskSettings(event->TaskIndex, strings, P23_Nlines, P23_Nchars);

        for (int varNr = 0; varNr < 8; varNr++)
        {
          addFormTextBox(concat(F("Line "), varNr + 1), getPluginCustomArgName(varNr), strings[varNr], 64);
        }
      }


      addFormPinSelect(PinSelectPurpose::Generic_input, formatGpioName_input_optional(F("Display button")), F("taskdevicepin3"), CONFIG_PIN3);

      addFormNumericBox(F("Display Timeout"), F("ptimer"), PCONFIG(2));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("i2c_addr"));
      PCONFIG(1) = getFormItemInt(F("rotate"));
      PCONFIG(2) = getFormItemInt(F("ptimer"));
      PCONFIG(3) = getFormItemInt(F("size"));
      PCONFIG(4) = getFormItemInt(F("font_spacing"));
      PCONFIG(5) = getFormItemInt(F("use_sh1106"));



      char deviceTemplate[P23_Nlines][P23_Nchars] = {};
      String error;

      for (uint8_t varNr = 0; varNr < P23_Nlines; varNr++) {
        if (!safe_strncpy(deviceTemplate[varNr], webArg(getPluginCustomArgName(varNr)), P23_Nchars)) {
          error += getCustomTaskSettingsError(varNr);
        }
      }

      if (error.length() > 0) {
        addHtmlError(error);
      }
      SaveCustomTaskSettings(event->TaskIndex, reinterpret_cast<const uint8_t *>(&deviceTemplate), sizeof(deviceTemplate));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      uint8_t type = 0;
      P023_data_struct::Spacing font_spacing = P023_data_struct::Spacing::normal;


      switch (PCONFIG(3)) {
        case 1:

          type = P023_data_struct::OLED_128x64;
          break;
        case 2:
          type = P023_data_struct::OLED_64x48;
          break;
        case 3:
          type = P023_data_struct::OLED_128x32;
          break;
      }

      if (PCONFIG(1) == 2) {
        type |= P023_data_struct::OLED_rotated;
      }

      if (PCONFIG(4) > 0) {
        font_spacing = static_cast<P023_data_struct::Spacing>(PCONFIG(4));
      }

      initPluginTaskData(event->TaskIndex, new (std::nothrow) P023_data_struct(PCONFIG(0), type, font_spacing, PCONFIG(2), PCONFIG(5)));
      P023_data_struct *P023_data = static_cast<P023_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P023_data) {
        P023_data->StartUp_OLED(event);
        P023_data->clearDisplay();

        if (PCONFIG(1) == 2) {
          P023_data->sendCommand(0xA0 | 0x1);
          P023_data->sendCommand(0xC8);
        }

        P023_data->sendStrXY("ESP Easy ", 0, 0);

        if (validGpio(CONFIG_PIN3)) {
          pinMode(CONFIG_PIN3, INPUT_PULLUP);
        }
        success = true;
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      if (validGpio(CONFIG_PIN3)) {
        if (!digitalRead(CONFIG_PIN3)) {
          P023_data_struct *P023_data = static_cast<P023_data_struct *>(getPluginTaskData(event->TaskIndex));

          if (nullptr != P023_data) {
            P023_data->setDisplayTimer(PCONFIG(2));
          }
        }
      }
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P023_data_struct *P023_data = static_cast<P023_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P023_data) {
        P023_data->checkDisplayTimer();
      }
      break;
    }

    case PLUGIN_READ:
    {
      P023_data_struct *P023_data = static_cast<P023_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P023_data) {
        P023_data->plugin_read(event);
      }
      success = false;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_VALUES:
    {
      P023_data_struct *P023_data =
        static_cast<P023_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P023_data) {
        success = P023_data->web_show_values();
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P023_data_struct *P023_data = static_cast<P023_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P023_data) {
        success = P023_data->plugin_write(event, string);
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P024_MLX90614.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P024
# 13 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P024_MLX90614.ino"
# include "src/PluginStructs/P024_data_struct.h"



#define PLUGIN_024 
#define PLUGIN_ID_024 24
#define PLUGIN_NAME_024 "Environment - MLX90614"
#define PLUGIN_VALUENAME1_024 "Temperature"

boolean Plugin_024(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;


  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_024;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 16;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].I2CMax100kHz = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_024);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_024));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x5a);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x5a;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      # define MLX90614_OPTION 2

      const __FlashStringHelper *options[MLX90614_OPTION] = {
        F("IR object temperature"),
        F("Ambient temperature")
      };
      const int optionValues[MLX90614_OPTION] = {
        (0x07),
        (0x06)
      };
      addFormSelector(F("Option"), F("option"), MLX90614_OPTION, options, optionValues, PCONFIG(0));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("option"));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      const uint8_t unit = CONFIG_PORT;
      const uint8_t address = 0x5A + unit;

      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P024_data_struct(address));
      break;
    }

    case PLUGIN_READ:
    {
      P024_data_struct *P024_data =
        static_cast<P024_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P024_data) {
        UserVar.setFloat(event->TaskIndex, 0, P024_data->readTemperature(PCONFIG(0)));

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("MLX90614  : Temperature: ");
          log += formatUserVarNoCheck(event->TaskIndex, 0);
          addLogMove(LOG_LEVEL_INFO, log);
        }


        success = true;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P025_ADS1115.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P025






# include "src/PluginStructs/P025_data_struct.h"

#define PLUGIN_025 
#define PLUGIN_ID_025 25
#define PLUGIN_NAME_025 "Analog input - ADS1x15"
#define PLUGIN_VALUENAME1_025 "Analog"


boolean Plugin_025(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;


  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_025;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_025);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      const int valueCount = P025_NR_OUTPUT_VALUES;

      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < valueCount) {
          const uint8_t pconfigIndex = P025_PCONFIG_INDEX(i);
          ExtraTaskSettings.setTaskDeviceValueName(i, Plugin_025_valuename(PCONFIG(pconfigIndex), false));
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P025_NR_OUTPUT_VALUES;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(P025_SENSOR_TYPE_INDEX));
      event->idx = P025_SENSOR_TYPE_INDEX;
      success = true;
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x48, 0x49, 0x4A, 0x4B };
      constexpr int nrAddressOptions = NR_ELEMENTS(i2cAddressValues);

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), nrAddressOptions, i2cAddressValues, P025_I2C_ADDR);
      } else {
        success = intArrayContains(nrAddressOptions, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P025_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG(P025_SENSOR_TYPE_INDEX) = static_cast<uint8_t>(Sensor_VType::SENSOR_TYPE_SINGLE);
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      success = P025_data_struct::webformLoad(event);
      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      const __FlashStringHelper *valOptions[] = {
        Plugin_025_valuename(0, true),
        Plugin_025_valuename(1, true),
        Plugin_025_valuename(2, true),
        Plugin_025_valuename(3, true),
        Plugin_025_valuename(4, true),
        Plugin_025_valuename(5, true),
        Plugin_025_valuename(6, true),
        Plugin_025_valuename(7, true)
      };
      constexpr int nrOptions = NR_ELEMENTS(valOptions);

      for (uint8_t i = 0; i < P025_NR_OUTPUT_VALUES; i++) {
        sensorTypeHelper_loadOutputSelector(event,
                                            P025_PCONFIG_INDEX(i),
                                            i,
                                            nrOptions,
                                            valOptions);
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      success = P025_data_struct::webformSave(event);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      success = P025_data_struct::webform_showConfig(event);
      break;
    }

    case PLUGIN_INIT:
    {





      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P025_data_struct(event));
      break;
    }

    case PLUGIN_READ:
    {
      const P025_data_struct *P025_data = static_cast<P025_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P025_data) {
        for (taskVarIndex_t i = 0; i < P025_NR_OUTPUT_VALUES; ++i) {
          float value{};

          if (P025_data->read(value, i)) {
            success = true;

        # ifndef BUILD_NO_DEBUG
            String log;

            if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
              log = F("ADS1x15 : Analog value: ");
              log += value;
              log += F(" / Channel: ");
              log += P025_MUX(i);
            }
        # endif

            UserVar.setFloat(event->TaskIndex, i, value);

            const P025_VARIOUS_BITS_t p025_variousBits(P025_VARIOUS_BITS);

            if (p025_variousBits.cal) {
              const int adc1 = P025_CAL_ADC1;
              const int adc2 = P025_CAL_ADC2;
              const float out1 = P025_CAL_OUT1;
              const float out2 = P025_CAL_OUT2;

              if (adc1 != adc2)
              {
                const float normalized = static_cast<float>(value - adc1) / static_cast<float>(adc2 - adc1);
                UserVar.setFloat(event->TaskIndex, i, normalized * (out2 - out1) + out1);
            # ifndef BUILD_NO_DEBUG

                if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
                  log += ' ';
                  log += formatUserVarNoCheck(event->TaskIndex, i);
                }
            # endif
              }
            }

        # ifndef BUILD_NO_DEBUG

            if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
              addLogMove(LOG_LEVEL_DEBUG, log);
            }
        # endif
          }
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P026_Sysinfo.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P026
# 19 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P026_Sysinfo.ino"
#define PLUGIN_026 
#define PLUGIN_ID_026 26
#define PLUGIN_NAME_026 "Generic - System Info"

# include "src/PluginStructs/P026_data_struct.h"



boolean Plugin_026(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_026;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_026);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      success = P026_data_struct::GetDeviceValueNames(event);
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P026_NR_OUTPUT_VALUES;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(P026_SENSOR_TYPE_INDEX));
      event->idx = P026_SENSOR_TYPE_INDEX;
      success = true;
      break;
    }


    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG(0) = 0;

      for (uint8_t i = 1; i < VARS_PER_TASK; ++i) {
        PCONFIG(i) = 11;
      }
      PCONFIG(P026_SENSOR_TYPE_INDEX) = static_cast<uint8_t>(Sensor_VType::SENSOR_TYPE_QUAD);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      success = P026_data_struct::WebformLoadOutputSelector(event);
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      success = P026_data_struct::WebformSave(event);
      break;
    }

    case PLUGIN_INIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      success = P026_data_struct::Plugin_Read(event);
      break;
    }
    # ifndef PLUGIN_BUILD_MINIMAL_OTA
    case PLUGIN_GET_CONFIG_VALUE:
    {
      success = P026_data_struct::Plugin_GetConfigValue(event, string);
      break;
    }
    # endif
# if FEATURE_PACKED_RAW_DATA
    case PLUGIN_GET_PACKED_RAW_DATA:
    {
      success = P026_data_struct::Plugin_GetPackedRawData(event, string);
      break;
    }
# endif
  }
  return success;
}


#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P027_INA219.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P027
# 14 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P027_INA219.ino"
# include "src/PluginStructs/P027_data_struct.h"

#define PLUGIN_027 
#define PLUGIN_ID_027 27
#define PLUGIN_NAME_027 "Energy (DC) - INA219"
#define PLUGIN_VALUENAME1_027 "Voltage"
#define PLUGIN_VALUENAME2_027 "Current"
#define PLUGIN_VALUENAME3_027 "Power"

#define P027_I2C_ADDR (uint8_t)PCONFIG(1)

boolean Plugin_027(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_027;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_027);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_027));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_027));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_027));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
# 85 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P027_INA219.ino"
      const uint8_t i2cAddressValues[] = { 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
                                           0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 16, i2cAddressValues, P027_I2C_ADDR);
      } else {
        success = intArrayContains(16, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P027_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *optionsMode[] = { F("32V, 2A"), F("32V, 1A"), F("16V, 0.4A") };
        const int optionValuesMode[] = { 0, 1, 2 };
        addFormSelector(F("Measure range"), F("range"), 3, optionsMode, optionValuesMode, PCONFIG(0));
      }
      {
        const __FlashStringHelper *options[] = { F("Voltage"), F("Current"), F("Power"), F("Voltage/Current/Power") };
        addFormSelector(F("Measurement Type"), F("measuretype"), 4, options, nullptr, PCONFIG(2));
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("range"));
      PCONFIG(1) = getFormItemInt(F("i2c_addr"));
      PCONFIG(2) = getFormItemInt(F("measuretype"));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      const uint8_t i2caddr = P027_I2C_ADDR;

      initPluginTaskData(event->TaskIndex, new (std::nothrow) P027_data_struct(i2caddr));
      P027_data_struct *P027_data =
        static_cast<P027_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P027_data) {
        const bool mustLog = loglevelActiveFor(LOG_LEVEL_INFO);
        String log;

        if (mustLog) {
          log = formatToHex(i2caddr, F("INA219 0x"), 2);
          log += F(" setting Range to: ");
        }

        switch (PCONFIG(0)) {
          case 0:
          {
            if (mustLog) {
              log += F("32V, 2A");
            }
            P027_data->setCalibration_32V_2A();
            break;
          }
          case 1:
          {
            if (mustLog) {
              log += F("32V, 1A");
            }
            P027_data->setCalibration_32V_1A();
            break;
          }
          case 2:
          {
            if (mustLog) {
              log += F("16V, 400mA");
            }
            P027_data->setCalibration_16V_400mA();
            break;
          }
        }

        if (mustLog) {
          addLogMove(LOG_LEVEL_INFO, log);
        }
        success = true;
      }
      break;
    }

    case PLUGIN_READ:
    {




      P027_data_struct *P027_data =
        static_cast<P027_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P027_data) {
        float voltage = P027_data->getBusVoltage_V() + (P027_data->getShuntVoltage_mV() / 1000);
        float current = P027_data->getCurrent_mA() / 1000;
        float power = voltage * current;

        UserVar.setFloat(event->TaskIndex, 0, voltage);
        UserVar.setFloat(event->TaskIndex, 1, current);
        UserVar.setFloat(event->TaskIndex, 2, power);

        const bool mustLog = loglevelActiveFor(LOG_LEVEL_INFO);
        String log;

        if (mustLog) {
          log = formatToHex(P027_I2C_ADDR, F("INA219 0x"), 2);
        }



        switch (PCONFIG(2)) {
          case 0:
          {
            event->sensorType = Sensor_VType::SENSOR_TYPE_SINGLE;
            UserVar.setFloat(event->TaskIndex, 0, voltage);

            if (mustLog) {
              log += F(": Voltage: ");
              log += voltage;
            }
            break;
          }
          case 1:
          {
            event->sensorType = Sensor_VType::SENSOR_TYPE_SINGLE;
            UserVar.setFloat(event->TaskIndex, 0, current);

            if (mustLog) {
              log += F(" Current: ");
              log += current;
            }
            break;
          }
          case 2:
          {
            event->sensorType = Sensor_VType::SENSOR_TYPE_SINGLE;
            UserVar.setFloat(event->TaskIndex, 0, power);

            if (mustLog) {
              log += F(" Power: ");
              log += power;
            }
            break;
          }
          case 3:
          {
            event->sensorType = Sensor_VType::SENSOR_TYPE_TRIPLE;
            UserVar.setFloat(event->TaskIndex, 0, voltage);
            UserVar.setFloat(event->TaskIndex, 1, current);
            UserVar.setFloat(event->TaskIndex, 2, power);

            if (mustLog) {
              log += F(": Voltage: ");
              log += voltage;
              log += F(" Current: ");
              log += current;
              log += F(" Power: ");
              log += power;
            }
            break;
          }
        }

        if (mustLog) {
          addLogMove(LOG_LEVEL_INFO, log);
        }
        success = true;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P028_BME280.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P028
# 16 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P028_BME280.ino"
# include "src/PluginStructs/P028_data_struct.h"



#define PLUGIN_028 
#define PLUGIN_ID_028 28
#define PLUGIN_NAME_028 "Environment - BMx280"
#define PLUGIN_VALUENAME1_028 "Temperature"
#define PLUGIN_VALUENAME2_028 "Humidity"
#define PLUGIN_VALUENAME3_028 "Pressure"


boolean Plugin_028(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_028;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_HUM_BARO;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].ErrorStateValues = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_028);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_028));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_028));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_028));
      break;
    }

    case PLUGIN_INIT_VALUE_RANGES:
    {

      ExtraTaskSettings.setAllowedRange(0, -40.0f, 85.0f);
      ExtraTaskSettings.setAllowedRange(1, 0.0f, 100.0f);
      ExtraTaskSettings.setAllowedRange(2, 300.0f, 1100.0f);

      switch (P028_ERROR_STATE_OUTPUT) {
        case P028_ERROR_IGNORE:
          ExtraTaskSettings.setIgnoreRangeCheck(0);
          break;
        case P028_ERROR_MIN_RANGE:
          ExtraTaskSettings.TaskDeviceErrorValue[0] = ExtraTaskSettings.TaskDeviceMinValue[0] - 1.0f;
          break;
        case P028_ERROR_ZERO:
          ExtraTaskSettings.TaskDeviceErrorValue[0] = 0.0f;
          break;
        case P028_ERROR_MAX_RANGE:
          ExtraTaskSettings.TaskDeviceErrorValue[0] = ExtraTaskSettings.TaskDeviceMaxValue[0] + 1.0f;
          break;
        case P028_ERROR_NAN:
          ExtraTaskSettings.TaskDeviceErrorValue[0] = NAN;
          break;
        # ifndef LIMIT_BUILD_SIZE
        case P028_ERROR_MIN_K:
          ExtraTaskSettings.TaskDeviceErrorValue[0] = -274.0f;
          break;
        # endif
        default:
          break;
      }

      ExtraTaskSettings.TaskDeviceErrorValue[1] = -1.0f;
      ExtraTaskSettings.TaskDeviceErrorValue[2] = -1.0f;

      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      const P028_data_struct::BMx_DetectMode detectMode = static_cast<P028_data_struct::BMx_DetectMode>(P028_DETECTION_MODE);


      if ((Settings.TaskDeviceDataFeed[event->TaskIndex] != 0) && (P028_data_struct::BMx_DetectMode::BMP280 == detectMode)) {

        event->sensorType = Sensor_VType::SENSOR_TYPE_TEMP_EMPTY_BARO;
        event->idx = getValueCountFromSensorType(Sensor_VType::SENSOR_TYPE_TEMP_EMPTY_BARO);
      }

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      const float tempOffset = P028_TEMPERATURE_OFFSET / 10.0f;
      success = initPluginTaskData(
        event->TaskIndex,
        new (std::nothrow) P028_data_struct(P028_I2C_ADDRESS, tempOffset));

      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x76, 0x77 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, P028_I2C_ADDRESS);
        addFormNote(F("SDO Low=0x76, High=0x77"));
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P028_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      bool wire_status = false;
      const uint8_t chip_id = I2C_read8_reg(P028_I2C_ADDRESS, BMx280_REGISTER_CHIPID, &wire_status);

      if (wire_status) {
        addRowLabel(F("Detected Sensor Type"));
        addHtml(P028_data_struct::getDeviceName(static_cast<P028_data_struct::BMx_ChipId>(chip_id)));
      }

      addFormNumericBox(F("Altitude"), F("elev"), P028_ALTITUDE);
      addUnit('m');

      addFormNumericBox(F("Temperature offset"), F("tempoffset"), P028_TEMPERATURE_OFFSET);
      addUnit(F("x 0.1C"));
      String offsetNote = F("Offset in units of 0.1 degree Celsius");

      P028_data_struct *P028_data =
        static_cast<P028_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P028_data) {
        if ((P028_data_struct::BMx_DetectMode::BMP280 != static_cast<P028_data_struct::BMx_DetectMode>(P028_DETECTION_MODE)) &&
            P028_data->hasHumidity()) {
          offsetNote += F(" (also correct humidity)");
        }
      }
      addFormNote(offsetNote);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD_ALWAYS:
    {
      if (Settings.TaskDeviceDataFeed[event->TaskIndex] != 0) {
        const __FlashStringHelper *detectOptionList[] = {
          P028_data_struct::getDeviceName(P028_data_struct::BMx_ChipId::BME280_DEVICE),
          P028_data_struct::getDeviceName(P028_data_struct::BMx_ChipId::BMP280_DEVICE),
        };
        const int detectOptions[] = {
          static_cast<int>(P028_data_struct::BMx_DetectMode::BME280),
          static_cast<int>(P028_data_struct::BMx_DetectMode::BMP280),
        };
        addFormSelector(F("Output values mode"), F("det"), 2, detectOptionList, detectOptions, P028_DETECTION_MODE);

        success = true;
      }
      break;
    }


# if FEATURE_PLUGIN_STATS && FEATURE_CHART_JS
    case PLUGIN_WEBFORM_LOAD_SHOW_STATS:
    {
      P028_data_struct *P028_data =
        static_cast<P028_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P028_data) {
        if ((P028_data_struct::BMx_DetectMode::BMP280 != static_cast<P028_data_struct::BMx_DetectMode>(P028_DETECTION_MODE)) &&
            P028_data->hasHumidity())
        {
          P028_data->plot_ChartJS_scatter(
            0,
            1,
            F("temphumscatter"),
            { F("Temp/Humidity Scatter Plot") },
            { F("temp/hum"), F("rgb(255, 99, 132)") },
            500,
            500);
        }
      }

      break;
    }
#endif


    case PLUGIN_WEBFORM_SHOW_ERRORSTATE_OPT:
    {
      # ifndef BUILD_NO_DEBUG
      addLog(LOG_LEVEL_INFO, F("BMx280: SHOW_ERRORSTATE_OPT"));
      # endif


      const __FlashStringHelper *resultsOptions[] = {
        F("Ignore"),
        F("Min -1 (-41&deg;C)"),
        F("0"),
        F("Max +1 (+86&deg;C)"),
        F("NaN"),
        # ifndef LIMIT_BUILD_SIZE
        F("-1&deg;K (-274&deg;C)")
        # endif
      };
      const int resultsOptionValues[] = {
        P028_ERROR_IGNORE,
        P028_ERROR_MIN_RANGE,
        P028_ERROR_ZERO,
        P028_ERROR_MAX_RANGE,
        P028_ERROR_NAN,
        # ifndef LIMIT_BUILD_SIZE
        P028_ERROR_MIN_K
        # endif
      };
      constexpr int P028_ERROR_STATE_COUNT = NR_ELEMENTS(resultsOptions);
      addFormSelector(F("Temperature Error Value"),
                      F("err"),
                      P028_ERROR_STATE_COUNT,
                      resultsOptions,
                      resultsOptionValues,
                      P028_ERROR_STATE_OUTPUT);

      break;
    }

    case PLUGIN_READ_ERROR_OCCURED:
    {


      P028_data_struct *P028_data =
        static_cast<P028_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P028_data) {
        if (P028_data->lastMeasurementError) {
          success = true;
          string = F("Sensor Not Found");
        }
      }
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P028_I2C_ADDRESS = getFormItemInt(F("i2c_addr"));
      P028_ALTITUDE = getFormItemInt(F("elev"));
      P028_TEMPERATURE_OFFSET = getFormItemInt(F("tempoffset"));
      P028_ERROR_STATE_OUTPUT = getFormItemInt(F("err"));

      if (Settings.TaskDeviceDataFeed[event->TaskIndex] != 0) {
        P028_DETECTION_MODE = getFormItemInt(F("det"));
      }
      success = true;
      break;
    }
    case PLUGIN_ONCE_A_SECOND:
    {
      P028_data_struct *P028_data =
        static_cast<P028_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P028_data) {
        if (P028_data->updateMeasurements(event->TaskIndex)) {

          Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 10);
        }
      }
      break;
    }

    case PLUGIN_READ:
    {
      P028_data_struct *P028_data =
        static_cast<P028_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P028_data) {


        if (P028_data->state != P028_data_struct::BMx_New_values) {
          P028_data->startMeasurement();

          if (P028_ERROR_STATE_OUTPUT != P028_ERROR_IGNORE) {
            if (P028_data->lastMeasurementError) {
              success = true;

              for (uint8_t i = 0; i < 3; i++) {
                UserVar.setFloat(event->TaskIndex, i, ExtraTaskSettings.TaskDeviceErrorValue[i]);
              }
            }
          }
        } else {
          P028_data->state = P028_data_struct::BMx_Values_read;

          if (!P028_data->hasHumidity()) {

            event->sensorType = Sensor_VType::SENSOR_TYPE_TEMP_EMPTY_BARO;
            event->idx = getValueCountFromSensorType(Sensor_VType::SENSOR_TYPE_TEMP_EMPTY_BARO);
          }
          UserVar.setFloat(event->TaskIndex, 0, ExtraTaskSettings.checkAllowedRange(0, P028_data->last_temp_val));
          UserVar.setFloat(event->TaskIndex, 1, P028_data->last_hum_val);
          const int elev = P028_ALTITUDE;

          if (elev != 0) {
            UserVar.setFloat(event->TaskIndex, 2, pressureElevation(P028_data->last_press_val, elev));
          } else {
            UserVar.setFloat(event->TaskIndex, 2, P028_data->last_press_val);
          }

          # ifndef LIMIT_BUILD_SIZE

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String hum;
            if (P028_data->hasHumidity()) {
              hum = formatUserVarNoCheck(event->TaskIndex, 1);
            }
            addLogMove(LOG_LEVEL_INFO, concat(
              P028_data_struct::getDeviceName(P028_data->sensorID),
              strformat(
                F(": Addr: %s T: %s H: %s P: %s"),
                formatToHex(P028_I2C_ADDRESS, 2).c_str(),
                formatUserVarNoCheck(event->TaskIndex, 0).c_str(),
                hum.c_str(),
                formatUserVarNoCheck(event->TaskIndex, 2).c_str())));
          }
          # endif
          success = true;
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P029_Output.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P029





#define PLUGIN_029 
#define PLUGIN_ID_029 29
#define PLUGIN_NAME_029 "Output - Domoticz MQTT Helper"
#define PLUGIN_VALUENAME1_029 "Output"
boolean Plugin_029(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {

    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_029;
        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = false;
        Device[deviceCount].ValueCount = 1;
        Device[deviceCount].SendDataOption = false;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_029);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_029));
        ExtraTaskSettings.TaskDeviceValueDecimals[0] = 0;
        break;
      }

    case PLUGIN_WEBFORM_LOAD:
      {

        uint8_t controllerNr = 0;
        for (controllerIndex_t i=0; i < CONTROLLER_MAX; i++)
        {

          if (Settings.Protocol[i] == 2) { controllerNr = i; }
        }

        addRowLabel(F("IDX"));
        addNumericBox(
          concat(F("TDID"), controllerNr + 1),
          Settings.TaskDeviceID[controllerNr][event->TaskIndex],
          0,
          DOMOTICZ_MAX_IDX);
        success = true;
        break;
      }

    case PLUGIN_INIT:
      {
        success = true;
        break;
      }
  }
  return success;
}
#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P031_SHT1X.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P031






# include "src/PluginStructs/P031_data_struct.h"

#define PLUGIN_031 
#define PLUGIN_ID_031 31
#define PLUGIN_NAME_031 "Environment - SHT1x"
#define PLUGIN_VALUENAME1_031 "Temperature"
#define PLUGIN_VALUENAME2_031 "Humidity"

boolean Plugin_031(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_031;
      Device[deviceCount].Type = DEVICE_TYPE_DUAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_HUM;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = true;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_031);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_031));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_031));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_bidirectional(F("Data"));
      event->String2 = formatGpioName_output(F("SCK"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Clock Delay"), F("delay"), PCONFIG(0), 0, P031_MAX_CLOCK_DELAY);
      addUnit(F("usec"));
      addFormNote(F("Reduce clock/data frequency to allow for longer cables"));
      success = true;
      break;
    }
    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("delay"));
      success = true;
      break;
    }


    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P031_data_struct());
      P031_data_struct *P031_data =
        static_cast<P031_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P031_data) {
        return success;
      }
        # ifndef BUILD_NO_DEBUG
      uint8_t status =
        # endif
      P031_data->init(
        CONFIG_PIN1, CONFIG_PIN2,
        Settings.TaskDevicePin1PullUp[event->TaskIndex],
        PCONFIG(0));
        # ifndef BUILD_NO_DEBUG

      if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
        String log = F("SHT1x : Status uint8_t: ");
        log += String(status, HEX);
        log += F(" - resolution: ");
        log += ((status & 1) ? F("low") : F("high"));
        log += F(" reload from OTP: ");
        log += (((status >> 1) & 1) ? F("yes") : F("no"));
        log += F(", heater: ");
        log += (((status >> 2) & 1) ? F("on") : F("off"));
        addLogMove(LOG_LEVEL_DEBUG, log);
      }
        # endif
      success = true;
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P031_data_struct *P031_data =
        static_cast<P031_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P031_data) {
        if (P031_data->process()) {

          Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 10);
        }
      }
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      P031_data_struct *P031_data =
        static_cast<P031_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P031_data) {
        if (P031_data->measurementReady()) {
          UserVar.setFloat(event->TaskIndex, 0, P031_data->tempC);
          UserVar.setFloat(event->TaskIndex, 1, P031_data->rhTrue);
          success = true;
          P031_data->state = P031_IDLE;
        } else if (P031_data->state == P031_IDLE) {
          P031_data->startMeasurement();
        } else if (P031_data->hasError()) {

          if (loglevelActiveFor(LOG_LEVEL_ERROR)) {
            switch (P031_data->state) {
              case P031_COMMAND_NO_ACK:
                addLog(LOG_LEVEL_ERROR, F("SHT1x : Sensor did not ACK command"));
                break;
              case P031_NO_DATA:
                addLog(LOG_LEVEL_ERROR, F("SHT1x : Data not ready"));
                break;
              default:
                break;
            }
          }
          P031_data->state = P031_IDLE;
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P032_MS5611.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P032







# include "src/PluginStructs/P032_data_struct.h"

#define PLUGIN_032 
#define PLUGIN_ID_032 32
#define PLUGIN_NAME_032 "Environment - MS5611 (GY-63)"
#define PLUGIN_VALUENAME1_032 "Temperature"
#define PLUGIN_VALUENAME2_032 "Pressure"

boolean Plugin_032(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_032;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_BARO;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_032);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_032));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_032));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x77, 0x76 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, PCONFIG(0));
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Altitude [m]"), F("elev"), PCONFIG(1));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("i2c_addr"));
      PCONFIG(1) = getFormItemInt(F("elev"));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(
        event->TaskIndex,
        new (std::nothrow) P032_data_struct(PCONFIG(0)));
      break;
    }

    case PLUGIN_READ:
    {
      P032_data_struct *P032_data =
        static_cast<P032_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P032_data) {
        if (P032_data->begin()) {
          P032_data->read_prom();
          P032_data->readout();

          UserVar.setFloat(event->TaskIndex, 0, P032_data->ms5611_temperature / 100);

          const int elev = PCONFIG(1);

          if (elev != 0)
          {
            UserVar.setFloat(event->TaskIndex, 1, pressureElevation(P032_data->ms5611_pressure, elev));
          } else {
            UserVar.setFloat(event->TaskIndex, 1, P032_data->ms5611_pressure);
          }

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log = F("MS5611  : Temperature: ");
            log += formatUserVarNoCheck(event->TaskIndex, 0);
            addLogMove(LOG_LEVEL_INFO, log);
            log = F("MS5611  : Barometric Pressure: ");
            log += formatUserVarNoCheck(event->TaskIndex, 1);
            addLogMove(LOG_LEVEL_INFO, log);
          }
          success = true;
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P033_Dummy.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P033





#define PLUGIN_033 
#define PLUGIN_ID_033 33
#define PLUGIN_NAME_033 "Generic - Dummy Device"
#define PLUGIN_VALUENAME1_033 "Dummy"
boolean Plugin_033(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_033;
      Device[deviceCount].Type = DEVICE_TYPE_DUMMY;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].DecimalsOnly = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::All;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_033);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {

      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_033));
      const Sensor_VType sensorType = static_cast<Sensor_VType>(PCONFIG(0));
      if (isIntegerOutputDataType(sensorType)) {
        for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
          ExtraTaskSettings.TaskDeviceValueDecimals[i] = 0;
        }
      }
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = getValueCountFromSensorType(static_cast<Sensor_VType>(PCONFIG(0)));
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(0));
      event->idx = 0;
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(0));
      #ifndef LIMIT_BUILD_SIZE

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        const uint8_t valueCount =
          getValueCountFromSensorType(static_cast<Sensor_VType>(PCONFIG(0)));
        for (uint8_t x = 0; x < valueCount; x++)
        {
          String log = F("Dummy: value ");
          log += x + 1;
          log += F(": ");
          log += formatUserVarNoCheck(event->TaskIndex, x);
          addLogMove(LOG_LEVEL_INFO, log);
        }
      }
      #endif
      success = true;
      break;
    }

  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P034_DHT12.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P034







#define PLUGIN_034 
#define PLUGIN_ID_034 34
#define PLUGIN_NAME_034 "Environment - DHT12 (I2C)"
#define PLUGIN_VALUENAME1_034 "Temperature"
#define PLUGIN_VALUENAME2_034 "Humidity"

#define DHT12_I2C_ADDRESS 0x5C

boolean Plugin_034(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_034;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_HUM;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_034);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_034));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_034));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == DHT12_I2C_ADDRESS);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = DHT12_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_INIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      uint8_t dht_dat[5];


      uint8_t i;


      boolean error = false;

      Wire.beginTransmission(DHT12_I2C_ADDRESS);
      Wire.write(0);
      Wire.endTransmission();

      if (Wire.requestFrom(DHT12_I2C_ADDRESS, 5) == 5) {
        for (i = 0; i < 5; i++)
        {
          dht_dat[i] = Wire.read();
        }
      } else {
        error = true;
      }

      if (!error)
      {

        uint8_t dht_check_sum = dht_dat[0] + dht_dat[1] + dht_dat[2] + dht_dat[3];

        if (dht_dat[4] == dht_check_sum)
        {
          float temperature = float(dht_dat[2] * 10 + (dht_dat[3] & 0x7f)) / 10.0f;

          if (dht_dat[3] & 0x80) { temperature = -temperature; }
          float humidity = float(dht_dat[0] * 10 + dht_dat[1]) / 10.0f;

          UserVar.setFloat(event->TaskIndex, 0, temperature);
          UserVar.setFloat(event->TaskIndex, 1, humidity);
          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log = F("DHT12: Temperature: ");
            log += formatUserVarNoCheck(event->TaskIndex, 0);
            addLogMove(LOG_LEVEL_INFO, log);
            log = F("DHT12: Humidity: ");
            log += formatUserVarNoCheck(event->TaskIndex, 1);
            addLogMove(LOG_LEVEL_INFO, log);
# 128 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P034_DHT12.ino"
          }
          success = true;
        }
      }

      if (!success)
      {
        addLog(LOG_LEVEL_INFO, F("DHT12: No reading!"));
        UserVar.setFloat(event->TaskIndex, 0, NAN);
        UserVar.setFloat(event->TaskIndex, 1, NAN);
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P035_IRTX.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P035
# 48 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P035_IRTX.ino"
# include "./src/PluginStructs/P035_data_struct.h"

#define PLUGIN_035 
#define PLUGIN_ID_035 35
#define PLUGIN_NAME_035 "Communication - IR Transmit"

boolean Plugin_035(uint8_t function, struct EventStruct *event, String& string)
{
  bool success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_035;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].SendDataOption = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_035);
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("LED"));
      break;
    }
    case PLUGIN_WEBFORM_LOAD:
    {
      addFormCheckBox(F("Inverted output"), F("invert"), PCONFIG(0) == 1);

      addRowLabel(F("Command"));
      addHtml(F("IRSEND,[PROTOCOL],[DATA],[BITS optional],[REPEATS optional]<BR>BITS and REPEATS are optional and default to 0<BR/>"));
      # ifdef P016_P035_Extended_AC
      addHtml(F("IRSENDAC,{JSON formatted AC command}"));
      # endif

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = isFormItemChecked(F("invert")) ? 1 : 0;
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P035_data_struct(CONFIG_PIN1, PCONFIG(0) == 1));
      P035_data_struct *P035_data = static_cast<P035_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P035_data) {
        success = P035_data->plugin_init(event);
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P035_data_struct *P035_data = static_cast<P035_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P035_data) {
        success = P035_data->plugin_write(event, string);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P036_FrameOLED.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P036
# 215 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P036_FrameOLED.ino"
# include "src/PluginStructs/P036_data_struct.h"
# ifdef P036_CHECK_HEAP
# include "src/Helpers/Memory.h"
# endif
# include "src/ESPEasyCore/ESPEasyNetwork.h"

#define PLUGIN_036 
#define PLUGIN_ID_036 36
#define PLUGIN_NAME_036 "Display - OLED SSD1306/SH1106 Framed"
#define PLUGIN_VALUENAME1_036 "OLED"


# ifdef P036_CHECK_HEAP
void P036_CheckHeap(String dbgtxt);
# endif

boolean Plugin_036(uint8_t function, struct EventStruct *event, String& string)
{
  bool success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_036;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_036);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_036));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      success = OLedI2CAddressCheck(function, event->Par1, F("i2c_addr"), P036_ADR);

      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P036_ADR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      string = concat(F("Btn: "), formatGpioLabel(CONFIG_PIN3, false));
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
# ifdef PLUGIN_036_DEBUG
      addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_WEBFORM_LOAD ..."));
# endif
# ifdef P036_CHECK_HEAP
      P036_CheckHeap(F("_LOAD: Entering"));
# endif



      OLedFormController(F("controller"), nullptr, P036_CONTROLLER);

      {
        const int optionValues[] =
        { static_cast<int>(p036_resolution::pix128x64),
          static_cast<int>(p036_resolution::pix128x32),
          static_cast<int>(p036_resolution::pix64x48) };
        OLedFormSizes(F("size"), optionValues, P036_RESOLUTION, true);
      }

      OLedFormRotation(F("rotate"), P036_ROTATE);

      {
        p036_resolution tOLEDIndex = static_cast<p036_resolution>(P036_RESOLUTION);
        addFormNumericBox(F("Lines per Frame"),
                          F("nlines"),
                          P036_NLINES,
                          1,
                          P036_data_struct::getDisplaySizeSettings(tOLEDIndex).MaxLines);
      }
# if P036_ENABLE_LEFT_ALIGN
      {
        addFormCheckBox(F("Reduce no. of lines to fit font"), F("ReduceLineNo"), bitRead(P036_FLAGS_1, P036_FLAG_REDUCE_LINE_NO));
# ifndef P036_LIMIT_BUILD_SIZE
        addFormNote(F("When checked, 'Lines per Frame' will be automatically reduced to fit the individual line settings."));
# endif
      }
# endif
      {
        const __FlashStringHelper *options[] = {
          F("Very Slow"),
          F("Slow"),
          F("Fast"),
          F("Very Fast"),
          F("Instant"),
# if P036_ENABLE_TICKER
          F("Ticker"),
# endif
        };
        const int optionValues[] =
        { static_cast<int>(ePageScrollSpeed::ePSS_VerySlow),
          static_cast<int>(ePageScrollSpeed::ePSS_Slow),
          static_cast<int>(ePageScrollSpeed::ePSS_Fast),
          static_cast<int>(ePageScrollSpeed::ePSS_VeryFast),
          static_cast<int>(ePageScrollSpeed::ePSS_Instant),
# if P036_ENABLE_TICKER
          static_cast<int>(ePageScrollSpeed::ePSS_Ticker),
# endif
        };
        constexpr int optionCnt = NR_ELEMENTS(optionValues);
        addFormSelector(F("Scroll"), F("scroll"), optionCnt, options, optionValues, P036_SCROLL);
      }


      addFormPinSelect(PinSelectPurpose::Generic_input, formatGpioName_input_optional(F("Display button")), F("taskdevicepin3"), CONFIG_PIN3);

      {
        const __FlashStringHelper *options[] = { F("Input"), F("Input pullup") };
        const int optionValues[] =
        { static_cast<int>(eP036pinmode::ePPM_Input),
          static_cast<int>(eP036pinmode::ePPM_InputPullUp) };
        addFormSelector(F("Pin mode"), F("pinmode"), 2, options, optionValues,
                        bitRead(P036_FLAGS_0, P036_FLAG_INPUT_PULLUP));
      }

      addFormCheckBox(F("Inversed Logic"), F("pin3invers"), bitRead(P036_FLAGS_0, P036_FLAG_PIN3_INVERSE));

      addFormCheckBox(F("Step through frames with Display button"), F("StepPages"), bitRead(P036_FLAGS_0, P036_FLAG_STEP_PAGES_BUTTON));

      addFormNumericBox(F("Display Timeout"), F("timer"), P036_TIMER, 0, 65535);

      OLedFormContrast(F("contrast"), P036_CONTRAST);

      addFormCheckBox(F("Disable all scrolling while WiFi is disconnected"), F("ScrollWithoutWifi"),
                      !bitRead(P036_FLAGS_0, P036_FLAG_SCROLL_WITHOUTWIFI));
# ifndef P036_LIMIT_BUILD_SIZE
      addFormNote(F("When checked, all scrollings (pages and lines) are disabled as long as WiFi is not connected."));
# endif

# if P036_SEND_EVENTS
      {
        uint8_t choice = 0;
        bitWrite(choice, 0, bitRead(P036_FLAGS_0, P036_FLAG_SEND_EVENTS));
        bitWrite(choice, 1, bitRead(P036_FLAGS_0, P036_FLAG_EVENTS_FRAME_LINE));
        const __FlashStringHelper *options[] = {
          F("None"),
          F("Display &amp; Contrast"),
          F("Display, Contrast, Frame, Line &amp; Linecount")
        };
        const int optionValues[] = { 0, 1, 3 };
        addFormSelector(F("Generate events"), F("generateEvents"), 3, options, optionValues, choice);

# ifndef P036_LIMIT_BUILD_SIZE
        addFormNote(F("Events: &lt;taskname&gt; #display=1/0 (on/off), #contrast=0/1/2 (low/med/high),"));
        addFormNote(F("and #frame=&lt;framenr&gt;, #line=&lt;linenr&gt; and #linecount=&lt;lines&gt;"));
# endif
      }
# endif

      addFormSubHeader(F("Content"));

      addFormCheckBox(F("Hide header"), F("HideHeader"), bitRead(P036_FLAGS_0, P036_FLAG_HIDE_HEADER));
# if P036_ENABLE_HIDE_FOOTER

      if (static_cast<p036_resolution>(P036_RESOLUTION) == p036_resolution::pix128x64) {

        addFormCheckBox(F("Hide indicator"), F("HideFooter"), bitRead(P036_FLAGS_0, P036_FLAG_HIDE_FOOTER));
      }
# endif

      {
        const __FlashStringHelper *options9[] =
        { F("SSID"), F("SysName"), F("IP"), F("MAC"), F("RSSI"),
          F("BSSID"), F("WiFi channel"), F("Unit"), F("SysLoad"), F("SysHeap"),
          F("SysStack"), F("Date"), F("Time"), F("PageNumbers"),
          # if P036_USERDEF_HEADERS
          F("User defined 1"),
          F("User defined 2"),
          # endif
        };
        const int optionValues9[] =
        { static_cast<int>(eHeaderContent::eSSID),
          static_cast<int>(eHeaderContent::eSysName),
          static_cast<int>(eHeaderContent::eIP),
          static_cast<int>(eHeaderContent::eMAC),
          static_cast<int>(eHeaderContent::eRSSI),
          static_cast<int>(eHeaderContent::eBSSID),
          static_cast<int>(eHeaderContent::eWiFiCh),
          static_cast<int>(eHeaderContent::eUnit),
          static_cast<int>(eHeaderContent::eSysLoad),
          static_cast<int>(eHeaderContent::eSysHeap),
          static_cast<int>(eHeaderContent::eSysStack),
          static_cast<int>(eHeaderContent::eDate),
          static_cast<int>(eHeaderContent::eTime),
          static_cast<int>(eHeaderContent::ePageNo),
          # if P036_USERDEF_HEADERS
          static_cast<int>(eHeaderContent::eUserDef1),
          static_cast<int>(eHeaderContent::eUserDef2),
          # endif
        };
        constexpr int nrOptions9 = NR_ELEMENTS(options9);
        addFormSelector(F("Header"), F("header"), nrOptions9, options9, optionValues9,
                        get8BitFromUL(P036_FLAGS_0, P036_FLAG_HEADER));
        addFormSelector(F("Header (alternate)"), F("headerAlternate"), nrOptions9, options9, optionValues9,
                        get8BitFromUL(P036_FLAGS_0, P036_FLAG_HEADER_ALTERNATIVE));
      }

      addFormCheckBox(F("Scroll long lines"), F("ScrollLines"), bitRead(P036_FLAGS_0, P036_FLAG_SCROLL_LINES));

      addFormCheckBox(F("Wake display on receiving text"), F("NoDisplay"), !bitRead(P036_FLAGS_0, P036_FLAG_NODISPLAY_ONRECEIVE));

# ifndef P036_LIMIT_BUILD_SIZE
      addFormNote(F("When checked, the display wakes up at receiving remote updates."));
# endif

      addFormSubHeader(F("Lines"));
# if P036_ENABLE_LEFT_ALIGN
      {
        const __FlashStringHelper *optionsAlignment[] =
        { F("left"), F("center"), F("right") };
        const int optionValuesAlignment[] =
        { static_cast<int>(eAlignment::eLeft),
          static_cast<int>(eAlignment::eCenter),
          static_cast<int>(eAlignment::eRight)
        };
        addFormSelector(F("Align content (global)"), F("LeftAlign"), 3, optionsAlignment, optionValuesAlignment,
                        get2BitFromUL(P036_FLAGS_1, P036_FLAG_LEFT_ALIGNED));
      }
# endif

      {



# ifdef P036_CHECK_HEAP
        P036_CheckHeap(F("_LOAD: Before (*P036_lines = new)"));
# endif

        {
          P036_LineContent P036_lines;
# ifdef P036_CHECK_HEAP
          P036_CheckHeap(F("_LOAD: Before loadDisplayLines()"));
# endif
          P036_lines.loadDisplayLines(event->TaskIndex, get4BitFromUL(P036_FLAGS_0, P036_FLAG_SETTINGS_VERSION));

# ifdef P036_CHECK_HEAP
          P036_CheckHeap(F("_LOAD: After loadDisplayLines()"));
# endif

          const __FlashStringHelper *optionsFont[] =
          { F("Use smallest"), F("Reduce to smaller"), F("None"), F("Enlarge to bigger"), F("Use biggest") };
          const int optionValuesFont[] =
          { static_cast<int>(eModifyFont::eMinimize),
            static_cast<int>(eModifyFont::eReduce),
            static_cast<int>(eModifyFont::eNone),
            static_cast<int>(eModifyFont::eEnlarge),
            static_cast<int>(eModifyFont::eMaximize)
          };

          const __FlashStringHelper *optionsAlignment[] =
          { F("Use global"), F("left"), F("center"), F("right") };
          const int optionValuesAlignment[] =
          { static_cast<int>(eAlignment::eGlobal),
            static_cast<int>(eAlignment::eLeft),
            static_cast<int>(eAlignment::eCenter),
            static_cast<int>(eAlignment::eRight)
          };

          addRowLabel(F("Line"));
          html_table(F("sub"));
          html_table_header(F("&nbsp;#&nbsp;"));
          html_table_header(F("Content"), 500);
          html_table_header(F("Modify font"));
          html_table_header(F("Alignment"));

          for (int varNr = 0; varNr < P36_Nlines; varNr++)
          {
            html_TR_TD();
            addHtml(F("&nbsp;"));
            addHtmlInt(varNr + 1);
            html_TD(F("padding-right: 8px"));
            addTextBox(getPluginCustomArgName(varNr),
                       P036_lines.DisplayLinesV1[varNr].Content,
                       P36_NcharsV1 - 1,
                       false,
                       false,
                       EMPTY_STRING,
                       F("xwide")
                       );
            html_TD();
            const uint8_t FontChoice = get3BitFromUL(P036_lines.DisplayLinesV1[varNr].ModifyLayout, P036_FLAG_ModifyLayout_Font);
            addSelector(getPluginCustomArgName(varNr + 100),
                        5,
                        optionsFont,
                        optionValuesFont,
                        nullptr,
                        FontChoice,
                        false,
                        true,
                        F("")
                        );
            html_TD();
            const uint8_t AlignmentChoice = get3BitFromUL(P036_lines.DisplayLinesV1[varNr].ModifyLayout,
                                                          P036_FLAG_ModifyLayout_Alignment);
            addSelector(getPluginCustomArgName(varNr + 200),
                        4,
                        optionsAlignment,
                        optionValuesAlignment,
                        nullptr,
                        AlignmentChoice,
                        false,
                        true,
                        F("")
                        );
          }
          html_end_table();
        }
      }

# ifdef P036_CHECK_HEAP
      P036_CheckHeap(F("_LOAD: Before exit"));
# endif
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
# ifdef PLUGIN_036_DEBUG
      addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_WEBFORM_SAVE ..."));
# endif
# ifdef P036_CHECK_HEAP
      P036_CheckHeap(F("_SAVE: Entering"));
# endif




      P036_ADR = getFormItemInt(F("i2c_addr"));
      P036_ROTATE = getFormItemInt(F("rotate"));
      P036_NLINES = getFormItemInt(F("nlines"));
      P036_SCROLL = getFormItemInt(F("scroll"));
      P036_TIMER = getFormItemInt(F("timer"));
      P036_CONTROLLER = getFormItemInt(F("controller"));
      P036_CONTRAST = getFormItemInt(F("contrast"));
      P036_RESOLUTION = getFormItemInt(F("size"));

      uint32_t lSettings = 0;
      set8BitToUL(lSettings, P036_FLAG_HEADER, uint8_t(getFormItemInt(F("header")) & 0xff));
      set8BitToUL(lSettings, P036_FLAG_HEADER_ALTERNATIVE, uint8_t(getFormItemInt(F("headerAlternate")) & 0xff));
      bitWrite(lSettings, P036_FLAG_PIN3_INVERSE, isFormItemChecked(F("pin3invers")));
      bitWrite(lSettings, P036_FLAG_SCROLL_LINES, isFormItemChecked(F("ScrollLines")));
      bitWrite(lSettings, P036_FLAG_NODISPLAY_ONRECEIVE, !isFormItemChecked(F("NoDisplay")));
      bitWrite(lSettings, P036_FLAG_STEP_PAGES_BUTTON, isFormItemChecked(F("StepPages")));

      set4BitToUL(lSettings, P036_FLAG_SETTINGS_VERSION, 0x01);



      bitWrite(lSettings, P036_FLAG_SCROLL_WITHOUTWIFI, !isFormItemChecked(F("ScrollWithoutWifi")));
      bitWrite(lSettings, P036_FLAG_HIDE_HEADER, isFormItemChecked(F("HideHeader")));
# if P036_ENABLE_HIDE_FOOTER
      bitWrite(lSettings, P036_FLAG_HIDE_FOOTER, isFormItemChecked(F("HideFooter")));
# endif

      bitWrite(lSettings, P036_FLAG_INPUT_PULLUP, getFormItemInt(F("pinmode")));
      # if P036_SEND_EVENTS
      const uint8_t generateEvents = getFormItemInt(F("generateEvents")) & 0xFF;
      bitWrite(lSettings, P036_FLAG_SEND_EVENTS, bitRead(generateEvents, 0));
      bitWrite(lSettings, P036_FLAG_EVENTS_FRAME_LINE, bitRead(generateEvents, 1));
      # endif

      P036_FLAGS_0 = lSettings;

# if P036_ENABLE_LEFT_ALIGN
      lSettings = 0;
      set2BitToUL(lSettings, P036_FLAG_LEFT_ALIGNED, uint8_t(getFormItemInt(F("LeftAlign")) & 0xff));
      bitWrite(lSettings, P036_FLAG_REDUCE_LINE_NO, isFormItemChecked(F("ReduceLineNo")));
      P036_FLAGS_1 = lSettings;
# endif

      {



# ifdef P036_CHECK_HEAP
        P036_CheckHeap(F("_SAVE: Before (*P036_lines = new)"));
# endif

        {
          P036_LineContent P036_lines;
          uint32_t lModifyLayout;

# ifdef P036_CHECK_HEAP
          P036_CheckHeap(F("_SAVE: After (*P036_lines = new)"));
# endif

          for (uint8_t varNr = 0; varNr < P36_Nlines; varNr++)
          {
            P036_lines.DisplayLinesV1[varNr].Content = webArg(getPluginCustomArgName(varNr));
            P036_lines.DisplayLinesV1[varNr].FontType = 0xff;
            lModifyLayout = 0xC0;

            set3BitToUL(lModifyLayout, P036_FLAG_ModifyLayout_Font, uint8_t(getFormItemIntCustomArgName(varNr + 100) & 0xff));


            set3BitToUL(lModifyLayout, P036_FLAG_ModifyLayout_Alignment, uint8_t(getFormItemIntCustomArgName(varNr + 200) & 0xff));
            P036_lines.DisplayLinesV1[varNr].ModifyLayout = uint8_t(lModifyLayout & 0xff);
            P036_lines.DisplayLinesV1[varNr].FontSpace = 0xff;
            P036_lines.DisplayLinesV1[varNr].reserved = 0xff;
          }

          const String error = P036_lines.saveDisplayLines(event->TaskIndex);

          if (!error.isEmpty()) {
            addHtmlError(error);
          }
        }
      }

# ifdef PLUGIN_036_DEBUG
      addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_WEBFORM_SAVE Done"));
# endif
# ifdef P036_CHECK_HEAP
      P036_CheckHeap(F("_SAVE: Before exit"));
# endif
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
# ifdef P036_CHECK_HEAP
      P036_CheckHeap(F("_INIT: Entering"));
# endif
      {
        # ifdef USE_SECOND_HEAP
        HeapSelectIram ephemeral;
        # endif

        initPluginTaskData(event->TaskIndex, new (std::nothrow) P036_data_struct());
      }
# ifdef P036_CHECK_HEAP
      P036_CheckHeap(F("_INIT: Before (*P036_data = static_cast<P036_data_struct *>)"));
# endif
      P036_data_struct *P036_data =
        static_cast<P036_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P036_data) {
        addLog(LOG_LEVEL_ERROR, F("P036_PLUGIN_INIT: P036_data are zero!"));
        return success;
      }



      P036_data->bHideHeader = bitRead(P036_FLAGS_0, P036_FLAG_HIDE_HEADER);
      # if P036_ENABLE_HIDE_FOOTER
      P036_data->bHideFooter |= bitRead(P036_FLAGS_0, P036_FLAG_HIDE_FOOTER);
      # endif
      # if P036_ENABLE_LEFT_ALIGN
      P036_data->setTextAlignment(static_cast<eAlignment>(get2BitFromUL(P036_FLAGS_1, P036_FLAG_LEFT_ALIGNED)));
      P036_data->bReduceLinesPerFrame = bitRead(P036_FLAGS_1, P036_FLAG_REDUCE_LINE_NO);
      # endif


# ifdef P036_CHECK_HEAP
      P036_CheckHeap(F("_INIT: Before P036_data->init()"));
# endif

      if (!(P036_data->init(event->TaskIndex,
                            get4BitFromUL(P036_FLAGS_0, P036_FLAG_SETTINGS_VERSION),
                            P036_CONTROLLER,
                            P036_ADR,
                            Settings.Pin_i2c_sda,
                            Settings.Pin_i2c_scl,
                            static_cast<p036_resolution>(P036_RESOLUTION),
                            (P036_ROTATE == 2),
                            P036_CONTRAST,
                            P036_TIMER,
                            static_cast<ePageScrollSpeed>(P036_SCROLL),
                            P036_NLINES
                            ))) {
        clearPluginTaskData(event->TaskIndex);
        P036_data = nullptr;


        break;
      }
# ifdef P036_CHECK_HEAP
      P036_CheckHeap(F("_INIT: After P036_data->init()"));
# endif


      P036_SetDisplayOn(1);
      # if P036_SEND_EVENTS

      if (bitRead(P036_FLAGS_0, P036_FLAG_SEND_EVENTS)) {
        P036_data_struct::P036_SendEvent(event, P036_EVENT_DISPLAY, 1);

        if (bitRead(P036_FLAGS_0, P036_FLAG_EVENTS_FRAME_LINE)) {
          # if P036_ENABLE_LINECOUNT
          P036_data_struct::P036_SendEvent(event, P036_EVENT_LINECNT, P036_NLINES);
          # endif
          P036_data_struct::P036_SendEvent(event, P036_EVENT_FRAME, P036_data->currentFrameToDisplay + 1);
        }
      }
      # endif

      if (validGpio(CONFIG_PIN3)) {
        if (bitRead(P036_FLAGS_0, P036_FLAG_INPUT_PULLUP)) {
          pinMode(CONFIG_PIN3, INPUT_PULLUP);
        }
        else {
          pinMode(CONFIG_PIN3, INPUT);
        }

        P036_data->DebounceCounter = 0;
        P036_data->RepeatCounter = 0;
        P036_data->ButtonState = false;
      }

# ifdef PLUGIN_036_DEBUG

      if (P036_data->isInitialized()) {
        addLog(LOG_LEVEL_INFO, F("P036_init Done"));
      } else {
        addLog(LOG_LEVEL_INFO, F("P036_init Not initialized"));
      }
# endif

# ifdef P036_CHECK_HEAP
      P036_CheckHeap(F("_INIT: Before exit"));
# endif
      success = P036_data->isInitialized();
      break;
    }

    case PLUGIN_EXIT:
    {
# ifdef PLUGIN_036_DEBUG
      addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_EXIT ..."));
# endif
# ifdef P036_CHECK_HEAP
      P036_CheckHeap(F("_EXIT: Before exit"));
# endif
      success = true;
      break;
    }


    case PLUGIN_FIFTY_PER_SECOND:
    {
      P036_data_struct *P036_data =
        static_cast<P036_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P036_data) {
        return success;
      }

      if (validGpio(CONFIG_PIN3)) {
        P036_data->registerButtonState(digitalRead(CONFIG_PIN3), bitRead(P036_FLAGS_0, P036_FLAG_PIN3_INVERSE));
      }
      success = true;
      break;
    }


    case PLUGIN_TEN_PER_SECOND:
    {
      P036_data_struct *P036_data =
        static_cast<P036_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P036_data) {
        return success;
      }

      if (P036_DisplayIsOn && (P036_data->disableFrameChangeCnt)) {


        P036_data->disableFrameChangeCnt--;
      }

      P036_data->bAlternativHeader = (++P036_data->HeaderCount > (Settings.TaskDeviceTimer[event->TaskIndex] * 5));


      if ((validGpio(CONFIG_PIN3)) && P036_data->ButtonState) {
        if (bitRead(P036_FLAGS_0, P036_FLAG_STEP_PAGES_BUTTON) &&



            P036_DisplayIsOn) {
          if (P036_data->ScrollingPages.Scrolling == 0) {


            P036_data->P036_JumpToPage(event, 0xFF);


          }
        } else {
          P036_data->display->displayOn();

          P036_SetDisplayOn(1);
          P036_data->P036_JumpToPage(event, 0);
          # if P036_SEND_EVENTS

          if (bitRead(P036_FLAGS_0, P036_FLAG_SEND_EVENTS)) {
            P036_data_struct::P036_SendEvent(event, P036_EVENT_DISPLAY, 1);
          }
          # endif
        }
        P036_data->markButtonStateProcessed();



        pinMode(CONFIG_PIN3, bitRead(P036_FLAGS_0, P036_FLAG_INPUT_PULLUP) ? INPUT_PULLUP : INPUT);
      }

      if (P036_data->bLineScrollEnabled) {
        # if P036_SEND_EVENTS
        const uint8_t currentFrame = P036_data->currentFrameToDisplay;
        # endif

        if (P036_DisplayIsOn && (P036_data->ScrollingPages.Scrolling == 0)) {

          P036_data->display_scrolling_lines();
        }
        # if P036_SEND_EVENTS

        if (bitRead(P036_FLAGS_0, P036_FLAG_SEND_EVENTS) &&
            bitRead(P036_FLAGS_0, P036_FLAG_EVENTS_FRAME_LINE) &&
            (currentFrame != P036_data->currentFrameToDisplay)) {
          P036_data_struct::P036_SendEvent(event, P036_EVENT_FRAME, P036_data->currentFrameToDisplay + 1);
        }
        # endif
      }
      success = true;
      break;
    }


    case PLUGIN_ONCE_A_SECOND:
    {
      P036_data_struct *P036_data =
        static_cast<P036_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P036_data) {
# ifdef PLUGIN_036_DEBUG
        addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_ONCE_A_SECOND NoData"));
# endif
        return success;
      }

      else if (!P036_data->isInitialized()) {
# ifdef PLUGIN_036_DEBUG
        addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_ONCE_A_SECOND Not initialized"));
# endif
        return success;
      }

      if (P036_data->displayTimer > 0) {
        P036_data->displayTimer--;

        if (P036_data->displayTimer == 0) {
          P036_data->display->displayOff();

          P036_SetDisplayOn(0);
          # if P036_SEND_EVENTS

          if (bitRead(P036_FLAGS_0, P036_FLAG_SEND_EVENTS)) {
            P036_data_struct::P036_SendEvent(event, P036_EVENT_DISPLAY, 0);
          }
          # endif
        }
      }

      if (P036_DisplayIsOn) {


        if (!P036_data->bRunning && NetworkConnected() && (P036_data->ScrollingPages.Scrolling == 0)) {

          P036_data->P036_DisplayPage(event);
        }
        else {
          P036_data->HeaderContent = static_cast<eHeaderContent>(get8BitFromUL(P036_FLAGS_0, P036_FLAG_HEADER));
          P036_data->HeaderContentAlternative = static_cast<eHeaderContent>(get8BitFromUL(P036_FLAGS_0, P036_FLAG_HEADER_ALTERNATIVE));


          P036_data->display_header();

          if (P036_data->isInitialized() && P036_data->display_wifibars()) {

            P036_data->update_display();
          }
        }
      }

      success = true;
      break;
    }

    case PLUGIN_TASKTIMER_IN:
    {
      P036_data_struct *P036_data =
        static_cast<P036_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P036_data) {
# ifdef PLUGIN_036_DEBUG
        addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_TIMER_IN NoData"));
# endif
        return success;
      }

      else if (!P036_data->isInitialized()) {
# ifdef PLUGIN_036_DEBUG
        addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_TIMER_IN Not initialized"));
# endif
        return success;
      }

      # if P036_SEND_EVENTS
      uint8_t currentFrame = P036_data->currentFrameToDisplay;
      # endif

      if (P036_DisplayIsOn && P036_data->display_scroll_timer()) {

        Scheduler.setPluginTaskTimer(P36_PageScrollTimer, event->TaskIndex, event->Par1);
      }
      # if P036_SEND_EVENTS

      if (bitRead(P036_FLAGS_0, P036_FLAG_SEND_EVENTS) &&
          bitRead(P036_FLAGS_0, P036_FLAG_EVENTS_FRAME_LINE) &&
          (currentFrame != P036_data->currentFrameToDisplay)) {
        P036_data_struct::P036_SendEvent(event, P036_EVENT_FRAME, P036_data->currentFrameToDisplay + 1);
      }
      # endif
      return success;
    }

    case PLUGIN_READ:
    {
      P036_data_struct *P036_data =
        static_cast<P036_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P036_data) {
# ifdef PLUGIN_036_DEBUG
        addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_READ NoData"));
# endif
        return success;
      }

      else if (!P036_data->isInitialized()) {
# ifdef PLUGIN_036_DEBUG
        addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_READ Not initialized"));
# endif
        return success;
      }

      if (P036_data->disableFrameChangeCnt) {

# ifdef PLUGIN_036_DEBUG
        addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_READ disableFrameChangeCnt"));
# endif
        return success;
      }

      if (P036_data->ScrollingPages.Scrolling == 0) {

        P036_data->P036_DisplayPage(event);
      # ifdef PLUGIN_036_DEBUG
      } else {
        addLog(LOG_LEVEL_INFO, F("P036_PLUGIN_READ Page scrolling running"));
      # endif
      }

      success = true;
      break;
    }

    # if P036_FEATURE_DISPLAY_PREVIEW
    case PLUGIN_WEBFORM_SHOW_VALUES:
    {
      P036_data_struct *P036_data =
        static_cast<P036_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P036_data) {
        success = P036_data->web_show_values();
      }
      break;
    }
    # endif

    case PLUGIN_WRITE:
    {
      P036_data_struct *P036_data =
        static_cast<P036_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P036_data) {
        if (P036_data->isInitialized()) {
          success = P036_data->plugin_write(event, string);
        }
      }

      break;
    }
  }
  return success;
}


# ifdef P036_CHECK_HEAP
void P036_CheckHeap(String dbgtxt) {
  String log;

  log.reserve(80);
  log += dbgtxt;
  log += F(" FreeHeap:");
  log += ESP.getFreeHeap();
  log += F(" FreeStack:");
  log += getCurrentFreeStack();
  addLog(LOG_LEVEL_INFO, log);
}

# endif

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P037_MQTTImport.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P037
# 33 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P037_MQTTImport.ino"
# include "src/PluginStructs/P037_data_struct.h"

#define PLUGIN_037 
#define PLUGIN_ID_037 37
#define PLUGIN_NAME_037 "Generic - MQTT Import"

#define PLUGIN_VALUENAME1_037 "Value1"
#define PLUGIN_VALUENAME2_037 "Value2"
#define PLUGIN_VALUENAME3_037 "Value3"
#define PLUGIN_VALUENAME4_037 "Value4"


#define P037_PARSE_JSON PCONFIG(1)
#define P037_APPLY_MAPPINGS PCONFIG(2)
#define P037_APPLY_FILTERS PCONFIG(3)
#define P037_SEND_EVENTS PCONFIG(4)
#define P037_DEDUPLICATE_EVENTS PCONFIG(5)
#define P037_QUEUEDEPTH_EVENTS PCONFIG(6)
#define P037_REPLACE_BY_COMMA PCONFIG(7)

#define P037_MAX_QUEUEDEPTH 150


bool MQTT_unsubscribe_037(struct EventStruct *event);
bool MQTTSubscribe_037(struct EventStruct *event);

# if P037_MAPPING_SUPPORT || P037_JSON_SUPPORT
String P037_getMQTTLastTopicPart(const String& topic) {
  const int16_t lastSlash = topic.lastIndexOf('/');

  if (lastSlash >= static_cast<int16_t>(topic.length() - 1)) {
    return F("");
  }
  String result = topic.substring(lastSlash + 1);

  result.trim();
  return result;
}

# endif

bool P037_addEventToQueue(struct EventStruct *event, String& newEvent) {
  if (newEvent.isEmpty()) { return false; }
  bool result = true;

  if ((P037_QUEUEDEPTH_EVENTS == 0) ||
      (eventQueue.size() <= static_cast<std::size_t>(P037_QUEUEDEPTH_EVENTS))) {
    # if P037_REPLACE_BY_COMMA_SUPPORT

    if (P037_REPLACE_BY_COMMA != 0x0) {
      const String character = String(static_cast<char>(P037_REPLACE_BY_COMMA));
      newEvent.replace(character, F(","));
    }
    # endif
    eventQueue.add(newEvent, P037_DEDUPLICATE_EVENTS);
  } else {
    result = false;
  }
  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
    String log = F("MQTT: Event added: ");

    if (result) {
      log += F("yes");
    } else {
      log += F("NO!");
    }
    addLog(LOG_LEVEL_DEBUG, log);
  }
  # endif
  return result;
}

boolean Plugin_037(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_037;
      Device[deviceCount].Type = DEVICE_TYPE_DUMMY;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].DecimalsOnly = true;
      Device[deviceCount].ValueCount = VARS_PER_TASK;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_037);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_037));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_037));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_037));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_037));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P037_SEND_EVENTS = 1;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      # if P037_JSON_SUPPORT
      addFormSelector_YesNo(F("Parse JSON messages"), F("pjson"), P037_PARSE_JSON, true);
      # endif
      # if P037_FILTER_SUPPORT
      addFormSelector_YesNo(F("Apply filters"), F("pfilters"), P037_APPLY_FILTERS, true);
      # endif
      # if P037_MAPPING_SUPPORT
      addFormSelector_YesNo(F("Apply mappings"), F("pmappings"), P037_APPLY_MAPPINGS, true);
      # endif
      # if P037_MAPPING_SUPPORT || P037_JSON_SUPPORT || P037_FILTER_SUPPORT
      # if !defined(P037_LIMIT_BUILD_SIZE)
      addFormNote(F("Changing a Yes/No option will reload the page. Changing to No will clear corresponding settings!"));
      # endif
      # endif

      addFormSubHeader(F("Options"));

      addFormCheckBox(F("Generate events for accepted topics"),
                      F("p037_send_events"), P037_SEND_EVENTS);
      # if !defined(P037_LIMIT_BUILD_SIZE)
      addFormNote(F("Event: &lt;TaskName&gt;#&lt;topic&gt;=&lt;payload&gt;"));
      # if P037_JSON_SUPPORT
      addFormNote(F("Events when JSON enabled and JSON payload: &lt;Topic&gt;#&lt;json-attribute&gt;=&lt;value&gt;"));
      # endif
      # endif

      {
        addFormCheckBox(F("Deduplicate events"), F("pdedupe"), P037_DEDUPLICATE_EVENTS == 1);
        # if !defined(P037_LIMIT_BUILD_SIZE)
        addFormNote(F("When enabled will not (re-)generate events that are already in the queue."));
        # endif
      }

      {
        # if !defined(P037_LIMIT_BUILD_SIZE) && FEATURE_TOOLTIPS
        String toolTip = F("0..");
        toolTip += P037_MAX_QUEUEDEPTH;
        toolTip += F(" entries");
        addFormNumericBox(F("Max. # entries in event queue"), F("pquedepth"), P037_QUEUEDEPTH_EVENTS, 0, P037_MAX_QUEUEDEPTH, toolTip);
        # else
        addFormNumericBox(F("Max. # entries in event queue"), F("pquedepth"), P037_QUEUEDEPTH_EVENTS, 0, P037_MAX_QUEUEDEPTH);
        # endif
        addUnit(F("0 = no check"));
        # if !defined(P037_LIMIT_BUILD_SIZE)
        addFormNote(F("New events will be discarded if the event queue has more entries queued."));
        # endif
      }
      # if P037_REPLACE_BY_COMMA_SUPPORT
      {
        addFormSeparatorCharInput(F("To replace by comma in event"), F("preplch"),
                                  P037_REPLACE_BY_COMMA, F(P037_REPLACE_CHAR_SET), F(""));
      }
      # endif

      {
        P037_data_struct *P037_data = new (std::nothrow) P037_data_struct(event->TaskIndex);

        if (nullptr == P037_data) {
          return success;
        }
        success = P037_data->loadSettings() && P037_data->webform_load(
          # if P037_MAPPING_SUPPORT
          P037_APPLY_MAPPINGS
          # endif
          # if P037_MAPPING_SUPPORT && P037_FILTER_SUPPORT
          ,
          # endif
          # if P037_FILTER_SUPPORT
          P037_APPLY_FILTERS
          # endif
          # if (P037_MAPPING_SUPPORT || P037_FILTER_SUPPORT) && P037_JSON_SUPPORT
          ,
          # endif
          # if P037_JSON_SUPPORT
          P037_PARSE_JSON
          # endif
          );
        delete P037_data;
      }
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P037_data_struct *P037_data = new (std::nothrow) P037_data_struct(event->TaskIndex);

      if (nullptr == P037_data) {
        return success;
      }
      P037_data->loadSettings();

      # if P037_JSON_SUPPORT
      P037_PARSE_JSON = getFormItemInt(F("pjson"));
      # endif
      # if P037_MAPPING_SUPPORT
      P037_APPLY_MAPPINGS = getFormItemInt(F("pmappings"));
      # endif
      # if P037_FILTER_SUPPORT
      P037_APPLY_FILTERS = getFormItemInt(F("pfilters"));
      # endif
      P037_SEND_EVENTS = isFormItemChecked(F("p037_send_events")) ? 1 : 0;
      P037_DEDUPLICATE_EVENTS = isFormItemChecked(F("pdedupe")) ? 1 : 0;
      P037_QUEUEDEPTH_EVENTS = getFormItemInt(F("pquedepth"));

      # if P037_REPLACE_BY_COMMA_SUPPORT
      P037_REPLACE_BY_COMMA = getFormItemInt(F("preplch"));
      # endif

      success = P037_data->webform_save(
        # if P037_FILTER_SUPPORT
        P037_APPLY_FILTERS
        # endif
        # if P037_FILTER_SUPPORT && P037_JSON_SUPPORT
        ,
        # endif
        # if P037_JSON_SUPPORT
        P037_PARSE_JSON
        # endif
        );
      delete P037_data;

      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P037_data_struct(event->TaskIndex));

      P037_data_struct *P037_data = static_cast<P037_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P037_data) && P037_data->loadSettings()) {


        if (MQTTclient_connected) {

          MQTTSubscribe_037(event);
        }
        success = true;
      }
      break;
    }

    case PLUGIN_EXIT:
    {
      MQTT_unsubscribe_037(event);
      break;
    }

    case PLUGIN_READ:
    {


      success = false;
      break;
    }

    case PLUGIN_MQTT_CONNECTION_STATE:
    {
      const bool currentConnectedState = event->Par1 == 1;

      if (P037_MQTTImport_connected != currentConnectedState) {
        P037_MQTTImport_connected = currentConnectedState;

        if (Settings.UseRules) {
          eventQueue.add(currentConnectedState ? F("MQTTimport#Connected") : F("MQTTimport#Disconnected"));
        }
      }

      if (currentConnectedState) {
        success = MQTTSubscribe_037(event);
      }
      break;
    }

    case PLUGIN_MQTT_IMPORT:
    {


      String Payload = event->String2;

      # ifdef PLUGIN_037_DEBUG

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String info = F("P037 : topic: ");
        info += event->String1;
        info += F(" value: ");
        info += Payload;
        addLog(LOG_LEVEL_INFO, info);
      }
      # endif

      P037_data_struct *P037_data = static_cast<P037_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P037_data) {
        return success;
      }

      String unparsedPayload;

      bool checkJson = false;

      String subscriptionTopicParsed;
      # if P037_MAPPING_SUPPORT || P037_FILTER_SUPPORT || P037_JSON_SUPPORT
      bool processData = false;


      bool matchedTopic = false;
      subscriptionTopicParsed.reserve(80);

      for (uint8_t x = 0; x < VARS_PER_TASK; x++)
      {
        if (P037_data->mqttTopics[x].length() == 0) {
          continue;
        }


        subscriptionTopicParsed = P037_data->getFullMQTTTopic(x);
        parseSystemVariables(subscriptionTopicParsed, false);

        if (MQTTCheckSubscription_037(event->String1, subscriptionTopicParsed)) {
          matchedTopic = true;
          processData = true;
        }
      }
      # else
      bool processData = true;
      # endif
      # if P037_JSON_SUPPORT

      if (matchedTopic &&
          P037_PARSE_JSON &&
          Payload.startsWith(F("{"))) {
        # ifdef PLUGIN_037_DEBUG
        addLog(LOG_LEVEL_INFO, F("IMPT : MQTT JSON data detected."));
        # endif
        checkJson = true;
      }
      # endif

      if (!checkJson) {
        unparsedPayload = event->String2;
      }

      bool continueProcessing = false;
      String key;

      # if P037_MAPPING_SUPPORT

      if (matchedTopic && !checkJson && P037_APPLY_MAPPINGS) {
        key = P037_getMQTTLastTopicPart(event->String1);
        Payload = P037_data->mapValue(Payload, key);
      }
      # endif

      # if P037_JSON_SUPPORT

      if (checkJson) {
        continueProcessing = P037_data->parseJSONMessage(event->String2);
      }
      # endif

      # if P037_FILTER_SUPPORT
      # ifdef P037_FILTER_PER_TOPIC

      for (uint8_t x = 0; x < VARS_PER_TASK && matchedTopic; x++) {
        if (P037_data->mqttTopics[x].length() == 0) {
          continue;
        }
      # else
      int8_t x = -1;

      if (matchedTopic) {
      # endif


        if (!checkJson && P037_data->hasFilters()) {
          key = P037_getMQTTLastTopicPart(event->String1);
          # if P037_MAPPING_SUPPORT

          if (P037_APPLY_MAPPINGS) {
            Payload = P037_data->mapValue(Payload, key);
          }
          # endif
          processData = P037_data->checkFilters(key, Payload, x + 1);
        }
        # if P037_JSON_SUPPORT

        # ifndef P037_FILTER_PER_TOPIC


        if (checkJson && P037_data->hasFilters()) {
          do {
            key = P037_data->iter->key().c_str();
            Payload = P037_data->iter->value().as<String>();
            # if P037_MAPPING_SUPPORT

            if (P037_APPLY_MAPPINGS) {
              Payload = P037_data->mapValue(Payload, key);
            }
            # endif
            processData = P037_data->checkFilters(key, Payload, x + 1);
            ++P037_data->iter;
          } while (processData && P037_data->iter != P037_data->doc.end());
        }
        # endif
        # endif
      }
      # ifndef BUILD_NO_DEBUG

      if (matchedTopic && P037_data->hasFilters() &&
          loglevelActiveFor(LOG_LEVEL_DEBUG)) {
        String log = F("IMPT : MQTT filter result: ");
        log += processData ? F("true") : F("false");
        addLogMove(LOG_LEVEL_DEBUG, log);
      }
      # endif
      # endif

      if (!processData) {
        Payload.clear();
        unparsedPayload.clear();
      }


      for (uint8_t x = 0; x < VARS_PER_TASK && processData; x++)
      {
        if (P037_data->mqttTopics[x].length() == 0) {
          continue;
        }


        subscriptionTopicParsed = P037_data->getFullMQTTTopic(x);
        parseSystemVariables(subscriptionTopicParsed, false);

        if (MQTTCheckSubscription_037(event->String1, subscriptionTopicParsed)) {
          # if P037_JSON_SUPPORT
          # ifdef P037_FILTER_PER_TOPIC


          bool passFilter = true;

          if (checkJson && P037_data->hasFilters()) {
            P037_data->iter = P037_data->doc.begin();

            do {
              key = P037_data->iter->key().c_str();
              Payload = P037_data->iter->value().as<String>();
              # if P037_MAPPING_SUPPORT

              if (P037_APPLY_MAPPINGS) {
                Payload = P037_data->mapValue(Payload, key);
              }
              # endif
              passFilter = P037_data->checkFilters(key, Payload, x + 1);

              ++P037_data->iter;
            } while (passFilter && P037_data->iter != P037_data->doc.end());
            P037_data->iter = P037_data->doc.begin();
          }

          if (passFilter)
          # endif
          # endif
          {
            do {
              # if P037_JSON_SUPPORT

              if (checkJson && (P037_data->iter != P037_data->doc.end())) {
                String jsonIndex = parseString(P037_data->jsonAttributes[x], 2, ';');
                String jsonAttribute = parseStringKeepCase(P037_data->jsonAttributes[x], 1, ';');
                jsonAttribute.trim();

                if (!jsonAttribute.isEmpty()) {
                  key = jsonAttribute;

                  if (key.indexOf('.') > -1) {
                    String part1 = parseStringKeepCase(key, 1, '.');
                    String part2 = parseStringKeepCase(key, 2, '.');
                    Payload = P037_data->doc[part1][part2].as<String>();
                  } else {
                    Payload = P037_data->doc[key].as<String>();
                  }
                  unparsedPayload = Payload;
                  int8_t jIndex = jsonIndex.toInt();

                  if (jIndex > 1) {
                    Payload = parseString(Payload, jIndex, ';');
                  }

                  # if !defined(P037_LIMIT_BUILD_SIZE) || defined(P037_OVERRIDE)

                  if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                    String log = F("IMPT : MQTT fetched json attribute: ");
                    log.reserve(48);
                    log += key;
                    log += F(" payload: ");
                    log += Payload;

                    if (!jsonIndex.isEmpty()) {
                      log += F(" index: ");
                      log += jsonIndex;
                    }
                    addLogMove(LOG_LEVEL_INFO, log);
                  }
                  # endif
                  continueProcessing = false;
                } else {
                  key = P037_data->iter->key().c_str();
                  Payload = P037_data->iter->value().as<String>();
                  unparsedPayload = Payload;
                }
                # ifdef PLUGIN_037_DEBUG

                if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                  String log = F("P037 json key: ");
                  log.reserve(48);
                  log += key;
                  log += F(" payload: ");
                  # if P037_MAPPING_SUPPORT
                  log += (P037_APPLY_MAPPINGS ? P037_data->mapValue(Payload, key) : Payload);
                  # else
                  log += Payload;
                  # endif
                  addLogMove(LOG_LEVEL_INFO, log);
                }
                # endif
                ++P037_data->iter;
              }
              # if P037_MAPPING_SUPPORT

              if (P037_APPLY_MAPPINGS) {
                Payload = P037_data->mapValue(Payload, key);
              }
              # endif
              # endif
              bool numericPayload = true;

              if (!checkJson || (checkJson && (!key.isEmpty()))) {
                ESPEASY_RULES_FLOAT_TYPE doublePayload{};

                if (!validDoubleFromString(Payload, doublePayload)) {
                  if (!checkJson && (P037_SEND_EVENTS == 0)) {
                    String log = F("IMPT : Bad Import MQTT Command ");
                    log.reserve(64);
                    log += event->String1;
                    addLog(LOG_LEVEL_ERROR, log);
                    # if !defined(P037_LIMIT_BUILD_SIZE) || defined(P037_OVERRIDE)

                    if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                      log.clear();
                      log += F("ERR  : Illegal Payload ");
                      log += Payload;
                      log += ' ';
                      log += getTaskDeviceName(event->TaskIndex);
                      addLogMove(LOG_LEVEL_INFO, log);
                    }
                    # endif
                    success = false;
                    break;
                  }
                  numericPayload = false;
                  doublePayload = NAN;
                }
                UserVar.setFloat(event->TaskIndex, x, doublePayload);

                if (!checkJson && P037_SEND_EVENTS && Settings.UseRules) {
                  String RuleEvent;
                  RuleEvent.reserve(64);
                  RuleEvent += getTaskDeviceName(event->TaskIndex);
                  RuleEvent += '#';
                  RuleEvent += event->String1;
                  RuleEvent += '=';
                  RuleEvent += wrapWithQuotesIfContainsParameterSeparatorChar(unparsedPayload);
                  P037_addEventToQueue(event, RuleEvent);
                }


                # if !defined(P037_LIMIT_BUILD_SIZE) || defined(P037_OVERRIDE)

                if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                  String log = F("IMPT : [");
                  log += getTaskDeviceName(event->TaskIndex);
                  log += '#';

                  if (checkJson) {
                    log += key;
                  } else {
                    log += getTaskValueName(event->TaskIndex, x);
                  }
                  log += F("] : ");
                  log += doublePayload;
                  addLogMove(LOG_LEVEL_INFO, log);
                }
                # endif



                if (Settings.UseRules && P037_SEND_EVENTS) {
                  if (checkJson) {

                    String RuleEvent;
                    RuleEvent.reserve(64);
                    RuleEvent += event->String1;
                    # if P037_FILTER_SUPPORT && defined(P037_FILTER_PER_TOPIC)
                    RuleEvent += P037_data->getFilterAsTopic(x + 1);
                    # endif
                    RuleEvent += '#';
                    RuleEvent += key;
                    RuleEvent += '=';
                    bool hasSemicolon = unparsedPayload.indexOf(';') > -1;

                    if (numericPayload && !hasSemicolon) {
                      RuleEvent += doublePayload;
                    } else if (numericPayload && hasSemicolon) {
                      RuleEvent += wrapWithQuotesIfContainsParameterSeparatorChar(Payload);
                      RuleEvent += ',';
                      RuleEvent += wrapWithQuotesIfContainsParameterSeparatorChar(unparsedPayload);
                    } else {
                      RuleEvent += wrapWithQuotesIfContainsParameterSeparatorChar(Payload);
                    }
                    P037_addEventToQueue(event, RuleEvent);
                  }


                  String RuleEvent;
                  RuleEvent.reserve(64);
                  RuleEvent += getTaskDeviceName(event->TaskIndex);
                  RuleEvent += '#';
                  RuleEvent += getTaskValueName(event->TaskIndex, x);
                  RuleEvent += '=';

                  if (numericPayload) {
                    RuleEvent += doublePayload;
                  } else {
                    RuleEvent += wrapWithQuotesIfContainsParameterSeparatorChar(Payload);
                  }
                  P037_addEventToQueue(event, RuleEvent);
                }
                # if P037_JSON_SUPPORT

                if (checkJson && (P037_data->iter == P037_data->doc.end())) {
                  continueProcessing = false;
                }
                # endif
              }
            } while (continueProcessing);
          }

          success = true;
        }
      }
      # if P037_JSON_SUPPORT

      if (checkJson) {
        P037_data->cleanupJSON();
      }
      # endif

      break;
    }
  }

  return success;
}

bool MQTT_unsubscribe_037(struct EventStruct *event)
{
  P037_data_struct *P037_data = static_cast<P037_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P037_data) {
    return false;
  }

  String topic;

  for (uint8_t x = 0; x < VARS_PER_TASK; x++) {
    String tmp = P037_data->getFullMQTTTopic(x);

    if (topic.equalsIgnoreCase(tmp)) {

      continue;
    }
    topic = std::move(tmp);



    bool canUnsubscribe = true;

    for (taskIndex_t task = 0; task < INVALID_TASK_INDEX && canUnsubscribe; ++task) {
      if (task != event->TaskIndex) {
        constexpr pluginID_t P037_PLUGIN_ID{PLUGIN_ID_037};
        if (Settings.TaskDeviceEnabled[task] &&
            (Settings.getPluginID_for_task(task) == P037_PLUGIN_ID)) {
          P037_data_struct *P037_data_other = static_cast<P037_data_struct *>(getPluginTaskData(task));

          if (nullptr != P037_data_other) {
            if (P037_data_other->shouldSubscribeToMQTTtopic(topic)) {
              canUnsubscribe = false;

              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log = F("IMPT : Cannot unsubscribe topic: ");
                log += topic;
                log += F(" used by: [");
                log += getTaskDeviceName(event->TaskIndex);
                log += '#';
                log += getTaskValueName(event->TaskIndex, x);
                log += ']';
                log += topic;
                addLogMove(LOG_LEVEL_INFO, log);
              }
            }
          }
        }
      }
    }

    if (canUnsubscribe && (topic.length() > 0) && MQTTclient.unsubscribe(topic.c_str())) {
      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log = F("IMPT : [");
        log += getTaskDeviceName(event->TaskIndex);
        log += '#';
        log += getTaskValueName(event->TaskIndex, x);
        log += F("] : Unsubscribe topic: ");
        log += topic;
        addLogMove(LOG_LEVEL_INFO, log);
      }
    }
  }
  return true;
}

bool MQTTSubscribe_037(struct EventStruct *event)
{

  P037_data_struct *P037_data = static_cast<P037_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P037_data) {
    return false;
  }


  P037_data->loadSettings();


  for (uint8_t x = 0; x < VARS_PER_TASK; x++) {
    String subscribeTo = P037_data->getFullMQTTTopic(x);

    if (!subscribeTo.isEmpty()) {
      parseSystemVariables(subscribeTo, false);

      if (MQTTclient.subscribe(subscribeTo.c_str())) {
        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("IMPT : [");
          log += getTaskDeviceName(event->TaskIndex);
          log += F("#");
          log += getTaskValueName(event->TaskIndex, x);
          log += F("] subscribed to ");
          log += subscribeTo;
          addLogMove(LOG_LEVEL_INFO, log);
        }
      } else {
        if (loglevelActiveFor(LOG_LEVEL_ERROR)) {
          String log = F("IMPT : Error subscribing to ");
          log += subscribeTo;
          addLogMove(LOG_LEVEL_ERROR, log);
        }
        return false;
      }
    }
  }
  return true;
}




bool MQTTCheckSubscription_037(const String& Topic, const String& Subscription) {
  if (Topic.isEmpty() || Subscription.isEmpty()) {
    return false;
  }

  String tmpTopic = Topic;
  String tmpSub = Subscription;

  tmpTopic.trim();
  tmpSub.trim();


  if (tmpTopic[0] == '/') { tmpTopic = tmpTopic.substring(1); }

  if (tmpSub[0] == '/') { tmpSub = tmpSub.substring(1); }




  if (equals(tmpSub, '#')) { return true; }

  if (tmpSub.endsWith(F("/#"))) {
    bool multiLevelWildcard = tmpTopic.startsWith(tmpSub.substring(0, tmpSub.length() - 1));

    if (tmpSub.indexOf('+') == -1) {
      return multiLevelWildcard;
    }
  } else {
    if (tmpSub.indexOf('#') != -1) { return false;
    }
  }



  int lenTopic = tmpTopic.length();

  if (tmpTopic.substring(lenTopic - 1, lenTopic) != "/") { tmpTopic += '/'; }

  int lenSub = tmpSub.length();

  if (tmpSub.substring(lenSub - 1, lenSub) != "/") { tmpSub += '/'; }



  int SlashTopic;
  int SlashSub;
  int count = 0;

  String pTopic;
  String pSub;

  while (count < 10) {


    SlashTopic = tmpTopic.indexOf('/');
    SlashSub = tmpSub.indexOf('/');




    if ((SlashTopic == -1) && (SlashSub == -1)) { return true; }

    if ((SlashTopic == -1) && (SlashSub != -1)) { return false; }

    if ((SlashTopic != -1) && (SlashSub == -1)) { return false; }



    pTopic = tmpTopic.substring(0, SlashTopic);
    pSub = tmpSub.substring(0, SlashSub);



    tmpTopic = tmpTopic.substring(SlashTopic + 1);
    tmpSub = tmpSub.substring(SlashSub + 1);


    if (pSub == "#") { return true; }

    if ((pTopic != pSub) && (!equals(pSub, '+'))) { return false; }

    count = count + 1;
  }
  return false;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P038_NeoPixel.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P038
# 42 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P038_NeoPixel.ino"
# include "./src/PluginStructs/P038_data_struct.h"

#define PLUGIN_038 
#define PLUGIN_ID_038 38
#define PLUGIN_NAME_038 "Output - NeoPixel (Basic)"
#define PLUGIN_VALUENAME1_038 ""

boolean Plugin_038(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_038;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].TimerOption = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_038);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_038));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("DIN"));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P038_CONFIG_BRIGHTNESS = 255;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Led Count"), F("pleds"), P038_CONFIG_LEDCOUNT, 1, 999);

      {
        const __FlashStringHelper *options[] = { F("GRB"), F("GRBW") };
        int indices[] = { P038_STRIP_TYPE_RGB, P038_STRIP_TYPE_RGBW };
        addFormSelector(F("Strip Type"), F("pstrip"), 2, options, indices, P038_CONFIG_STRIPTYPE);
      }

      if (P038_CONFIG_BRIGHTNESS == 0) { P038_CONFIG_BRIGHTNESS = 255; }
      addFormNumericBox(F("Initial brightness"), F("ibright"), P038_CONFIG_BRIGHTNESS, 1, 255);
      addUnit(F("1..255"));

      if (P038_CONFIG_MAXBRIGHT == 0) { P038_CONFIG_MAXBRIGHT = 255; }
      addFormNumericBox(F("Maximum allowed brightness"), F("maxbright"), P038_CONFIG_MAXBRIGHT, 1, 255);
      addUnit(F("1..255"));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P038_CONFIG_LEDCOUNT = getFormItemInt(F("pleds"));
      P038_CONFIG_STRIPTYPE = getFormItemInt(F("pstrip"));
      P038_CONFIG_BRIGHTNESS = getFormItemInt(F("ibright"));
      P038_CONFIG_MAXBRIGHT = getFormItemInt(F("maxbright"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      if (P038_CONFIG_BRIGHTNESS == 0) { P038_CONFIG_BRIGHTNESS = 255; }

      if (P038_CONFIG_MAXBRIGHT == 0) { P038_CONFIG_MAXBRIGHT = 255; }
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P038_data_struct(CONFIG_PIN1,
                                                                               P038_CONFIG_LEDCOUNT,
                                                                               P038_CONFIG_STRIPTYPE,
                                                                               P038_CONFIG_BRIGHTNESS,
                                                                               P038_CONFIG_MAXBRIGHT));
      P038_data_struct *P038_data = static_cast<P038_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P038_data) && P038_data->plugin_init(event);

      break;
    }

    case PLUGIN_EXIT:
    {
      P038_data_struct *P038_data = static_cast<P038_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P038_data) {
        success = P038_data->plugin_exit(event);
      }

      break;
    }

    case PLUGIN_WRITE:
    {
      P038_data_struct *P038_data = static_cast<P038_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P038_data) {
        success = P038_data->plugin_write(event, string);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P039
# 65 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
# include <SPI.h>


# include "src/PluginStructs/P039_data_struct.h"
# 77 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
#define MAX31865_RD_ADDRESS(n) (MAX31865_READ_ADDR_BASE + (n))
#define MAX31865_WR_ADDRESS(n) (MAX31865_WRITE_ADDR_BASE + (n))

#define PLUGIN_039 
#define PLUGIN_ID_039 39
#define PLUGIN_NAME_039 "Environment - Thermosensors"
#define PLUGIN_VALUENAME1_039 "Temperature"

#define P039_SET true
#define P039_RESET false




#define P039_CS_Delay() delayMicroseconds(2u)

#define P039_MAX_TYPE PCONFIG(0)
#define P039_TC_TYPE PCONFIG(1)
#define P039_FAM_TYPE PCONFIG(2)
#define P039_RTD_TYPE PCONFIG(3)
#define P039_CONFIG_4 PCONFIG(4)
#define P039_RTD_FILT_TYPE PCONFIG(5)
#define P039_RTD_LM_TYPE PCONFIG(6)
#define P039_RTD_LM_SHTDWN PCONFIG(7)
#define P039_RTD_RES PCONFIG_LONG(0)
#define P039_FLAGS PCONFIG_ULONG(3)
#define P039_TEMP_THRESHOLD_FLAG 0
#define P039_RTD_OFFSET PCONFIG_FLOAT(0)
#define P039_TEMP_THRESHOLD PCONFIG_FLOAT(1)

#define P039_TEMP_THRESHOLD_DEFAULT (-273.15f)
#define P039_TEMP_THRESHOLD_MIN P039_TEMP_THRESHOLD_DEFAULT
#define P039_TEMP_THRESHOLD_MAX (1000.0f)
#define P039_TC 0u
#define P039_RTD 1u

#define P039_MAX6675 1
#define P039_MAX31855 2
#define P039_MAX31856 3
#define P039_MAX31865 4
#define P039_LM7x 5




#define MAX6675_TC_DEVID 0x0002u
#define MAX6675_TC_OC 0x0004u




#define MAX31855_TC_OC 0x00000001u
#define MAX31855_TC_SC 0x00000002u
#define MAX31855_TC_SCVCC 0x00000004u
#define MAX31855_TC_GENFLT 0x00010000u





#define MAX31856_READ_ADDR_BASE 0x00u
#define MAX31856_WRITE_ADDR_BASE 0x80u


#define MAX31856_CR0 0u
#define MAX31856_CR1 1u
#define MAX31856_MASK 2u
#define MAX31856_CJHF 3u
#define MAX31856_CJLF 4u
#define MAX31856_LTHFTH 5u
#define MAX31856_LTHFTL 6u
#define MAX31856_LTLFTH 7u
#define MAX31856_LTLFTL 8u
#define MAX31856_CJTO 9u
#define MAX31856_CJTH 10u
#define MAX31856_CJTL 11u
#define MAX31856_LTCBH 12u
#define MAX31856_LTCBM 13u
#define MAX31856_LTCBL 14u
#define MAX31856_SR 15u

#define MAX31856_NO_REG 16u


#define MAX31856_TC_OC 0x01u
#define MAX31856_TC_OVUV 0x02u
#define MAX31856_TC_TCLOW 0x04u
#define MAX31856_TC_TCLHIGH 0x08u
#define MAX31856_TC_CJLOW 0x10u
#define MAX31856_TC_CJHIGH 0x20u
#define MAX31856_TC_TCRANGE 0x40u
#define MAX31856_TC_CJRANGE 0x80u


#define MAX31856_SET_50HZ 0x01u
#define MAX31856_CLEAR_FAULTS 0x02u
#define MAX31856_FLT_ISR_MODE 0x04u
#define MAX31856_CJ_SENS_DISABLE 0x08u
#define MAX31856_FAULT_CTRL_MASK 0x30u
#define MAX31856_SET_ONE_SHOT 0x40u
#define MAX31856_SET_CONV_AUTO 0x80u
# 187 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
#define MAX31865_CONVERSION_TIME 70ul
#define MAX31865_BIAS_WAIT_TIME 10ul


#define MAX31865_INIT_STATE 0u
#define MAX31865_BIAS_ON_STATE 1u
#define MAX31865_RD_STATE 2u
#define MAX31865_RDY_STATE 3u


#define MAX31865_PT100 0u
#define MAX31865_PT1000 1u


#define MAX31865_READ_ADDR_BASE 0x00u
#define MAX31865_WRITE_ADDR_BASE 0x80u


#define MAX31865_CONFIG 0u
#define MAX31865_RTD_MSB 1u
#define MAX31865_RTD_LSB 2u
#define MAX31865_HFT_MSB 3u
#define MAX31865_HFT_LSB 4u
#define MAX31865_LFT_MSB 5u
#define MAX31865_LFT_LSB 6u
#define MAX31865_FAULT 7u


#define MAX31865_NO_REG 8u


#define MAX31865_FAULT_HIGHTHRESH 0x80u
#define MAX31865_FAULT_LOWTHRESH 0x40u
#define MAX31865_FAULT_REFINLOW 0x20u
#define MAX31865_FAULT_REFINHIGH 0x10u
#define MAX31865_FAULT_RTDINLOW 0x08u
#define MAX31865_FAULT_OVUV 0x04u


#define MAX31865_SET_50HZ 0x01u
#define MAX31865_CLEAR_FAULTS 0x02u
#define MAX31865_FAULT_CTRL_MASK 0x0Cu
#define MAX31865_SET_3WIRE 0x10u
#define MAX31865_SET_ONE_SHOT 0x20u
#define MAX31865_SET_CONV_AUTO 0x40u
#define MAX31865_SET_VBIAS_ON 0x80u




#define LM7x_SD70 0x00u
#define LM7x_SD71 0x01u
#define LM7x_SD74 0x04u
#define LM7x_SD121 0x05u
#define LM7x_SD122 0x06u
#define LM7x_SD123 0x07u
#define LM7x_SD124 0x08u
#define LM7x_SD125 0x09u


#define LM7x_CONV_RDY 0x02u


void P039_AddMainsFrequencyFilterSelection(struct EventStruct *event);

boolean Plugin_039(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_039;
      Device[deviceCount].Type = DEVICE_TYPE_SPI;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_039);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_039));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("CS"));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P039_TEMP_THRESHOLD = P039_TEMP_THRESHOLD_DEFAULT;
      bitSet(P039_FLAGS, P039_TEMP_THRESHOLD_FLAG);
      break;
    }

    case PLUGIN_INIT:
    {
      if (!bitRead(P039_FLAGS, P039_TEMP_THRESHOLD_FLAG)) {
        P039_TEMP_THRESHOLD = P039_TEMP_THRESHOLD_DEFAULT;
      }

      if (P039_MAX_TYPE < P039_MAX6675 || P039_MAX_TYPE > P039_LM7x) {
        break;
      }



      initPluginTaskData(event->TaskIndex, new (std::nothrow) P039_data_struct());
      P039_data_struct *P039_data = static_cast<P039_data_struct *>(getPluginTaskData(event->TaskIndex));

      int8_t CS_pin_no = get_SPI_CS_Pin(event);


      init_SPI_CS_Pin(CS_pin_no);


      SPI.setHwCs(false);
      SPI.begin();


      SPI.setDataMode(SPI_MODE3);







      if (P039_MAX_TYPE == P039_MAX31855) {


        if (nullptr != P039_data) {

          P039_data->sensorFault = false;
        }
      }


      if (P039_MAX_TYPE == P039_MAX31856) {




        uint8_t sendBuffer[11] =
        { 0x80, static_cast<uint8_t>(P039_RTD_FILT_TYPE), static_cast<uint8_t>((P039_CONFIG_4 << 4) | P039_TC_TYPE), 0xFC, 0x7F, 0xC0, 0x7F,
          0xFF, 0x80, 0x00, 0x00 };

        transfer_n_ByteSPI(CS_pin_no, 11, &sendBuffer[0]);

        if (nullptr != P039_data) {

          P039_data->sensorFault = false;
        }


        change8BitRegister(CS_pin_no,
                           (MAX31856_READ_ADDR_BASE + MAX31856_CR0),
                           (MAX31856_WRITE_ADDR_BASE + MAX31856_CR0),
                           MAX31856_SET_ONE_SHOT,
                           P039_SET);
      }


      if (P039_MAX_TYPE == P039_MAX31865) {

        uint8_t initSendBufferHFTH[3] = { (MAX31865_WRITE_ADDR_BASE + MAX31865_HFT_MSB), 0xFF, 0xFF };
        uint8_t initSendBufferLFTH[3] = { (MAX31865_WRITE_ADDR_BASE + MAX31865_HFT_MSB), 0xFF, 0xFF };


        write8BitRegister(CS_pin_no, (MAX31865_WRITE_ADDR_BASE + MAX31865_CONFIG), 0x00u);


        change8BitRegister(CS_pin_no,
                           MAX31865_RD_ADDRESS(MAX31865_CONFIG),
                           MAX31865_WR_ADDRESS(MAX31865_CONFIG),
                           MAX31865_SET_50HZ,
                           static_cast<bool>(P039_RTD_FILT_TYPE));


        MAX31865_setConType(CS_pin_no, P039_CONFIG_4);


        transfer_n_ByteSPI(CS_pin_no, 3, &initSendBufferHFTH[0]);


        transfer_n_ByteSPI(CS_pin_no, 3, &initSendBufferLFTH[0]);


        MAX31865_clearFaults(CS_pin_no);


        change8BitRegister(CS_pin_no,
                           (MAX31865_READ_ADDR_BASE + MAX31865_CONFIG),
                           (MAX31865_WRITE_ADDR_BASE + MAX31865_CONFIG),
                           MAX31865_SET_VBIAS_ON,
                           P039_SET);

        if (nullptr != P039_data) {

          P039_data->timer = millis();




          Scheduler.setPluginTaskTimer(MAX31865_BIAS_WAIT_TIME, event->TaskIndex, MAX31865_BIAS_ON_STATE);
        }
      }







#ifndef BUILD_NO_DEBUG
      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        addLogMove(LOG_LEVEL_INFO, strformat(F("P039 : %s : SPI Init - DONE"), getTaskDeviceName(event->TaskIndex).c_str()));
      }
#endif

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Sensor Family Selection"));

      const uint8_t family = P039_FAM_TYPE;
      {
        const __FlashStringHelper *Foptions[2] = { F("Thermocouple"), F("RTD") };
        const int FoptionValues[2] = { P039_TC, P039_RTD };
        addFormSelector(F("Sensor Family Type"), F("famtype"), 2, Foptions, FoptionValues, family, true);
      }

      const uint8_t choice = P039_MAX_TYPE;

      addFormSubHeader(F("Device Type Settings"));
      if (family == P039_TC) {
        {
          const __FlashStringHelper *options[3] = { F("MAX 6675"), F("MAX 31855"), F("MAX 31856") };
          const int optionValues[3] = { P039_MAX6675, P039_MAX31855, P039_MAX31856 };
          addFormSelector(F("Adapter IC"), F("maxtype"), 3, options, optionValues, choice, true);
        }

        if (choice == P039_MAX31856) {
          addFormSubHeader(F("Device Settings"));
          {
            const __FlashStringHelper *Toptions[10] = { F("B"), F("E"), F("J"), F("K"), F("N"), F("R"), F("S"), F("T"), F("VM8"), F("VM32") };
# 471 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
            const int ToptionValues[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 12 };
            addFormSelector(F("Thermocouple type"), F("tctype"), 10, Toptions, ToptionValues, P039_TC_TYPE);
          }
          {
            const __FlashStringHelper *Coptions[5] = { F("1"), F("2"), F("4"), F("8"), F("16") };
            const int CoptionValues[5] = { 0, 1, 2, 3, 4 };
            addFormSelector(F("Averaging"), F("contype"), 5, Coptions, CoptionValues, P039_CONFIG_4);
            addUnit(F("sample(s)"));
          }
          P039_AddMainsFrequencyFilterSelection(event);
        }
      }
      else {
        {
          const __FlashStringHelper *TPoptions[2] = { F("MAX 31865"), F("LM7x") };
          const int TPoptionValues[2] = { P039_MAX31865, P039_LM7x };
          addFormSelector(F("Adapter IC"), F("maxtype"), 2, TPoptions, TPoptionValues, choice, true);
          addFormNote(F("LM7x support is experimental."));
        }


        if (choice == P039_MAX31865)
        {
          {
            addFormSubHeader(F("Device Settings"));
          }
          {
            const __FlashStringHelper *PToptions[2] = { F("PT100"), F("PT1000") };
            const int PToptionValues[2] = { MAX31865_PT100, MAX31865_PT1000 };
            addFormSelector(F("Resistor Type"), F("rtdtype"), 2, PToptions, PToptionValues, P039_RTD_TYPE);
          }
          {
            const __FlashStringHelper *Coptions[2] = { F("2-/4"), F("3") };
            const int CoptionValues[2] = { 0, 1 };
            addFormSelector(F("Connection Type"), F("contype"), 2, Coptions, CoptionValues, P039_CONFIG_4);
            addUnit(F("wire"));
          }

          P039_AddMainsFrequencyFilterSelection(event);

          {
            addFormNumericBox(F("Reference Resistor"), F("res"), P039_RTD_RES, 0);
            addUnit(F("Ohm"));
            addFormNote(F("PT100: typically 430 [OHM]; PT1000: typically 4300 [OHM]"));
          }
          {
            addFormFloatNumberBox(F("Temperature Offset"), F("offset"), P039_RTD_OFFSET, -50.0f, 50.0f, 2, 0.01f);
            addUnit('K');
            # ifndef BUILD_NO_DEBUG
            addFormNote(F("Valid values: [-50.0...50.0 K], min. stepsize: [0.01]"));
            #endif
          }
        }

        if (choice == P039_LM7x)
        {
          {
            addFormSubHeader(F("Device Settings"));
          }

          {
            const __FlashStringHelper *PToptions[8] =
            { F("LM70"), F("LM71"), F("LM74"), F("TMP121"), F("TMP122"), F("TMP123"), F("TMP124"), F("TMP125") };
            const int PToptionValues[8] = { LM7x_SD70, LM7x_SD71, LM7x_SD74, LM7x_SD121, LM7x_SD122, LM7x_SD123, LM7x_SD124, LM7x_SD125 };
            addFormSelector(F("LM7x device details"), F("rtd_lm_type"), 8, PToptions, PToptionValues, P039_RTD_LM_TYPE);
            addFormNote(F("TMP122/124 Limited support -> fixed 12 Bit res, no advanced options"));
          }
          {
            addFormCheckBox(F("Enable Shutdown Mode"), F("rtd_lm_shtdwn"), P039_RTD_LM_SHTDWN);
            # ifndef BUILD_NO_DEBUG
            addFormNote(F("Device is set to shutdown between sample cycles. Useful for very long call cycles, to save power.\nWithout LM7x device conversion happens in between call cycles. Call Cylces should therefore not become lower than 350ms."));
            #endif
          }
        }
      }

      addFormSubHeader(F("Value validation"));

      if (!bitRead(P039_FLAGS, P039_TEMP_THRESHOLD_FLAG)) {
        P039_TEMP_THRESHOLD = P039_TEMP_THRESHOLD_DEFAULT;
      }
      addFormFloatNumberBox(F("Low temperature threshold"),
                            F("temp_thres"),
                            P039_TEMP_THRESHOLD,
                            P039_TEMP_THRESHOLD_MIN,
                            P039_TEMP_THRESHOLD_MAX,
                            2u);
      addUnit(F("&deg;C"));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P039_FAM_TYPE = getFormItemInt(F("famtype"));
      P039_MAX_TYPE = getFormItemInt(F("maxtype"));
      P039_TC_TYPE = getFormItemInt(F("tctype"));
      P039_RTD_TYPE = getFormItemInt(F("rtdtype"));
      P039_CONFIG_4 = getFormItemInt(F("contype"));
      P039_RTD_FILT_TYPE = getFormItemInt(F("filttype"));
      P039_RTD_RES = getFormItemInt(F("res"));
      P039_RTD_OFFSET = getFormItemFloat(F("offset"));
      P039_RTD_LM_TYPE = getFormItemInt(F("rtd_lm_type"));
      P039_RTD_LM_SHTDWN = isFormItemChecked(F("rtd_lm_shtdwn"));
      P039_TEMP_THRESHOLD = getFormItemFloat(F("temp_thres"));
      bitSet(P039_FLAGS, P039_TEMP_THRESHOLD_FLAG);

      success = true;
      break;
    }

    case PLUGIN_READ:
    {

      uint8_t MaxType = P039_MAX_TYPE;

      float Plugin_039_Celsius = NAN;

      switch (MaxType) {
        case P039_MAX6675:
          Plugin_039_Celsius = readMax6675(event);
          break;
        case P039_MAX31855:
          Plugin_039_Celsius = readMax31855(event);
          break;
        case P039_MAX31856:
          Plugin_039_Celsius = readMax31856(event);
          break;
        case P039_MAX31865:
          Plugin_039_Celsius = readMax31865(event);
          break;
        case P039_LM7x:
          Plugin_039_Celsius = readLM7x(event);
          break;
      }

      if (isValidFloat(Plugin_039_Celsius))
      {
        UserVar.setFloat(event->TaskIndex, 0, Plugin_039_Celsius);

#ifndef BUILD_NO_DEBUG
        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = strformat(F("P039 : %s :"), getTaskDeviceName(event->TaskIndex).c_str());
          for (uint8_t i = 0; i < getValueCountForTask(event->TaskIndex); i++)
          {
            log += strformat(
              F(" %s: %s"),
              getTaskValueName(event->TaskIndex, i).c_str(),
              formatUserVarNoCheck(event->TaskIndex, i).c_str());
          }
          addLogMove(LOG_LEVEL_INFO, log);
        }
#endif

        if (definitelyGreaterThan(Plugin_039_Celsius, P039_TEMP_THRESHOLD)) {
          success = true;
        }
      }
      else
      {
        UserVar.setFloat(event->TaskIndex, 0, NAN);
        UserVar.setFloat(event->TaskIndex, 1, NAN);

        if (loglevelActiveFor(LOG_LEVEL_ERROR)) {
          addLog(LOG_LEVEL_ERROR, strformat(F("P039 : %s : No Sensor attached!"), getTaskDeviceName(event->TaskIndex).c_str()));
        }
        success = false;
      }

      break;
    }

    case PLUGIN_TASKTIMER_IN:
    {
      P039_data_struct *P039_data = static_cast<P039_data_struct *>(getPluginTaskData(event->TaskIndex));

      int8_t CS_pin_no = get_SPI_CS_Pin(event);


      uint8_t MaxType = P039_MAX_TYPE;

      switch (MaxType)
      {
        case P039_MAX31865:
        {
          if ((nullptr != P039_data)) {
            switch (event->Par1)
            {
              case MAX31865_BIAS_ON_STATE:
              {
                # ifndef BUILD_NO_DEBUG

                if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
                  addLogMove(LOG_LEVEL_DEBUG, strformat(
                    F("P039 : %s : current state: MAX31865_BIAS_ON_STATE; delta: %d ms"),
                    getTaskDeviceName(event->TaskIndex).c_str(),
                    timePassedSince(P039_data->timer)));
                }
                # endif


                P039_data->timer = millis();


                change8BitRegister(CS_pin_no,
                                   (MAX31865_READ_ADDR_BASE + MAX31865_CONFIG),
                                   (MAX31865_WRITE_ADDR_BASE + MAX31865_CONFIG),
                                   MAX31865_SET_ONE_SHOT,
                                   P039_SET);



                P039_data->convReady = false;
                Scheduler.setPluginTaskTimer(MAX31865_CONVERSION_TIME, event->TaskIndex, MAX31865_RD_STATE);

                # ifndef BUILD_NO_DEBUG

                if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
                  addLog(LOG_LEVEL_DEBUG, strformat(
                    F("P039 : %s : Next State: %d"),
                    getTaskDeviceName(event->TaskIndex).c_str(),
                    event->Par1));
                }
                # endif

                break;
              }
              case MAX31865_RD_STATE:
              {
                # ifndef BUILD_NO_DEBUG

                if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
                  addLogMove(LOG_LEVEL_DEBUG, strformat(
                    F("P039 : %s : current state: MAX31865_RD_STATE; delta: %d ms"),
                    getTaskDeviceName(event->TaskIndex).c_str(),
                    timePassedSince(P039_data->timer)));
                }
                # endif


                P039_data->timer = millis();


                P039_data->conversionResult = read16BitRegister(CS_pin_no, (MAX31865_READ_ADDR_BASE + MAX31865_RTD_MSB));


                change8BitRegister(CS_pin_no,
                                   (MAX31865_READ_ADDR_BASE + MAX31865_CONFIG),
                                   (MAX31865_WRITE_ADDR_BASE + MAX31865_CONFIG),
                                   MAX31865_SET_VBIAS_ON,
                                   P039_RESET);


                P039_data->deviceFaults = read8BitRegister(CS_pin_no, (MAX31865_READ_ADDR_BASE + MAX31865_FAULT));


                P039_data->convReady = true;

                # ifndef BUILD_NO_DEBUG

                if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
                  String log;

                  if ((log.reserve(170u))) {
                    log = F("P039 : ");
                    log += getTaskDeviceName(event->TaskIndex);
                    log += F(" : conversionResult: ");
                    log += formatToHex_decimal(P039_data->conversionResult);
                    log += F("; deviceFaults: ");
                    log += formatToHex_decimal(P039_data->deviceFaults);
                    log += F("; Next State: ");
                    log += event->Par1;
                    addLogMove(LOG_LEVEL_DEBUG, log);
                  }
                }
                # endif


                break;
              }
              case MAX31865_INIT_STATE:
              default:
              {

                MAX31865_clearFaults(CS_pin_no);


                change8BitRegister(CS_pin_no,
                                   (MAX31865_READ_ADDR_BASE + MAX31865_CONFIG),
                                   (MAX31865_WRITE_ADDR_BASE + MAX31865_CONFIG),
                                   MAX31865_SET_VBIAS_ON,
                                   P039_SET);


                # ifndef BUILD_NO_DEBUG

                if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
                  String log;

                  if ((log.reserve(140u))) {
                    log = F("P039 : ");
                    log += getTaskDeviceName(event->TaskIndex);
                    log += F(" : ");
                    log += F("current state: MAX31865_INIT_STATE, default;");
                    log += F(" next state: MAX31865_BIAS_ON_STATE");
                    addLogMove(LOG_LEVEL_DEBUG, log);
                  }


                  P039_data->timer = millis();
                }
                # endif





                Scheduler.setPluginTaskTimer(MAX31865_BIAS_WAIT_TIME, event->TaskIndex, MAX31865_BIAS_ON_STATE);


                break;
              }
            }
          }
          break;
        }
        default:
        {
          break;
        }
      }

      success = true;
      break;
    }
  }
  return success;
}

void P039_AddMainsFrequencyFilterSelection(struct EventStruct *event)
{
  const __FlashStringHelper *FToptions[2] = { F("60"), F("50") };
  const int FToptionValues[2] = { 0, 1 };
  addFormSelector(F("Supply Frequency Filter"), F("filttype"), 2, FToptions, FToptionValues, P039_RTD_FILT_TYPE);
  addUnit(F("Hz"));
  addFormNote(F("Filter power net frequency (50/60 Hz)"));
}

float readMax6675(struct EventStruct *event)
{
  int8_t CS_pin_no = get_SPI_CS_Pin(event);

  uint8_t messageBuffer[2] = { 0 };
  uint16_t rawvalue = 0u;



  transfer_n_ByteSPI(CS_pin_no, 2, &messageBuffer[0]);


  rawvalue = ((messageBuffer[0] << 8) | messageBuffer[1]);

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG))
  {
    String log;

    if ((log.reserve(130u))) {
      log = F("P039 : MAX6675 : RAW - BIN: ");
      log += String(rawvalue, BIN);
      log += F(" HEX: ");
      log += formatToHex(rawvalue);
      log += F(" DEC: ");
      log += String(rawvalue);
      log += F(" MSB: ");
      log += formatToHex_decimal(messageBuffer[0]);
      log += F(" LSB: ");
      log += formatToHex_decimal(messageBuffer[1]);
      addLogMove(LOG_LEVEL_DEBUG, log);
    }
  }

  # endif






  const bool Plugin_039_SensorAttached = !(rawvalue & MAX6675_TC_OC);

  if (Plugin_039_SensorAttached)
  {

    rawvalue >>= 3;


    return rawvalue * 0.25f;
  }
  else
  {
    return NAN;
  }
}

float readMax31855(struct EventStruct *event)
{
  P039_data_struct *P039_data = static_cast<P039_data_struct *>(getPluginTaskData(event->TaskIndex));

  uint8_t messageBuffer[4] = { 0 };

  int8_t CS_pin_no = get_SPI_CS_Pin(event);


  transfer_n_ByteSPI(CS_pin_no, 4, &messageBuffer[0]);


  uint32_t rawvalue =
    ((static_cast<uint32_t>(messageBuffer[0]) <<
      24) |
     (static_cast<uint32_t>(messageBuffer[1]) <<
      16) | (static_cast<uint32_t>(messageBuffer[2]) << 8) | static_cast<uint32_t>(messageBuffer[3]));


  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG))
  {
    String log;

    if ((log.reserve(200u))) {
      log = F("P039 : MAX31855 : RAW - BIN: ");
      log += String(rawvalue, BIN);
      log += F(" rawvalue,HEX: ");
      log += formatToHex(rawvalue);
      log += F(" rawvalue,DEC: ");
      log += rawvalue;
      log += F(" messageBuffer[],HEX:");

      for (size_t i = 0u; i < 4; i++)
      {
        log += ' ';
        log += formatToHex_decimal(messageBuffer[i]);
      }
      addLogMove(LOG_LEVEL_DEBUG, log);
    }
  }

  # endif

  if (nullptr != P039_data) {



    if (P039_data->sensorFault != ((rawvalue & (MAX31855_TC_SCVCC | MAX31855_TC_SC | MAX31855_TC_OC)) == 0)) {

      P039_data->sensorFault = ((rawvalue & (MAX31855_TC_SCVCC | MAX31855_TC_SC | MAX31855_TC_OC)) == 0);

      # ifndef BUILD_NO_DEBUG

      if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE))
      {
        String log;

        if ((log.reserve(120u))) {
          log = F("P039 : MAX31855 : ");

          if ((P039_data->sensorFault)) {
            log += F("Fault resolved");
          } else {
            log += F("Fault code :");

            if (rawvalue & MAX31855_TC_OC) {
              log += F(" Open (no connection)");
            }

            if (rawvalue & MAX31855_TC_SC) {
              log += F(" Short-circuit to GND");
            }

            if (rawvalue & MAX31855_TC_SCVCC) {
              log += F(" Short-circuit to Vcc");
            }
          }
          addLogMove(LOG_LEVEL_DEBUG_MORE, log);
        }
      }
      # endif
    }

    # ifndef BUILD_NO_DEBUG

    if (loglevelActiveFor(LOG_LEVEL_DEBUG))
    {
      String log;

      if ((log.reserve(120u))) {
        log = F("P039 : MAX31855 : ");
        log += F("rawvalue: ");
        log += formatToHex_decimal(rawvalue);
        log += F(" P039_data->sensorFault: ");
        log += formatToHex_decimal(P039_data->sensorFault);
        addLogMove(LOG_LEVEL_DEBUG, log);
      }
    }

    # endif
  }



  const bool Plugin_039_SensorAttached = !(rawvalue & (MAX31855_TC_GENFLT | MAX31855_TC_SCVCC | MAX31855_TC_SC | MAX31855_TC_OC));

  if (Plugin_039_SensorAttached)
  {


    rawvalue >>= 18;
# 999 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
    int temperature = Plugin_039_convert_two_complement(rawvalue, 14);


    return temperature * 0.25f;
  }
  else
  {

    return NAN;
  }
}

float readMax31856(struct EventStruct *event)
{
  P039_data_struct *P039_data = static_cast<P039_data_struct *>(getPluginTaskData(event->TaskIndex));

  int8_t CS_pin_no = get_SPI_CS_Pin(event);


  uint8_t registers[MAX31856_NO_REG] = { 0 };
  uint8_t messageBuffer[MAX31856_NO_REG + 1] = { 0 };

  messageBuffer[0] = MAX31856_READ_ADDR_BASE;


  transfer_n_ByteSPI(CS_pin_no, (MAX31856_NO_REG + 1), &messageBuffer[0]);


  for (uint8_t i = 0u; i < MAX31856_NO_REG; ++i) {
    registers[i] = messageBuffer[i + 1];
  }



  change8BitRegister(CS_pin_no,
                     (MAX31856_READ_ADDR_BASE + MAX31856_CR0),
                     (MAX31856_WRITE_ADDR_BASE + MAX31856_CR0),
                     MAX31856_SET_50HZ,
                     static_cast<bool>(P039_RTD_FILT_TYPE));


  write8BitRegister(CS_pin_no, (MAX31856_WRITE_ADDR_BASE + MAX31856_CR1), static_cast<uint8_t>((P039_CONFIG_4 << 4) | P039_TC_TYPE));



  change8BitRegister(CS_pin_no,
                     (MAX31856_READ_ADDR_BASE + MAX31856_CR0),
                     (MAX31856_WRITE_ADDR_BASE + MAX31856_CR0),
                     MAX31856_SET_ONE_SHOT,
                     P039_SET);



  uint32_t rawvalue = static_cast<uint32_t>(registers[MAX31856_LTCBH]);

  rawvalue = (rawvalue << 8) | static_cast<uint32_t>(registers[MAX31856_LTCBM]);
  rawvalue = (rawvalue << 8) | static_cast<uint32_t>(registers[MAX31856_LTCBL]);

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG))
  {
    String log;

    if ((log.reserve(210u))) {
      log = F("P039 : MAX31856 :");

      for (uint8_t i = 0; i < MAX31856_NO_REG; ++i) {
        log += ' ';
        log += formatToHex_decimal(registers[i]);
      }
      log += F(" rawvalue: ");
      log += formatToHex_decimal(rawvalue);
      addLogMove(LOG_LEVEL_DEBUG, log);
    }
  }

  # endif
# 1085 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
  uint8_t sr = registers[MAX31856_SR];

  if ((8u == P039_TC_TYPE) || (12u == P039_TC_TYPE)) {
    sr &= ~MAX31856_TC_TCRANGE;
  }



  if ((nullptr != P039_data)) {


    P039_data->sensorFault = (sr != 0);

    # ifndef BUILD_NO_DEBUG

    if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE))
    {

      const bool faultResolved = (P039_data->sensorFault) && (sr == 0);

      if ((P039_data->sensorFault) || faultResolved) {
        String log;

        if ((log.reserve(140u))) {
          log = F("P039 : MAX31856 : ");

          if ((P039_data->sensorFault) == 0) {
            log += F("Fault resolved");
          } else {
            log += F("Fault :");

            if (sr & MAX31856_TC_OC) {
              log += F(" Open (no connection)");
            }

            if (sr & MAX31856_TC_OVUV) {
              log += F(" Over/Under Voltage");
            }

            if (sr & MAX31856_TC_TCLOW) {
              log += F(" TC Low");
            }

            if (sr & MAX31856_TC_TCLHIGH) {
              log += F(" TC High");
            }

            if (sr & MAX31856_TC_CJLOW) {
              log += F(" CJ Low");
            }

            if (sr & MAX31856_TC_CJHIGH) {
              log += F(" CJ High");
            }

            if (sr & MAX31856_TC_TCRANGE) {
              log += F(" TC Range");
            }

            if (sr & MAX31856_TC_CJRANGE) {
              log += F(" CJ Range");
            }
            addLogMove(LOG_LEVEL_DEBUG_MORE, log);
          }
        }
      }
    }
    # endif
  }


  const bool Plugin_039_SensorAttached = (sr == 0);

  if (Plugin_039_SensorAttached)
  {
    rawvalue >>= 5;


    {
      float temperature = 0;

      switch (P039_TC_TYPE)
      {
        case 8:
        {
          temperature = rawvalue / 1677721.6f;
          break;
        }
        case 12:
        {
          temperature = rawvalue / 6710886.4f;
          break;
        }
        default:
        {
          temperature = Plugin_039_convert_two_complement(rawvalue, 19);


          temperature /= 128.0f;
          break;
        }
      }

      return temperature;
    }
  }
  else
  {

    return NAN;
  }
}

float readMax31865(struct EventStruct *event)
{
  P039_data_struct *P039_data = static_cast<P039_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (P039_data == nullptr) {
    return NAN;
  }

  uint8_t registers[MAX31865_NO_REG] = { 0 };
  uint16_t rawValue = 0u;

  int8_t CS_pin_no = get_SPI_CS_Pin(event);

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG))
  {
    String log;

    if ((log.reserve(80u))) {
      log = F("P039 : MAX31865 :");
      log += F(" P039_data->convReady: ");
      log += boolToString(P039_data->convReady);

      addLogMove(LOG_LEVEL_DEBUG, log);
    }
  }

  # endif




  if (P039_data->convReady) {
    rawValue = P039_data->conversionResult;
    registers[MAX31865_FAULT] = P039_data->deviceFaults;
  }


  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE))
  {
    String log;

    if ((log.reserve(160u))) {
      for (uint8_t i = 0u; i < MAX31865_NO_REG; ++i)
      {
        registers[i] = read8BitRegister(CS_pin_no, (MAX31865_READ_ADDR_BASE + i));
      }

      log = F("P039 : MAX31865 :");

      for (uint8_t i = 0u; i < MAX31865_NO_REG; ++i)
      {
        log += ' ';
        log += formatToHex_decimal(registers[i]);
      }

      addLogMove(LOG_LEVEL_DEBUG_MORE, log);
    }
  }

  # endif



  MAX31865_clearFaults(CS_pin_no);


  change8BitRegister(CS_pin_no,
                     (MAX31865_READ_ADDR_BASE + MAX31865_CONFIG),
                     (MAX31865_WRITE_ADDR_BASE + MAX31865_CONFIG),
                     MAX31865_SET_50HZ,
                     static_cast<bool>(P039_RTD_FILT_TYPE));



  MAX31865_setConType(CS_pin_no, P039_CONFIG_4);


  change8BitRegister(CS_pin_no,
                     (MAX31865_READ_ADDR_BASE + MAX31865_CONFIG),
                     (MAX31865_WRITE_ADDR_BASE + MAX31865_CONFIG),
                     MAX31865_SET_VBIAS_ON,
                     P039_SET);




  P039_data->timer = millis();



  Scheduler.setPluginTaskTimer(MAX31865_BIAS_WAIT_TIME, event->TaskIndex, MAX31865_BIAS_ON_STATE);

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE))
  {
    if (registers[MAX31865_FAULT])
    {
      String log;

      if ((log.reserve(210u))) {
        log = F("P039 : MAX31865 : ");

        log += F("Fault : ");
        log += formatToHex_decimal(registers[MAX31865_FAULT]);
        log += F(" :");

        if (registers[MAX31865_FAULT] & MAX31865_FAULT_OVUV)
        {
          log += F(" Under/Over voltage");
        }

        if (registers[MAX31865_FAULT] & MAX31865_FAULT_RTDINLOW)
        {
          log += F(" RTDIN- < 0.85 x Bias - FORCE- open");
        }

        if (registers[MAX31865_FAULT] & MAX31865_FAULT_REFINHIGH)
        {
          log += F(" REFIN- < 0.85 x Bias - FORCE- open");
        }

        if (registers[MAX31865_FAULT] & MAX31865_FAULT_REFINLOW)
        {
          log += F(" REFIN- > 0.85 x Bias");
        }

        if (registers[MAX31865_FAULT] & MAX31865_FAULT_LOWTHRESH)
        {
          log += F(" RTD Low Threshold");
        }

        if (registers[MAX31865_FAULT] & MAX31865_FAULT_HIGHTHRESH)
        {
          log += F(" RTD High Threshold");
        }
        addLogMove(LOG_LEVEL_DEBUG_MORE, log);
      }
    }
  }
  # endif


  bool ValueValid = false;

  if (registers[MAX31865_FAULT] == 0x00u) {
    ValueValid = true;
  }

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG))
  {
    String log;

    if ((log.reserve(85u))) {
      log = F("P039 : Temperature :");
      log += F(" registers[MAX31865_FAULT]: ");
      log += formatToHex_decimal(registers[MAX31865_FAULT]);
      log += F(" ValueValid: ");
      log += boolToString(ValueValid);
      addLogMove(LOG_LEVEL_DEBUG, log);
    }
  }

  # endif

  if (ValueValid)
  {
    rawValue >>= 1;

    float temperature = Plugin_039_convert_to_temperature(rawValue, getNomResistor(P039_RTD_TYPE), P039_RTD_RES);

    # ifndef BUILD_NO_DEBUG

    if (loglevelActiveFor(LOG_LEVEL_DEBUG))
    {
      String log;

      if ((log.reserve(110u))) {
        log = F("P039 : Temperature :");
        log += F(" rawValue: ");
        log += formatToHex_decimal(rawValue);
        log += F(" temperature: ");
        log += temperature;
        log += F(" P039_RTD_TYPE: ");
        log += P039_RTD_TYPE;
        log += F(" P039_RTD_RES: ");
        log += P039_RTD_RES;
        addLogMove(LOG_LEVEL_DEBUG, log);
      }
    }

    # endif


    temperature += P039_RTD_OFFSET;


    return temperature;
  }
  else
  {

    return NAN;
  }
}

void MAX31865_clearFaults(int8_t l_CS_pin_no)
{
  uint8_t l_reg = 0u;


  l_reg = read8BitRegister(l_CS_pin_no, (MAX31865_READ_ADDR_BASE + MAX31865_CONFIG));



  l_reg &= ~(MAX31865_SET_ONE_SHOT | MAX31865_FAULT_CTRL_MASK);
  l_reg |= MAX31865_CLEAR_FAULTS;


  write8BitRegister(l_CS_pin_no, (MAX31865_WRITE_ADDR_BASE + MAX31865_CONFIG), l_reg);
}

void MAX31865_setConType(int8_t l_CS_pin_no, uint8_t l_conType)
{
  bool l_set_reset = false;


  switch (l_conType)
  {
    case 0:
      l_set_reset = P039_RESET;
      break;
    case 1:
      l_set_reset = P039_SET;
      break;
    default:
      l_set_reset = P039_RESET;
      break;
  }


  change8BitRegister(l_CS_pin_no,
                     (MAX31865_READ_ADDR_BASE + MAX31865_CONFIG),
                     (MAX31865_WRITE_ADDR_BASE + MAX31865_CONFIG),
                     MAX31865_SET_3WIRE,
                     l_set_reset);
}
# 1467 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
float Plugin_039_convert_to_temperature(uint32_t l_rawvalue, float RTDnominal, float refResistor)
{
  # define RTD_A 3.9083e-3f
  # define RTD_B -5.775e-7f

  float Z1, Z2, Z3, Z4, Rt, temp;

  Rt = l_rawvalue;
  Rt /= 32768u;
  Rt *= refResistor;

  Z1 = -RTD_A;
  Z2 = RTD_A * RTD_A - (4 * RTD_B);
  Z3 = (4 * RTD_B) / RTDnominal;
  Z4 = 2 * RTD_B;

  temp = Z2 + (Z3 * Rt);
  temp = (sqrtf(temp) + Z1) / Z4;

  if (temp >= 0) {
    return temp;
  }

  Rt /= RTDnominal;
  Rt *= 100;

  float rpoly = Rt;

  temp = -242.02f;
  temp += 2.2228f * rpoly;
  rpoly *= Rt;
  temp += 2.5859e-3f * rpoly;
  rpoly *= Rt;
  temp -= 4.8260e-6f * rpoly;
  rpoly *= Rt;
  temp -= 2.8183e-8f * rpoly;
  rpoly *= Rt;
  temp += 1.5243e-10f * rpoly;

  return temp;
}

uint16_t getNomResistor(uint8_t l_RType)
{
  uint16_t l_returnValue = 100u;

  switch (l_RType)
  {
    case MAX31865_PT100:
      l_returnValue = 100u;
      break;
    case MAX31865_PT1000:
      l_returnValue = 1000u;
      break;
    default:
      l_returnValue = 100u;
      break;
  }
  return l_returnValue;
}

int Plugin_039_convert_two_complement(uint32_t value, int nr_bits) {
  const bool negative = (value & (1 << (nr_bits - 1))) != 0;
  int nativeInt;

  if (negative) {

    nativeInt = value | ~((1 << nr_bits) - 1);
  } else {
    nativeInt = value;
  }
  return nativeInt;
}

float readLM7x(struct EventStruct *event)
{
  float temperature = 0.0f;
  uint16_t device_id = 0u;
  uint16_t rawValue = 0u;

  int8_t CS_pin_no = get_SPI_CS_Pin(event);




  rawValue = readLM7xRegisters(CS_pin_no, P039_RTD_LM_TYPE, P039_RTD_LM_SHTDWN, &device_id);

  temperature = convertLM7xTemp(rawValue, P039_RTD_LM_TYPE);

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG))
  {
    String log;

    if ((log.reserve(130u))) {
      log = F("P039 : LM7x : readLM7x : ");
      log += F(" rawValue: ");
      log += formatToHex_decimal(rawValue);
      log += F(" device_id: ");
      log += formatToHex(device_id);
      log += F(" temperature: ");
      log += temperature;
      addLogMove(LOG_LEVEL_DEBUG, log);
    }
  }

  # endif

  return temperature;
}

float convertLM7xTemp(uint16_t l_rawValue, uint16_t l_LM7xsubtype)
{
  float l_returnValue = 0.0f;
  float l_lsbvalue = 0.0f;
  uint8_t l_noBits = 0u;
  int l_intTemperature = 0;

  switch (l_LM7xsubtype)
  {
    case LM7x_SD70:
      l_rawValue >>= 5;
      l_lsbvalue = 0.25f;
      l_noBits = 11u;
      break;
    case LM7x_SD71:
      l_rawValue >>= 2;
      l_lsbvalue = 0.03125f;
      l_noBits = 14u;
      break;
    case LM7x_SD74:
      l_rawValue >>= 3;
      l_lsbvalue = 0.0625f;
      l_noBits = 13u;
      break;
    case LM7x_SD121:
    case LM7x_SD122:
    case LM7x_SD123:
    case LM7x_SD124:
      l_rawValue >>= 4;
      l_lsbvalue = 0.0625f;
      l_noBits = 12u;
      break;
    case LM7x_SD125:
      l_rawValue >>= 5;
      l_lsbvalue = 0.25f;
      l_noBits = 10u;
      break;
    default:
      l_rawValue >>= 5;
      l_lsbvalue = 0.25f;
      l_noBits = 11u;
      break;
  }

  l_intTemperature = Plugin_039_convert_two_complement(l_rawValue, l_noBits);

  l_returnValue = l_intTemperature * l_lsbvalue;

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE))
  {
    String log;

    if ((log.reserve(185u))) {
      log = F("P039 : LM7x : convertLM7xTemp : ");
      log += F(" l_returnValue: ");
      log += formatToHex_decimal(l_returnValue);
      log += F(" l_LM7xsubtype: ");
      log += formatToHex_decimal(l_LM7xsubtype);
      log += F(" l_rawValue: ");
      log += formatToHex_decimal(l_rawValue);
      log += F(" l_noBits: ");
      log += l_noBits;
      log += F(" l_lsbvalue: ");
      log += l_lsbvalue;
      addLogMove(LOG_LEVEL_DEBUG_MORE, log);
    }
  }

  # endif

  return l_returnValue;
}

uint16_t readLM7xRegisters(int8_t l_CS_pin_no, uint8_t l_LM7xsubType, uint8_t l_runMode, uint16_t *l_device_id)
{
  uint16_t l_returnValue = 0u;
  uint16_t l_mswaitTime = 0u;


  switch (l_LM7xsubType)
  {
    case LM7x_SD70:
    case LM7x_SD71:
    case LM7x_SD74:
      l_mswaitTime = 300;
      break;
    case LM7x_SD121:
    case LM7x_SD122:
    case LM7x_SD123:
    case LM7x_SD124:
      l_mswaitTime = 320;
      break;
    case LM7x_SD125:
      l_mswaitTime = 100;
      break;
    default:
      l_mswaitTime = 500;
      break;
  }




  if (l_runMode)
  {

    uint8_t messageBuffer[12] = { 0xFF, 0xFF, 0xFF, 0X00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF };


    transfer_n_ByteSPI(l_CS_pin_no, 4, &messageBuffer[0]);


    delay(l_mswaitTime);


    transfer_n_ByteSPI(l_CS_pin_no, 8, &messageBuffer[4]);


    l_returnValue = ((messageBuffer[4] << 8) | messageBuffer[5]);


    *(l_device_id) = ((messageBuffer[8] << 8) | messageBuffer[9]);
# 1729 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
  }
  else
  {

    uint8_t messageBuffer[8] = { 0x00, 0x00, 0xFF, 0XFF, 0x00, 0x00, 0x00, 0x00 };

    transfer_n_ByteSPI(l_CS_pin_no, 8, &messageBuffer[0]);


    l_returnValue = ((messageBuffer[0] << 8) | messageBuffer[1]);


    *(l_device_id) = ((messageBuffer[4] << 8) | messageBuffer[5]);
# 1760 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
  }




  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE))
  {
    String log;

    if ((log.reserve(115u))) {
      log = F("P039 : LM7x : readLM7xRegisters : ");
      log += F(" l_returnValue: ");
      log += formatToHex_decimal(l_returnValue);
      log += F(" l_device_id: ");
      log += formatToHex(*(l_device_id));
      addLogMove(LOG_LEVEL_DEBUG_MORE, log);
    }
  }

  # endif

  return l_returnValue;
}
# 1814 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
int get_SPI_CS_Pin(struct EventStruct *event) {
  if (CONFIG_PIN1 != -1) {
    return CONFIG_PIN1;
  }
  return 15;
}
# 1832 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
void init_SPI_CS_Pin(int8_t l_CS_pin_no) {

  pinMode(l_CS_pin_no, OUTPUT);
}
# 1849 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
void handle_SPI_CS_Pin(int8_t l_CS_pin_no, bool l_state) {
  P039_CS_Delay();
  digitalWrite(l_CS_pin_no, l_state);
  P039_CS_Delay();
}
# 1868 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
void write8BitRegister(int8_t l_CS_pin_no, uint8_t l_address, uint8_t value)
{
  uint8_t l_messageBuffer[2] = { l_address, value };

  transfer_n_ByteSPI(l_CS_pin_no, 2, l_messageBuffer);

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE))
  {
    String log;

    if ((log.reserve(100u))) {
      log = F("P039 : SPI : write8BitRegister : ");
      log += F("l_address: ");
      log += formatToHex(l_address);
      log += F(" value: ");
      log += formatToHex_decimal(value);
      addLogMove(LOG_LEVEL_DEBUG_MORE, log);
    }
  }

  # endif
}
# 1906 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
void write16BitRegister(int8_t l_CS_pin_no, uint8_t l_address, uint16_t value)
{
  uint8_t l_messageBuffer[3] = { l_address, static_cast<uint8_t>((value >> 8) & 0xFF), static_cast<uint8_t>(value & 0xFF) };

  transfer_n_ByteSPI(l_CS_pin_no, 3, l_messageBuffer);

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE))
  {
    String log;

    if ((log.reserve(110u))) {
      log = F("P039 : SPI : write16BitRegister : ");
      log += F("l_address: ");
      log += formatToHex(l_address);
      log += F(" value: ");
      log += formatToHex_decimal(value);
      addLogMove(LOG_LEVEL_DEBUG_MORE, log);
    }
  }

  # endif
}
# 1943 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
uint8_t read8BitRegister(int8_t l_CS_pin_no, uint8_t l_address)
{
  uint8_t l_messageBuffer[2] = { l_address, 0x00 };

  transfer_n_ByteSPI(l_CS_pin_no, 2, l_messageBuffer);

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE))
  {
    String log;

    if ((log.reserve(100u))) {
      log = F("P039 : SPI : read8BitRegister : ");
      log += F("l_address: ");
      log += formatToHex(l_address);
      log += F(" returnvalue: ");
      log += formatToHex_decimal(l_messageBuffer[1]);
      addLogMove(LOG_LEVEL_DEBUG_MORE, log);
    }
  }

  # endif

  return l_messageBuffer[1];
}
# 1982 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
uint16_t read16BitRegister(int8_t l_CS_pin_no, uint8_t l_address)
{
  uint8_t l_messageBuffer[3] = { l_address, 0x00, 0x00 };
  uint16_t l_returnValue;

  transfer_n_ByteSPI(l_CS_pin_no, 3, l_messageBuffer);
  l_returnValue = ((l_messageBuffer[1] << 8) | l_messageBuffer[2]);

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE))
  {
    String log;

    if ((log.reserve(110u))) {
      log = F("P039 : SPI : read16BitRegister : ");
      log += F("l_address: ");
      log += formatToHex(l_address);
      log += F(" l_returnValue: ");
      log += formatToHex_decimal(l_returnValue);
      addLogMove(LOG_LEVEL_DEBUG_MORE, log);
    }
  }

  # endif

  return l_returnValue;
}
# 2025 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
void transfer_n_ByteSPI(int8_t l_CS_pin_no, uint8_t l_noBytesToSend, uint8_t *l_inoutMessageBuffer)
{

  handle_SPI_CS_Pin(l_CS_pin_no, LOW);

  for (size_t i = 0u; i < l_noBytesToSend; i++)
  {
    l_inoutMessageBuffer[i] = SPI.transfer(l_inoutMessageBuffer[i]);
  }


  handle_SPI_CS_Pin(l_CS_pin_no, HIGH);

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE))
  {
    String log;

    if ((log.reserve(120u))) {
      log = F("P039 : SPI : transfer_n_ByteSPI : ");

      for (uint8_t i = 0; i < l_noBytesToSend; ++i)
      {
        log += ' ';
        log += formatToHex_decimal(l_inoutMessageBuffer[i]);
      }
      addLogMove(LOG_LEVEL_DEBUG_MORE, log);
    }
  }

  # endif
}
# 2075 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
void change16BitRegister(int8_t l_CS_pin_no, uint8_t l_readaddress, uint8_t l_writeaddress, uint16_t l_flagmask, bool l_set_reset)
{
  uint16_t l_reg = 0u;


  l_reg = read16BitRegister(l_CS_pin_no, l_readaddress);

  if (l_set_reset) {
    l_reg |= l_flagmask;
  }
  else
  {
    l_reg &= ~(l_flagmask);
  }


  write16BitRegister(l_CS_pin_no, l_writeaddress, l_reg);
}
# 2110 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P039_Thermosensors.ino"
void change8BitRegister(int8_t l_CS_pin_no, uint8_t l_readaddress, uint8_t l_writeaddress, uint8_t l_flagmask, bool l_set_reset)
{
  uint8_t l_reg = 0u;


  l_reg = read8BitRegister(l_CS_pin_no, l_readaddress);



  if (l_set_reset) {
    l_reg |= l_flagmask;
  }
  else
  {
    l_reg &= ~(l_flagmask);
  }


  write8BitRegister(l_CS_pin_no, l_writeaddress, l_reg);
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P040_ID12.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P040






#define PLUGIN_040 
#define PLUGIN_ID_040 40
#define PLUGIN_NAME_040 "RFID - ID12LA/RDM6300"
#define PLUGIN_VALUENAME1_040 "Tag"

boolean Plugin_040_init = false;

boolean Plugin_040(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {

    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_040;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_ULONG;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = false;
        Device[deviceCount].ValueCount = 1;
        Device[deviceCount].SendDataOption = true;
        Device[deviceCount].TimerOption = false;
        Device[deviceCount].GlobalSyncOption = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_040);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_040));
        break;
      }

    case PLUGIN_INIT:
      {
        Plugin_040_init = true;
        ESPEASY_SERIAL_0.begin(9600);
        success = true;
        break;
      }

    case PLUGIN_TASKTIMER_IN:
      {
        if (Plugin_040_init) {

            UserVar.setSensorTypeLong(event->TaskIndex, 0);
            addLog(LOG_LEVEL_INFO, F("RFID : Removed Tag"));
            sendData(event);
            success = true;
        }
        break;
      }

    case PLUGIN_SERIAL_IN:
      {
        if (Plugin_040_init)
        {
          uint8_t val = 0;
          uint8_t code[6];
          uint8_t checksum = 0;
          uint8_t bytesread = 0;
          uint8_t tempbyte = 0;

          if ((val = ESPEASY_SERIAL_0.read()) == 2)
          {
            bytesread = 0;
            while (bytesread < 12) {
              if ( ESPEASY_SERIAL_0.available() > 0) {
                val = ESPEASY_SERIAL_0.read();
                if ((val == 0x0D) || (val == 0x0A) || (val == 0x03) || (val == 0x02)) {

                  break;
                }


                if (isDigit(val)) {
                  val = val - '0';
                }
                else if ((val >= 'A') && (val <= 'F')) {
                  val = 10 + val - 'A';
                }


                if ( (bytesread & 1) == 1) {


                  code[bytesread >> 1] = (val | (tempbyte << 4));

                  if (bytesread >> 1 != 5) {
                    checksum ^= code[bytesread >> 1];
                  };
                }
                else {
                  tempbyte = val;
                };
                bytesread++;
              }
            }
          }

          if (bytesread == 12)
          {
            if (code[5] == checksum)
            {

              taskIndex_t index = INVALID_TASK_INDEX;
              constexpr pluginID_t PLUGIN_ID_P040_ID12(PLUGIN_ID_040);

              for (taskIndex_t y = 0; y < TASKS_MAX; y++)
                if (Settings.getPluginID_for_task(y) == PLUGIN_ID_P040_ID12)
                  index = y;
              const deviceIndex_t DeviceIndex = getDeviceIndex_from_TaskIndex(index);
              if (!validDeviceIndex(DeviceIndex)) {
                break;
              }
              event->setTaskIndex(index);
              if (!validUserVarIndex(event->BaseVarIndex)) {
                break;
              }
              checkDeviceVTypeForTask(event);


              unsigned long key = 0, old_key = 0;
              old_key = UserVar.getSensorTypeLong(event->TaskIndex);
              for (uint8_t i = 1; i < 5; i++) key = key | (((unsigned long) code[i] << ((4 - i) * 8)));
              bool new_key = false;
              if (old_key != key) {
                UserVar.setSensorTypeLong(event->TaskIndex, key);
                new_key = true;
              }

              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log = F("RFID : ");
                if (new_key) {
                  log += F("New Tag: ");
                } else {
                  log += F("Old Tag: ");
                }
                log += key;
                addLogMove(LOG_LEVEL_INFO, log);
              }

              if (new_key) sendData(event);
              Scheduler.setPluginTaskTimer(500, event->TaskIndex, event->Par1);
            }
          }
          success = true;
        }
        break;
      }
  }
  return success;
}
#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P041_NeoClock.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P041
# 16 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P041_NeoClock.ino"
# include <NeoPixelBus_wrapper.h>


#define NUM_LEDS 114

uint8_t Plugin_041_red = 0;
uint8_t Plugin_041_green = 0;
uint8_t Plugin_041_blue = 0;

NeoPixelBus_wrapper *Plugin_041_pixels = nullptr;

#define PLUGIN_041 
#define PLUGIN_ID_041 41
#define PLUGIN_NAME_041 "Output - NeoPixel (Word Clock)"
#define PLUGIN_VALUENAME1_041 "Clock"
boolean Plugin_041(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_041;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_041);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_041));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("Data"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Red"), F("red"), PCONFIG(0), 0, 255);
      addFormNumericBox(F("Green"), F("green"), PCONFIG(1), 0, 255);
      addFormNumericBox(F("Blue"), F("blue"), PCONFIG(2), 0, 255);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("red"));
      PCONFIG(1) = getFormItemInt(F("green"));
      PCONFIG(2) = getFormItemInt(F("blue"));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      Plugin_041_red = PCONFIG(0);
      Plugin_041_green = PCONFIG(1);
      Plugin_041_blue = PCONFIG(2);

      if (Plugin_041_pixels == nullptr)
      {
        Plugin_041_pixels = new (std::nothrow) NeoPixelBus_wrapper(NUM_LEDS, CONFIG_PIN1, NEO_GRB + NEO_KHZ800);

        if (Plugin_041_pixels != nullptr) {
          Plugin_041_pixels->begin();
          Plugin_041_update();
        }
      }
      success = Plugin_041_pixels != nullptr;
      break;
    }

    case PLUGIN_EXIT:
    {
      if (Plugin_041_pixels != nullptr) {
        delete Plugin_041_pixels;
        Plugin_041_pixels = nullptr;
      }
      break;
    }

    case PLUGIN_CLOCK_IN:
    {
      Plugin_041_update();
      success = true;
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {





      success = true;
      break;
    }

    case PLUGIN_WRITE:
    {
      String cmd = parseString(string, 1);

      if (equals(cmd, F("neoclockcolor")))
      {
        Plugin_041_red = event->Par1;
        Plugin_041_green = event->Par2;
        Plugin_041_blue = event->Par3;
        Plugin_041_update();
        success = true;
      }

      if (equals(cmd, F("neotestall")))
      {
        for (int i = 0; i < NUM_LEDS; i++) {
          Plugin_041_pixels->setPixelColor(i, Plugin_041_pixels->Color(event->Par1, event->Par2, event->Par3));
        }
        Plugin_041_pixels->show();
        success = true;
      }

      if (equals(cmd, F("neotestloop")))
      {
        for (int i = 0; i < NUM_LEDS; i++)
        {
          resetAndBlack();
          Plugin_041_pixels->setPixelColor(i, Plugin_041_pixels->Color(event->Par1, event->Par2, event->Par3));
          Plugin_041_pixels->show();
          delay(200);
        }
        success = true;
      }

      break;
    }
  }
  return success;
}

void Plugin_041_update()
{
  uint8_t Hours = node_time.hour();
  uint8_t Minutes = node_time.minute();

  resetAndBlack();
  timeToStrip(Hours, Minutes);
  Plugin_041_pixels->show();
}

void resetAndBlack() {
  for (int i = 0; i < NUM_LEDS; i++) {
    Plugin_041_pixels->setPixelColor(i, Plugin_041_pixels->Color(0, 0, 0));
  }
}

void pushToStrip(int ledId) {
  Plugin_041_pixels->setPixelColor(ledId, Plugin_041_pixels->Color(Plugin_041_red, Plugin_041_green, Plugin_041_blue));
}

void timeToStrip(uint8_t hours, uint8_t minutes)
{
  pushIT_IS();


  if ((minutes >= 5) && (minutes < 10)) {
    pushFIVE1();
    pushAFTER();
  } else if ((minutes >= 10) && (minutes < 15)) {
    pushTEN1();
    pushAFTER();
  } else if ((minutes >= 15) && (minutes < 20)) {
    pushQUATER();
    pushAFTER();
  } else if ((minutes >= 20) && (minutes < 25)) {
    pushTEN1();
    pushFOR();
    pushHALF();
  } else if ((minutes >= 25) && (minutes < 30)) {
    pushFIVE1();
    pushFOR();
    pushHALF();
  } else if ((minutes >= 30) && (minutes < 35)) {
    pushHALF();
  } else if ((minutes >= 35) && (minutes < 40)) {
    pushFIVE1();
    pushAFTER();
    pushHALF();
  } else if ((minutes >= 40) && (minutes < 45)) {
    pushTEN1();
    pushAFTER();
    pushHALF();
  } else if ((minutes >= 45) && (minutes < 50)) {
    pushQUATER();
    pushFOR();
  } else if ((minutes >= 50) && (minutes < 55)) {
    pushTEN1();
    pushFOR();
  } else if ((minutes >= 55) && (minutes < 60)) {
    pushFIVE1();
    pushFOR();
  }

  int singleMinutes = minutes % 5;

  switch (singleMinutes) {
    case 1:
      pushM_ONE();
      break;
    case 2:
      pushM_ONE();
      pushM_TWO();
      break;
    case 3:
      pushM_ONE();
      pushM_TWO();
      pushM_THREE();
      break;
    case 4:
      pushM_ONE();
      pushM_TWO();
      pushM_THREE();
      pushM_FOUR();
      break;
  }

  if (hours >= 12) {
    hours -= 12;
  }

  if (hours == 12) {
    hours = 0;
  }

  if (minutes >= 20) {
    hours++;
  }


  switch (hours) {
    case 1:
      pushONE();
      break;
    case 2:
      pushTWO();
      break;
    case 3:
      pushTHREE();
      break;
    case 4:
      pushFOUR();
      break;
    case 5:
      pushFIVE2();
      break;
    case 6:
      pushSIX();
      break;
    case 7:
      pushSEVEN();
      break;
    case 8:
      pushEIGHT();
      break;
    case 9:
      pushNINE();
      break;
    case 10:
      pushTEN();
      break;
    case 11:
      pushELEVEN();
      break;
    case 0:
    case 12:
      pushTWELVE();
      break;
  }


  if (minutes < 5) {
    pushHOURE();
  }
}

void pushToStrip(const int *ids, size_t count) {
  for (size_t i = 0; i < count; ++i) {
    pushToStrip(ids[i]);
  }
}

void pushM_ONE() {
  pushToStrip(0);
}

void pushM_TWO() {
  pushToStrip(12);
}

void pushM_THREE() {
  pushToStrip(101);
}

void pushM_FOUR() {
  pushToStrip(113);
}

void pushIT_IS() {
  constexpr int ids[] = { 1, 2, 3, 5, 6 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushAFTER() {
  constexpr int ids[] = { 36, 37, 38, 39 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushQUATER() {
  constexpr int ids[] = { 30, 31, 32, 33, 34 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushFOR() {
  constexpr int ids[] = { 41, 42, 43, 44 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushHALF() {
  constexpr int ids[] = { 50, 51, 52, 53 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushONE() {
  constexpr int ids[] = { 63, 64, 65 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushTWO() {
  constexpr int ids[] = { 64, 65, 66, 67 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushTHREE() {
  constexpr int ids[] = { 109, 110, 111, 112 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushFOUR() {
  constexpr int ids[] = { 57, 58, 59, 60 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushFIVE1() {
  constexpr int ids[] = { 8, 9, 10, 11 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushFIVE2() {
  constexpr int ids[] = { 92, 93, 94, 95 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushSIX() {
  constexpr int ids[] = { 69, 88, 91 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushSEVEN() {
  constexpr int ids[] = { 69, 70, 71, 72, 73 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushEIGHT() {
  constexpr int ids[] = { 97, 98, 99, 100 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushNINE() {
  constexpr int ids[] = { 73, 74, 75, 76, 77 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushTEN() {
  constexpr int ids[] = { 54, 59, 76, 81 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushTEN1() {
  constexpr int ids[] = { 25, 26, 27, 28 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushELEVEN() {
  constexpr int ids[] = { 107, 108, 109 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushTWELVE() {
  constexpr int ids[] = { 82, 83, 84, 85, 86, 87 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushTWENTY() {
  constexpr int ids[] = { 16, 17, 18, 19, 20, 21, 22 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

void pushHOURE() {
  constexpr int ids[] = { 102, 103, 104 };
  constexpr size_t count = NR_ELEMENTS(ids);

  pushToStrip(ids, count);
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P042_Candle.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P042
# 66 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P042_Candle.ino"
# include "src/PluginStructs/P042_data_struct.h"

#define PLUGIN_042 
#define PLUGIN_ID_042 42
#define PLUGIN_NAME_042 "Output - NeoPixel (Candle)"
#define PLUGIN_VALUENAME1_042 "Color"
#define PLUGIN_VALUENAME2_042 "Brightness"
#define PLUGIN_VALUENAME3_042 "Type"

boolean Plugin_042(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;



  const __FlashStringHelper *_webVars[P042_WEBVAR_COUNT] =
  { F(P042_WEBVAR_RED_S),
    F(P042_WEBVAR_GREEN_S),
    F(P042_WEBVAR_BLUE_S),
    F(P042_WEBVAR_BRIGHTNESS_S),
    F(P042_WEBVAR_CANDLETYPE_S),
    F(P042_WEBVAR_COLORTYPE_S),
    F(P042_WEBVAR_PIXELCOUNT_S),
  };

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_042;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_042);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_042));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_042));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_042));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("Data"));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P042_CONFIG_PIXELCOUNT = P042_NUM_PIXEL;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      html_add_script_arg(F("src=\"jscolor.min.js\""), true);
      html_add_script_end();

      if (P042_CONFIG_PIXELCOUNT == 0) { P042_CONFIG_PIXELCOUNT = P042_NUM_PIXEL; }

      addFormNumericBox(F("Led Count"), P042_WEBVAR_PIXELCOUNT, P042_CONFIG_PIXELCOUNT, 1, P042_MAX_PIXELS);

      {
        const __FlashStringHelper *options[P042_FLAME_OPTIONS] = {
          F("Off"),
          F("Static Light"),
          F("Simple Candle"),
          F("Advanced Candle"),
          F("Police"),
          F("Blink"),
          F("Strobe"),
          F("Color Fader")
        };

        if (P042_CONFIG_CANDLETYPE > P042_FLAME_OPTIONS - 1) {
          P042_CONFIG_CANDLETYPE = 2;
        }


        addFormSelector(F("Flame Type"), P042_WEBVAR_CANDLETYPE, P042_FLAME_OPTIONS, options, nullptr, P042_CONFIG_CANDLETYPE);
      }


      P042_ColorType Candle_color = static_cast<P042_ColorType>(P042_CONFIG_COLORTYPE);
      addRowLabel(F("Color Handling"));
      addHtml(F("<input type='radio' id='clrDef' name='" P042_WEBVAR_COLORTYPE_S "' value='0'"));

      if (Candle_color == P042_ColorType::ColorDefault) {
        addHtml(F(" checked>"));
      } else {
        addHtml('>');
      }
      addHtml(F("<label for='clrDef'> Use default color</label><br>"));
      addHtml(F("<input type='radio' id='clrSel' name='" P042_WEBVAR_COLORTYPE_S "' value='1'"));

      if (Candle_color == P042_ColorType::ColorSelected) {
        addHtml(F(" checked>"));
      } else {
        addHtml('>');
      }
      addHtml(F("<label for='clrSel'> Use selected color</label><br>"));


      addRowLabel(F("Color"));
      addHtml(F("<input data-jscolor=\"{onInput:'update(this)',position:'top',value:'#"));
      addHtml(formatToHex_no_prefix(P042_CONFIG_RED, 2));
      addHtml(formatToHex_no_prefix(P042_CONFIG_GREEN, 2));
      addHtml(formatToHex_no_prefix(P042_CONFIG_BLUE, 2));
      addHtml(F("'}\">"));
      addFormNumericBox(F("RGB Color"), P042_WEBVAR_RED, P042_CONFIG_RED, 0, 255);
      addNumericBox(P042_WEBVAR_GREEN, P042_CONFIG_GREEN, 0, 255);
      addNumericBox(P042_WEBVAR_BLUE, P042_CONFIG_BLUE, 0, 255);


      addRowLabel(F("Brightness"));
      addHtml(F("min<input type='range' id='" P042_OTHVAR_BRIGHTNESSSLIDE_S "' min='0' max='255' value='"));
      addHtmlInt(P042_CONFIG_BRIGHTNESS);
      addHtml(F("'> max"));

      {
        addFormNumericBox(F("Brightness Value"), P042_WEBVAR_BRIGHTNESS, P042_CONFIG_BRIGHTNESS, 0, 255);
      }
# 212 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P042_Candle.ino"
      html_add_script(false);
      addHtml(F("function update(e){document.getElementById('" P042_WEBVAR_RED_S
                "').value=Math.round(e.channel('R')),"
                "document.getElementById('" P042_WEBVAR_GREEN_S
                "').value=Math.round(e.channel('G')),"
                "document.getElementById('" P042_WEBVAR_BLUE_S
                "').value=Math.round(e.channel('B'))}"));
# 227 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P042_Candle.ino"
      addHtml(F("window.addEventListener('load',function(){document.getElementById('" P042_OTHVAR_BRIGHTNESSSLIDE_S
                "').addEventListener('input',function(){document.getElementById('" P042_WEBVAR_BRIGHTNESS_S
                "').value=this.value})})"));
      html_add_script_end();

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      for (int p = 0; p < P042_WEBVAR_COUNT; p++) {
        PCONFIG(p) = getFormItemInt(_webVars[p]);
      }

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P042_data_struct());
      P042_data_struct *P042_data = static_cast<P042_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P042_data) {
        success = P042_data->plugin_init(event);
      }

      break;
    }

    case PLUGIN_EXIT:
    {
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P042_data_struct *P042_data = static_cast<P042_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P042_data) {
        success = P042_data->plugin_once_a_second(event);
      }

      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P042_data_struct *P042_data = static_cast<P042_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P042_data) {
        success = P042_data->plugin_fifty_per_second(event);
      }

      break;
    }

    case PLUGIN_READ:
    {
      P042_data_struct *P042_data = static_cast<P042_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P042_data) {
        success = P042_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_WRITE:
    {
      P042_data_struct *P042_data = static_cast<P042_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P042_data) {
        success = P042_data->plugin_write(event, string);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P043_ClkOutput.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P043
# 46 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P043_ClkOutput.ino"
# include "src/Helpers/StringGenerator_Web.h"

#define PLUGIN_043 
#define PLUGIN_ID_043 43
#define PLUGIN_NAME_043 "Output - Clock"
#define PLUGIN_VALUENAME_043 "Output"

#define P043_SIMPLE_VALUE PCONFIG(6)
#define P043_MAX_SETTINGS PCONFIG(7)
#define P043_DEFAULT_MAX 8
#define P043_SENSOR_TYPE_INDEX 2
#define P043_NR_OUTPUT_VALUES getValueCountFromSensorType(static_cast<Sensor_VType>(PCONFIG(P043_SENSOR_TYPE_INDEX)))


boolean Plugin_043(uint8_t function, struct EventStruct *event, String& string)
{
  # ifndef LIMIT_BUILD_SIZE
  const String weekDays = F("AllSunMonTueWedThuFriSatWrkWkd");
  # endif
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_043;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_043);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      ExtraTaskSettings.populateDeviceValueNamesSeq(F("Output"), P043_NR_OUTPUT_VALUES, 2, false);
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P043_MAX_SETTINGS = P043_DEFAULT_MAX;
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P043_NR_OUTPUT_VALUES;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(P043_SENSOR_TYPE_INDEX));
      event->idx = P043_SENSOR_TYPE_INDEX;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("Clock Event"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      if (P043_MAX_SETTINGS == 0) { P043_MAX_SETTINGS = P043_DEFAULT_MAX; }
      addFormNumericBox(F("Nr. of Day,Time fields"), F("vcount"), P043_MAX_SETTINGS, 1, PLUGIN_EXTRACONFIGVAR_MAX);
      addUnit(concat(F("1.."), PLUGIN_EXTRACONFIGVAR_MAX));

      addFormCheckBox(F("Value input On/Off only"), F("simpl"), P043_SIMPLE_VALUE == 1);
      # ifndef LIMIT_BUILD_SIZE
      addFormNote(F("Page will be updated after Submit"));
      # endif

      const __FlashStringHelper *options[] = {
        F(""),
        F("Off"),
        F("On"),
      };
      constexpr int optionsCount = NR_ELEMENTS(options);

      # ifndef LIMIT_BUILD_SIZE
      const unsigned int daysCount = weekDays.length() / 3;
      String days[daysCount];

      for (unsigned int n = 0; n < weekDays.length() / 3u; ++n) {
        days[n] = weekDays.substring(n * 3, n * 3 + 3);
      }

      datalistStart(F("timepatternlist"));
      datalistAddValue(F("00:00"));
      datalistAddValue(F("%sunrise%"));
      datalistAddValue(F("%sunset%"));
      datalistFinish();
      # endif

      for (int x = 0; x < P043_MAX_SETTINGS; x++)
      {
        const String timeStr = timeLong2String(Cache.getTaskDevicePluginConfigLong(event->TaskIndex, x));
        # ifndef LIMIT_BUILD_SIZE
        addRowLabel(concat(F("Day,Time "), x + 1));
        int thisDay = weekDays.indexOf(timeStr.substring(0, 3));

        if (thisDay > 0) { thisDay /= 3; }
        addSelector(concat(F("day"), x), daysCount, days, nullptr, nullptr, thisDay, false, true, F(""));
        addHtml(',');
        addTextBox(concat(F("clock"), x),
                   parseString(timeStr, 2), 32
                   , false, false, EMPTY_STRING, F("")
                   # if FEATURE_TOOLTIPS
                   , EMPTY_STRING
                   # endif
                   , F("timepatternlist"));
        # else
        addFormTextBox(concat(F("Day,Time "), x + 1),
                       concat(F("clock"), x),
                       timeStr, 32);
        # endif

        if (validGpio(CONFIG_PIN1) || (P043_SIMPLE_VALUE == 1)) {
          addHtml(' ');
          const uint8_t choice = Cache.getTaskDevicePluginConfig(event->TaskIndex, x);
          addSelector(concat(F("state"), x), optionsCount, options, nullptr, nullptr, choice);
        }
        else {
          addHtml(strformat(F("Value %d:"), x + 1));
          addNumericBox(concat(F("state"), x),
                        Cache.getTaskDevicePluginConfig(event->TaskIndex, x), INT_MIN, INT_MAX);
        }
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P043_MAX_SETTINGS = getFormItemInt(F("vcount"));
      P043_SIMPLE_VALUE = isFormItemChecked(F("simpl")) ? 1 : 0;

      for (int x = 0; x < P043_MAX_SETTINGS; x++)
      {
        String plugin1;
        # ifndef LIMIT_BUILD_SIZE
        const int day = getFormItemInt(concat(F("day"), x));
        plugin1 = strformat(F("%s,%s"), weekDays.substring(day * 3, day * 3 + 3).c_str(), webArg(concat(F("clock"), x)).c_str());
        # else
        plugin1 = webArg(concat(F("clock"), x));
        # endif
        ExtraTaskSettings.TaskDevicePluginConfigLong[x] = string2TimeLong(plugin1);
        const String plugin2 = webArg(concat(F("state"), x));
        ExtraTaskSettings.TaskDevicePluginConfig[x] = plugin2.toInt();
      }
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = true;
      break;
    }

    case PLUGIN_CLOCK_IN:
    {
      if (P043_MAX_SETTINGS == 0) { P043_MAX_SETTINGS = P043_DEFAULT_MAX; }

      unsigned long clockEvent = (unsigned long)node_time.minute() % 10
                                 | (unsigned long)(node_time.minute() / 10) << 4
                                 | (unsigned long)(node_time.hour() % 10) << 8
                                 | (unsigned long)(node_time.hour() / 10) << 12
                                 | (unsigned long)node_time.weekday() << 16;

      for (uint8_t x = 0; x < P043_MAX_SETTINGS; x++)
      {
        unsigned long clockSet = Cache.getTaskDevicePluginConfigLong(event->TaskIndex, x);

        # ifndef PLUGIN_BUILD_MINIMAL_OTA

        if (bitRead(clockSet, 28) || bitRead(clockSet, 29)) {
          String specialTime = timeLong2String(clockSet);

          parseSystemVariables(specialTime, false);
          clockSet = string2TimeLong(specialTime);
        }
        # endif

        if (matchClockEvent(clockEvent, clockSet))
        {
          uint8_t state = Cache.getTaskDevicePluginConfig(event->TaskIndex, x);

          if (state != 0)
          {
            const bool hasGpio = validGpio(CONFIG_PIN1);

            if (hasGpio || (P043_SIMPLE_VALUE == 1)) {
              state--;

              if (hasGpio) {
                pinMode(CONFIG_PIN1, OUTPUT);
                digitalWrite(CONFIG_PIN1, state);
              }
              UserVar.setFloat(event->TaskIndex, 0, state);
            }
            else {
              UserVar.setFloat(event->TaskIndex, 0, x + 1);
              UserVar.setFloat(event->TaskIndex, 1, state);
            }

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              addLog(LOG_LEVEL_INFO, strformat(F("TCLK : State %d"), state));
            }
            sendData(event);
          }
        }
      }
      break;
    }

    case PLUGIN_SET_CONFIG:
    {
      const String cmd = parseString(string, 1);


      if (equals(cmd, F("settime"))) {
        String para = parseString(string, 2);
        int32_t timeIndex = 0;

        if (validIntFromString(para, timeIndex) && (timeIndex > 0) && (timeIndex <= P043_MAX_SETTINGS)) {
          para = parseString(string, 3);
          String para4 = parseString(string, 4);
          const String para5 = parseString(string, 5);
          int32_t value = INT_MIN;

          if ((para.length() == 3) && !para4.isEmpty() && !para5.isEmpty()) {

            para += ',';
            para += para4;
            para4 = para5;
          }

          # ifndef BUILD_NO_DEBUG
          addLog(LOG_LEVEL_DEBUG, concat(F("P043: Time received "), para));
          # endif

          para.replace('$', '%');

          LoadTaskSettings(event->TaskIndex);

          ExtraTaskSettings.TaskDevicePluginConfigLong[timeIndex - 1] = string2TimeLong(para);

          if (validIntFromString(para4, value)) {
            if (validGpio(CONFIG_PIN1) || (P043_SIMPLE_VALUE == 1)) { value++; }

            ExtraTaskSettings.TaskDevicePluginConfig[timeIndex - 1] = value;
          }

          Cache.updateExtraTaskSettingsCache();
          SaveTaskSettings(event->TaskIndex);


          # ifndef BUILD_NO_DEBUG
          addLog(LOG_LEVEL_DEBUG, strformat(F("P043: Time received %s, value %d, stored %s, long: %d"), para.c_str(), value,
                                            timeLong2String(ExtraTaskSettings.TaskDevicePluginConfigLong[timeIndex - 1]).c_str(),
                                            string2TimeLong(para)));
          # endif
          success = true;
        }
      }
      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      # define P043_GETTIME_LENGTH 7u
      # define P043_GETVALUE_LENGTH 8u
      const String cmd = parseString(string, 1);
      unsigned int idx = 0u;
      int32_t timeIndex = -1;

      if (cmd.startsWith(F("gettime"))) {
        idx = P043_GETTIME_LENGTH;
      } else
      if (cmd.startsWith(F("getvalue"))) {
        idx = P043_GETVALUE_LENGTH;
      }

      if ((idx > 0) && validIntFromString(cmd.substring(idx), timeIndex) &&
          (timeIndex > 0) && (timeIndex <= P043_MAX_SETTINGS)) {
        LoadTaskSettings(event->TaskIndex);

        if (idx == P043_GETTIME_LENGTH) {
          string = timeLong2String(ExtraTaskSettings.TaskDevicePluginConfigLong[timeIndex - 1]);
        } else {
          const int16_t offset = (validGpio(CONFIG_PIN1) || (P043_SIMPLE_VALUE == 1)) ? 1 : 0;
          string = ExtraTaskSettings.TaskDevicePluginConfig[timeIndex - 1] - offset;
        }
        success = true;
      }
      # undef P043_GETTIME_LENGTH
      # undef P043_GETVALUE_LENGTH
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P044_P1WifiGateway.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P044_ORG
# 21 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P044_P1WifiGateway.ino"
# include "src/Helpers/_Plugin_Helper_serial.h"
# include "src/PluginStructs/P044_data_struct.h"
# include <ESPeasySerial.h>

#define PLUGIN_044 
#define PLUGIN_ID_044 44
#define PLUGIN_NAME_044 "Communication - P1 Wifi Gateway"


boolean Plugin_044(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_044;
      Device[deviceCount].Type = DEVICE_TYPE_CUSTOM2;
      Device[deviceCount].Custom = true;
      Device[deviceCount].TimerOption = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_044);
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P044_LED_PIN = P044_STATUS_LED;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      string = concat(F("RST: "), formatGpioLabel(P044_RESET_TARGET_PIN, false));
      string += event->String1;
      string += concat(F("LED: "), formatGpioLabel((P044_LED_ENABLED & 0x7f) == 0 ? P044_LED_PIN : -1, false));

      if ((P044_LED_INVERTED == 1) && ((P044_LED_ENABLED & 0x7f) == 0)) {
        string += F(" (inv)");
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      # ifdef USES_P020
      String msg;
      msg.reserve(132);
      msg += F("This plugin is deprecated and will be removed in a future release. Please use P020 - ");
      msg += getPluginNameFromPluginID(20);
      addFormNote(msg);
      # endif
      LoadTaskSettings(event->TaskIndex);

      {
        addFormSubHeader(F("Serial"));

        uint8_t serialConfChoice = serialHelper_convertOldSerialConfig(P044_SERIAL_CONFIG);
        serialHelper_serialconfig_webformLoad(event, serialConfChoice);

        addFormNumericBox(F("Baud Rate"), F("pbaud"), P044_GET_BAUDRATE, 0, 115200);
      }

      {
        addFormSubHeader(F("Device"));

        addFormNumericBox(F("TCP Port"), F("pport"), P044_GET_WIFI_SERVER_PORT, 0, 65535);
        # ifndef LIMIT_BUILD_SIZE
        addUnit(F("0..65535"));
        # endif


        addFormPinSelect(PinSelectPurpose::Generic, F("Reset target after boot"), F("taskdevicepin1"), P044_RESET_TARGET_PIN);

        addFormNumericBox(F("RX Receive Timeout (mSec)"), F("prxwait"), P044_RX_WAIT, 0);
      }

      {
        addFormSubHeader(F("Led"));

        addFormCheckBox(F("Led enabled"), F("pled"), (P044_LED_ENABLED & 0x7f) == 0);
        addFormPinSelect(PinSelectPurpose::Generic, F("Led pin"), F("taskdevicepin2"), P044_LED_PIN);
        addFormCheckBox(F("Led inverted"), F("pledinv"), P044_LED_INVERTED == 1);
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P044_SET_WIFI_SERVER_PORT = getFormItemInt(F("pport"));
      P044_SET_BAUDRATE = getFormItemInt(F("pbaud"));
      P044_RX_WAIT = getFormItemInt(F("prxwait"));
      P044_LED_ENABLED = 0x80 + (isFormItemChecked(F("pled")) ? 0 : 1);

      P044_LED_INVERTED = isFormItemChecked(F("pledinv")) ? 1 : 0;
      P044_SERIAL_CONFIG = serialHelper_serialconfig_webformSave();

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      if (((P044_LED_ENABLED & 0x7f) == 1) && (P044_LED_PIN != -1)) {
        pinMode(P044_LED_PIN, OUTPUT);
        digitalWrite(P044_LED_PIN, P044_LED_INVERTED == 1 ? 1 : 0);
      }

      LoadTaskSettings(event->TaskIndex);

      if ((P044_GET_WIFI_SERVER_PORT == 0) || (P044_GET_BAUDRATE == 0)) {
        clearPluginTaskData(event->TaskIndex);
        break;
      }


      P044_Task *task = static_cast<P044_Task *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != task) && task->isInit()) {


      } else {
        initPluginTaskData(event->TaskIndex, new (std::nothrow) P044_Task(event));
        task = static_cast<P044_Task *>(getPluginTaskData(event->TaskIndex));
      }

      if (nullptr == task) {
        break;
      }

      int rxPin;
      int txPin;


      ESPeasySerialType::getSerialTypePins(ESPEasySerialPort::serial0, rxPin, txPin);
      uint8_t serialconfig = serialHelper_convertOldSerialConfig(P044_SERIAL_CONFIG);
      task->serialBegin(ESPEasySerialPort::not_set, rxPin, txPin, P044_GET_BAUDRATE, serialconfig);
      task->startServer(P044_GET_WIFI_SERVER_PORT);

      if (!task->isInit()) {
        clearPluginTaskData(event->TaskIndex);
        break;
      }

      if (validGpio(P044_RESET_TARGET_PIN)) {
        pinMode(P044_RESET_TARGET_PIN, OUTPUT);
        digitalWrite(P044_RESET_TARGET_PIN, LOW);
        delay(500);
        digitalWrite(P044_RESET_TARGET_PIN, HIGH);
        pinMode(P044_RESET_TARGET_PIN, INPUT_PULLUP);
      }

      task->blinkLED();

      if (P044_GET_BAUDRATE == 115200) {
        # ifndef BUILD_NO_DEBUG
        addLog(LOG_LEVEL_DEBUG, F("P1   : DSMR version 5 meter, CRC on"));
        # endif
        task->CRCcheck = true;
      } else {
        # ifndef BUILD_NO_DEBUG
        addLog(LOG_LEVEL_DEBUG, F("P1   : DSMR version 4 meter, CRC off"));
        # endif
        task->CRCcheck = false;
      }

      success = true;
      break;
    }

    case PLUGIN_EXIT:
    {
      P044_Task *task = static_cast<P044_Task *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != task) {
        task->stopServer();
        task->serialEnd();
      }

      success = true;
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P044_Task *task = static_cast<P044_Task *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != task) {
        task->checkServer();
        success = true;
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P044_Task *task = static_cast<P044_Task *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != task) {
        if (task->hasClientConnected()) {
          task->discardClientIn();
        }
        task->checkBlinkLED();
        success = true;
      }
      break;
    }

    case PLUGIN_SERIAL_IN:
    {
      P044_Task *task = static_cast<P044_Task *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != task) {
        if (task->hasClientConnected()) {
          task->handleSerialIn(event);
        } else {
          task->discardSerialIn();
        }
        success = true;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P045_MPU6050.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P045
# 67 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P045_MPU6050.ino"
# include "src/PluginStructs/P045_data_struct.h"

#define PLUGIN_045 
#define PLUGIN_ID_045 45
#define PLUGIN_NAME_045 "Gyro - MPU 6050"
#define PLUGIN_VALUENAME1_045 ""


boolean Plugin_045(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_045;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_045);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_045));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x68, 0x69 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, PCONFIG(0));
        addFormNote(F("ADDR Low=0x68, High=0x69"));
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      uint8_t choice = PCONFIG(1);
      {
        const __FlashStringHelper *options[10] = {
          F("Movement detection"),
          F("Range acceleration X"),
          F("Range acceleration Y"),
          F("Range acceleration Z"),
          F("Acceleration X"),
          F("Acceleration Y"),
          F("Acceleration Z"),
          F("G-force X"),
          F("G-force Y"),
          F("G-force Z")
        };
        addFormSelector(F("Function"), F("pfunction"), 10, options, nullptr, choice);
      }

      if (choice == 0) {



        addFormNumericBox(F("Detection threshold X"), F("pthld_x"), PCONFIG(2), 0, 65535);
        addFormNumericBox(F("Detection threshold Y"), F("pthld_y"), PCONFIG(3), 0, 65535);
        addFormNumericBox(F("Detection threshold Z"), F("pthld_z"), PCONFIG(4), 0, 65535);
        addFormNote(F("A Detection threshold value of 0 disables movement detection for that axis."));

        addFormCheckBox(F("Detection on all 3 axes"), F("pmultiaxes"), PCONFIG_LONG(2) == 0);
        addFormNote(F("When unchecked, movement detection will trigger on ANY axis"));

        addFormNumericBox(F("Min. detection count"), F("pthld_counter"), PCONFIG(5), 0, 999999);
        addFormNumericBox(F("Detection window"), F("pthld_window"), PCONFIG(6), 0, 999999);

        addFormNote(F("Details are in the 'ReadTheDocs' documentation."));
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {

      PCONFIG(0) = getFormItemInt(F("i2c_addr"));
      PCONFIG(1) = getFormItemInt(F("pfunction"));
      PCONFIG(2) = getFormItemInt(F("pthld_x"));
      PCONFIG(3) = getFormItemInt(F("pthld_y"));
      PCONFIG(4) = getFormItemInt(F("pthld_z"));
      PCONFIG(5) = getFormItemInt(F("pthld_counter"));
      PCONFIG(6) = getFormItemInt(F("pthld_window"));
      PCONFIG_LONG(2) = isFormItemChecked(F("pmultiaxes")) ? 0 : 1;

      if (PCONFIG(6) < PCONFIG(5)) {
        PCONFIG(6) = PCONFIG(5);
      }
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {

      uint8_t devAddr = PCONFIG(0);

      if ((devAddr < 0x68) || (devAddr > 0x69)) {
        devAddr = 0x68;
        PCONFIG(0) = devAddr;
      }

      initPluginTaskData(event->TaskIndex, new (std::nothrow) P045_data_struct(devAddr));
      P045_data_struct *P045_data =
        static_cast<P045_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P045_data) {
        P045_data->init();
        success = true;
      }


      PCONFIG(7) = 0;
      UserVar.setFloat(event->TaskIndex, 0, 0);
      PCONFIG_LONG(0) = 0;
      PCONFIG_LONG(1) = 0;
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P045_data_struct *P045_data =
        static_cast<P045_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P045_data) {
        P045_data->loop();
        success = true;
      }
      break;
    }

    case PLUGIN_READ:
    {

      const P045_data_struct *P045_data =
        static_cast<const P045_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P045_data) {
        int _P045_Function = PCONFIG(1);

        switch (_P045_Function)
        {

          case 0:
          {

            bool thresexceed = true;
            uint8_t count = 0;
            uint8_t threscount = 0;

            for (uint8_t i = 0; i < 3; i++)
            {

              if (PCONFIG(i + 2) != 0) {
                if (P045_data->_axis[i][2] >= PCONFIG(i + 2)) { threscount++; }
              } else { count++; }
            }

            if (PCONFIG_LONG(2) == 0) {
              thresexceed = ((threscount > 0) && (count + threscount == 3));
            } else {
              thresexceed = threscount > 0;
            }

            if (count == 3) { thresexceed = false; }


            if (thresexceed) { PCONFIG_LONG(0)++; }


            PCONFIG_LONG(1)++;

            if (PCONFIG_LONG(1) >= PCONFIG(6)) {

              PCONFIG_LONG(1) = 0;


              if (PCONFIG_LONG(0) >= PCONFIG(5)) {
                UserVar.setFloat(event->TaskIndex, 0, 1);
              } else {
                UserVar.setFloat(event->TaskIndex, 0, 0);
              }


              if (PCONFIG(7) != UserVar[event->BaseVarIndex]) {
                PCONFIG(7) = UserVar[event->BaseVarIndex];
                success = true;
              } else {
                success = false;
              }
              PCONFIG_LONG(0) = 0;
            }



            event->sensorType = Sensor_VType::SENSOR_TYPE_SWITCH;
            break;
          }


          default:
          {
            uint8_t reqaxis = (_P045_Function - 1) % 3;
            uint8_t reqvar = ((_P045_Function - 1) / 3) + 2;
            UserVar.setFloat(event->TaskIndex, 0, float(P045_data->_axis[reqaxis][reqvar]));
            success = true;
            break;
          }
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P046_VentusW266.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P046
# 89 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P046_VentusW266.ino"
#define PLUGIN_046_DEBUG true

#define PLUGIN_046 
#define PLUGIN_ID_046 46
#define PLUGIN_NAME_046 "Hardware - Ventus W266"
#define PLUGIN_VALUENAME1_046 ""
#define PLUGIN_VALUENAME2_046 ""
#define PLUGIN_VALUENAME3_046 ""

#define Plugin_046_MagicByte 0x7F
#define Plugin_046_RAW_BUFFER_SIZE 24
#define Plugin_046_Payload 23

struct P046_data_struct {
  int8_t Plugin_046_MOSIpin = -1;
  int8_t Plugin_046_SCLKpin = -1;
  int8_t Plugin_046_nSELpin = -1;
  int8_t Plugin_046_MISOpin = -1;

  uint8_t Plugin_046_ISR_Buffer[Plugin_046_RAW_BUFFER_SIZE];

  uint8_t Plugin_046_databuffer[Plugin_046_RAW_BUFFER_SIZE];
  bool Plugin_046_ReceiveActive = false;
  bool Plugin_046_MasterSlave = false;
  bool Plugin_046_newData = false;
  uint8_t Plugin_046_bitpointer;
  uint8_t Plugin_046_bytepointer;
  uint8_t Plugin_046_receivedData;

};

#include "./ESPEasy-Globals.h"

P046_data_struct* P046_data = nullptr;




volatile unsigned long Plugin_046_lastrainctr;
volatile int Plugin_046_lastraincount;
volatile float Plugin_046_rainmmph = 0;
volatile unsigned long Plugin_046_laststrikectr;
volatile unsigned int Plugin_046_laststrikecount;
volatile int Plugin_046_strikesph = 0;



void Plugin_046_ISR_nSEL() IRAM_ATTR;
void Plugin_046_ISR_SCLK() IRAM_ATTR;

boolean Plugin_046(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_046;
        Device[deviceCount].Type = DEVICE_TYPE_DUMMY;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = true;
        Device[deviceCount].SendDataOption = true;
        Device[deviceCount].ValueCount = 3;
        break;
      }

    case PLUGIN_WEBFORM_LOAD:
      {
        uint8_t choice = PCONFIG(0);
        {
          const uint8_t nrchoices = 9;
          const __FlashStringHelper * options[nrchoices] = {
            F("Main + Temp/Hygro"),
            F("Wind"),
            F("Rain"),
            F("UV"),
            F("Lightning strikes"),
            F("Lightning distance"),

            F("Unknown 1, uint8_t 6"),
            F("Unknown 2, uint8_t 16"),
            F("Unknown 3, uint8_t 19"),
          };

          addFormSelector(F("Plugin function"), F("p046"), nrchoices, options, nullptr, choice, true);
          addFormNote(F("Changing the function will reload this page."));
        }

        if (choice==0) {
          addFormPinSelect(PinSelectPurpose::SPI, F("1st GPIO (5-MOSI)"), F("taskdevicepin1"), PCONFIG(1));
          addFormPinSelect(PinSelectPurpose::SPI, F("2nd GPIO (6-SCLK)"), F("taskdevicepin2"), PCONFIG(2));
          addFormPinSelect(PinSelectPurpose::SPI, F("3rd GPIO (7-nSEL)"), F("taskdevicepin3"), PCONFIG(3));
          addFormPinSelect(PinSelectPurpose::SPI, F("4th GPIO (8-MISO)"), F("taskdeviceport"), PCONFIG(4));
        }

        switch (choice)
        {
          case (0):
          {
            addHtml(F("<TR><TD><B>Be sure you only have 1 main plugin!</B></TD>"));
            addHtml(F("<TR><TD>Value 1: Temperature, 1 decimal<BR>Value 2: Humidity, 0 decimals"));
            addHtml(F("<BR>Value 3: not used</TD>"));
            break;
          }
          case (1):
          {
            addHtml(F("<TR><TD>Value 1: Direction, 0 decimals<BR>"));
            addHtml(F("Value 2: Average, 1 decimal<Br>Value 3: Gust, 1 decimal</TD>"));
            break;
          }
          case (2):
          {
            addHtml(F("<TR><TD>Value 1: Rain in mm per hour<BR>Value 2: Total rain in mm"));
            addHtml(F("<BR>Value 3: not used</TD>"));
            break;
          }
          case (3):
          {
            addHtml(F("<TR><TD>Value 1: UV, 1 decimal"));
            addHtml(F("<BR>Values 2, 3</TD>"));
            break;
          }
          case (4):
          {
            addHtml(F("<TR><TD>Value 1: Strikes this hour, 0 decimals"));
            addHtml(F("<BR>Values 2, 3: not used</TD>"));
            break;
          }
          case (5):
          {
            addHtml(F("<TR><TD>Value 1: Distance in km, 0 decimals"));
            addHtml(F("<BR>Values 2, 3: not used</TD>"));
            break;
          }
          case (6):
          {
            addHtml(F("<TR><TD>Value 1: Batterybyte, 0 decimals"));
            addHtml(F("<BR>Values 2, 3: not used</TD>"));
            break;
          }
          case (7):
          {
            addHtml(F("<TR><TD>Value 1: Last rainbyte, 0 decimals"));
            addHtml(F("<BR>Values 2, 3: not used</TD>"));
            break;
          }
          case (8):
          {
            addHtml(F("<TR><TD>Value 1: Last lightningbyte, 0 decimals"));
            addHtml(F("<BR>Values 2, 3: not used</TD>"));
            break;
          }
        }

        success = true;
        break;
      }

    case PLUGIN_WEBFORM_SAVE:
      {
        PCONFIG(0) = getFormItemInt(F("p046"));
        if (PCONFIG(0) == 0) {
          PCONFIG(1) = getFormItemInt(F("taskdevicepin1"));
          PCONFIG(2) = getFormItemInt(F("taskdevicepin2"));
          PCONFIG(3) = getFormItemInt(F("taskdevicepin3"));
          PCONFIG(4) = getFormItemInt(F("taskdeviceport"));
        }
        success = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_046);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_046));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_046));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_046));
        break;
      }

    case PLUGIN_EXIT:
      {
        if (P046_data && (PCONFIG(0) == 0)) {
          delete P046_data;
          P046_data = nullptr;
        }
        break;
      }

    case PLUGIN_INIT:
      {
        if (!P046_data) {
          P046_data = new (std::nothrow) P046_data_struct();
        }

        uint8_t choice = PCONFIG(0);
        switch (choice)
        {
          case (0):
          {
            P046_data->Plugin_046_MOSIpin = PCONFIG(1);
            P046_data->Plugin_046_SCLKpin = PCONFIG(2);
            P046_data->Plugin_046_nSELpin = PCONFIG(3);
            P046_data->Plugin_046_MISOpin = PCONFIG(4);
            int8_t total = P046_data->Plugin_046_MOSIpin + P046_data->Plugin_046_SCLKpin + P046_data->Plugin_046_nSELpin + P046_data->Plugin_046_MISOpin;
            if (total > 6) {
              pinMode(P046_data->Plugin_046_MOSIpin, INPUT);
              pinMode(P046_data->Plugin_046_SCLKpin, INPUT);
              pinMode(P046_data->Plugin_046_nSELpin, INPUT);
              pinMode(P046_data->Plugin_046_MISOpin, INPUT);
              P046_data->Plugin_046_databuffer[0] = 0;
              Plugin_046_lastrainctr = 0;
              Plugin_046_lastraincount = -1;
              Plugin_046_laststrikectr = 0;
              Plugin_046_laststrikecount = -1;
              attachInterrupt(P046_data->Plugin_046_SCLKpin, Plugin_046_ISR_SCLK, RISING);
              attachInterrupt(P046_data->Plugin_046_nSELpin, Plugin_046_ISR_nSEL, CHANGE);
            }
            break;
          }
        }
        success = (nullptr != P046_data);
        break;
      }

    case PLUGIN_TEN_PER_SECOND:
      {
        if (!P046_data) break;
        if (PCONFIG(0) == 0) {
          if (P046_data->Plugin_046_newData) {
            uint8_t crc = 0xff;
            char data;

            P046_data->Plugin_046_databuffer[0] = P046_data->Plugin_046_ISR_Buffer[0];
            for (int i = 1; i < P046_data->Plugin_046_bytepointer; i++) {
              data = P046_data->Plugin_046_ISR_Buffer[i];
              P046_data->Plugin_046_databuffer[i] = data;
              for (int j = 0; j < 8; j++)
              {
                uint8_t mix = (crc ^ data) & 0x01;
                crc >>= 1;
                if (mix) crc ^= 0x8C;
                  data >>= 1;
              }
            }
            P046_data->Plugin_046_MasterSlave = false;
            P046_data->Plugin_046_newData = false;
            #ifndef BUILD_NO_DEBUG
            #if PLUGIN_046_DEBUG
              String log = F("Ventus W266 Rcvd(");
              log += node_time.getTimeString(':');
              log += F(") ");
              for (int i = 0; i < Plugin_046_Payload; i++) {
                if ((i==2)||(i==3)||(i==4)||(i==9)||(i==10)||(i==14)||(i==17)||(i==18)||(i==20)) {
                  log += ':';
                }
                char myHex = (P046_data->Plugin_046_databuffer[i] >> 4) + 0x30;
                if (myHex > 0x39) { myHex += 7; }
                log += myHex;
                myHex = (P046_data->Plugin_046_databuffer[i] & 0x0f) + 0x30;
                if (myHex > 0x39) { myHex += 7; }
                log += myHex;
              }
              log += F(" > ");
              char myHex = (crc >> 4) + 0x30;
              if (myHex > 0x39) { myHex += 7; }
              log += myHex;
              myHex = (crc & 0x0f) + 0x30;
              if (myHex > 0x39) { myHex += 7; }
              log += myHex;
              addLogMove(LOG_LEVEL_INFO, log);
            #endif
            #endif
            if (crc != 00)
            {
              P046_data->Plugin_046_databuffer[0] = 0;
            }
          }
        }
        success = true;
        break;
      }

    case PLUGIN_READ:
      {
        if (!P046_data) break;
        if (P046_data->Plugin_046_databuffer[0] == Plugin_046_MagicByte)
        {
          UserVar.setFloat(event->TaskIndex, 1, 0);
          uint8_t choice = PCONFIG(0);
          switch (choice)
          {
            case (0):
            {
              int myTemp = int((P046_data->Plugin_046_databuffer[5] * 256) + P046_data->Plugin_046_databuffer[4]);
              if (myTemp > 0x8000) { myTemp |= 0xffff0000; }
              float temperature = static_cast<float>(myTemp) / 10.0f;
              uint8_t myHum = (P046_data->Plugin_046_databuffer[2] >> 4) * 10 + (P046_data->Plugin_046_databuffer[2] & 0x0f);
              UserVar.setFloat(event->TaskIndex, 0, temperature);
              UserVar.setFloat(event->TaskIndex, 1, static_cast<float>(myHum));
              event->sensorType = Sensor_VType::SENSOR_TYPE_TEMP_HUM;
              break;
            }
            case (1):
            {
              const float average = static_cast<float>((P046_data->Plugin_046_databuffer[11] << 8) + P046_data->Plugin_046_databuffer[10]) / 10.0f;
              const float gust = static_cast<float>((P046_data->Plugin_046_databuffer[13] << 8) + P046_data->Plugin_046_databuffer[12]) / 10.0f;
              const float bearing = static_cast<float>(P046_data->Plugin_046_databuffer[9] & 0x0f) * 22.5f;
              UserVar.setFloat(event->TaskIndex, 0, bearing);
              UserVar.setFloat(event->TaskIndex, 1, average);
              UserVar.setFloat(event->TaskIndex, 2, gust);
              event->sensorType = Sensor_VType::SENSOR_TYPE_WIND;
              break;
            }
            case (2):
            {
              float raincnt = static_cast<float>(((P046_data->Plugin_046_databuffer[15]) * 256 + P046_data->Plugin_046_databuffer[14])) / 4.0f;
              int rainnow = int(raincnt);
              if (wdcounter < Plugin_046_lastrainctr) { Plugin_046_lastrainctr = wdcounter; }
              if (Plugin_046_lastrainctr > (wdcounter + 10))
              {
                Plugin_046_lastrainctr = wdcounter;
                if (rainnow > Plugin_046_lastraincount)
                {
                  Plugin_046_rainmmph = static_cast<float>(rainnow - Plugin_046_lastraincount) * 12.0f;
                  Plugin_046_lastraincount = rainnow;
                } else {
                  Plugin_046_rainmmph = 0;
                }
              }
              UserVar.setFloat(event->TaskIndex, 0, Plugin_046_rainmmph);
              UserVar.setFloat(event->TaskIndex, 1, raincnt);
              break;
            }
            case (3):
            {
              float uvindex = static_cast<float>(P046_data->Plugin_046_databuffer[17]) / 10.0f;
              UserVar.setFloat(event->TaskIndex, 0, uvindex);
              break;
            }
            case (4):
            {

              unsigned int strikesnow = int((P046_data->Plugin_046_databuffer[21]) * 256 + P046_data->Plugin_046_databuffer[20]);
              if (wdcounter < Plugin_046_laststrikectr) { Plugin_046_laststrikectr = wdcounter; }
              if (Plugin_046_laststrikectr > (wdcounter + 10))
              {
                Plugin_046_laststrikectr = wdcounter;
                if (strikesnow > Plugin_046_laststrikecount)
                {
                  Plugin_046_strikesph = strikesnow - Plugin_046_laststrikecount;
                  Plugin_046_laststrikecount = strikesnow;
                } else {
                  Plugin_046_strikesph = 0;
                }
              }
              UserVar.setFloat(event->TaskIndex, 0, Plugin_046_strikesph);
              break;
            }
            case (5):
            {
              float distance = -1.0f;
              if (P046_data->Plugin_046_databuffer[18] != 0x3F )
              {
                distance = P046_data->Plugin_046_databuffer[18];
              }
              UserVar.setFloat(event->TaskIndex, 0, distance);
              break;
            }
            case (6):
            {
              UserVar.setFloat(event->TaskIndex, 0, P046_data->Plugin_046_databuffer[6]);
              break;
            }
            case (7):
            {
              UserVar.setFloat(event->TaskIndex, 0, P046_data->Plugin_046_databuffer[16]);
              break;
            }
            case (8):
            {
              UserVar.setFloat(event->TaskIndex, 0, P046_data->Plugin_046_databuffer[19]);
              break;
            }
          }
          success = true;
        } else {
          success = false;
        }
        break;
      }
    }
    return success;
}

void Plugin_046_ISR_nSEL()
  {
    if (!P046_data) return;
    if (digitalRead(P046_data->Plugin_046_nSELpin)) {
      P046_data->Plugin_046_ReceiveActive = false;
      if (P046_data->Plugin_046_MasterSlave) {
        if (P046_data->Plugin_046_bytepointer == Plugin_046_Payload) {
          P046_data->Plugin_046_newData = true;
        }
      }
    } else {
      if (!P046_data->Plugin_046_newData) {
        P046_data->Plugin_046_bitpointer = 7;
        P046_data->Plugin_046_bytepointer = 0;
        P046_data->Plugin_046_MasterSlave = false;
        P046_data->Plugin_046_ReceiveActive = true;
      }
    }
  }

void Plugin_046_ISR_SCLK()
  {
    if (!P046_data) return;

    if (P046_data->Plugin_046_ReceiveActive) {
      if (P046_data->Plugin_046_MasterSlave) {
        bitWrite(P046_data->Plugin_046_receivedData, P046_data->Plugin_046_bitpointer, digitalRead(P046_data->Plugin_046_MISOpin));
      } else {
        bitWrite(P046_data->Plugin_046_receivedData, P046_data->Plugin_046_bitpointer, digitalRead(P046_data->Plugin_046_MOSIpin));
      }
      if (P046_data->Plugin_046_bitpointer == 0) {
        P046_data->Plugin_046_bitpointer = 7;
        if (P046_data->Plugin_046_receivedData==Plugin_046_MagicByte) {
          P046_data->Plugin_046_MasterSlave = true;
        }
        P046_data->Plugin_046_ISR_Buffer[P046_data->Plugin_046_bytepointer] = P046_data->Plugin_046_receivedData;
        P046_data->Plugin_046_bytepointer++;
        if (P046_data->Plugin_046_bytepointer > Plugin_046_RAW_BUFFER_SIZE) {
          P046_data->Plugin_046_ReceiveActive = false;
          P046_data->Plugin_046_MasterSlave = false;
        }
      } else {
        P046_data->Plugin_046_bitpointer--;
      }
    }
  }

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P047_i2c-soil-moisture-sensor.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P047
# 24 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P047_i2c-soil-moisture-sensor.ino"
#define PLUGIN_047 
#define PLUGIN_ID_047 47
#define PLUGIN_NAME_047 "Environment - Soil moisture sensor"
#define PLUGIN_VALUENAME1_047 "Temperature"
#define PLUGIN_VALUENAME2_047 "Moisture"
#define PLUGIN_VALUENAME3_047 "Light"

# include "src/PluginStructs/P047_data_struct.h"


boolean Plugin_047(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_047;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_047);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_047));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_047));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_047));
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P047_MODEL_CATNIP == static_cast<P047_SensorModels>(P047_MODEL) ? 3 : 2;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(P047_MODEL_CATNIP == static_cast<P047_SensorModels>(P047_MODEL) ? 3 : 2);
      event->idx = P047_MODEL_CATNIP == static_cast<P047_SensorModels>(P047_MODEL) ? 3 : 2;
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P047_I2C_ADDR = P047_CATNIP_DEFAULT_ADDR;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      addFormTextBox(F("I2C Address (Hex)"), F("i2c_addr"),
                     formatToHex_decimal(P047_I2C_ADDR), 4);
      addUnit(F("0x01..0x7F"));


      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = event->Par1 == P047_I2C_ADDR;
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P047_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *SensorModels[] = {
          F("Catnip electronics/miceuz (default)"),
          F("BeFlE"),
        };
        const int SensorModelIds[] = {
          static_cast<int>(P047_MODEL_CATNIP),
          static_cast<int>(P047_MODEL_BEFLE),
        };
        constexpr size_t P047_MODEL_OPTIONS = sizeof(SensorModelIds) / sizeof(SensorModelIds[0]);
        addFormSelector(F("Sensor model"), F("model"), P047_MODEL_OPTIONS, SensorModels, SensorModelIds, P047_MODEL, true);
        addFormNote(F("Changing the Sensor model will reload the page."));
      }

      if (P047_MODEL_CATNIP == static_cast<P047_SensorModels>(P047_MODEL)) {
        addFormSeparator(2);

        addFormCheckBox(F("Send sensor to sleep"), F("sleep"), P047_SENSOR_SLEEP);

        addFormCheckBox(F("Check sensor version"), F("version"), P047_CHECK_VERSION);
      }

      addFormSeparator(2);

      addFormCheckBox(F("Change Sensor address"), F("changeAddr"), false);
      addFormTextBox(F("Change I2C Addr. to (Hex)"), F("newAddr"),
                     formatToHex_decimal(P047_I2C_ADDR), 4);
      addUnit(F("0x01..0x7F"));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      success = true;
      String webarg = webArg(F("i2c_addr"));
      int addr = static_cast<int>(strtol(webarg.c_str(), 0, 16));

      if ((addr > 0x00) && (addr < 0x80)) {
        P047_I2C_ADDR = addr;
      } else {
        addHtmlError(F("I2C Address (Hex) error, range: 0x01..0x7F"));
        success = false;
      }

      uint8_t model = getFormItemInt(F("model"));

      if (model != P047_MODEL) {
        P047_MODEL = model;

        if (P047_MODEL_CATNIP == static_cast<P047_SensorModels>(model)) {
          P047_I2C_ADDR = P047_CATNIP_DEFAULT_ADDR;
          strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_047));
        } else {
          P047_I2C_ADDR = P047_BEFLE_DEFAULT_ADDR;
        }
      }

      P047_SENSOR_SLEEP = isFormItemChecked(F("sleep"));

      P047_CHECK_VERSION = isFormItemChecked(F("version"));

      webarg = webArg(F("newAddr"));
      addr = static_cast<int>(strtol(webarg.c_str(), 0, 16));

      if ((addr > 0x00) && (addr < 0x80)) {
        P047_NEW_ADDR = addr;
      } else {
        addHtmlError(F("Change I2C Addr. to (Hex) error, range: 0x01..0x7F"));
        success = false;
      }
      P047_CHANGE_ADDR = isFormItemChecked(F("changeAddr"));

      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P047_data_struct(P047_I2C_ADDR, P047_MODEL));
      break;
    }

    case PLUGIN_READ:
    {
      P047_data_struct *P047_data =
        static_cast<P047_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P047_data) {
        success = P047_data->plugin_read(event);
      }

      break;
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P048_Motorshield_v2.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P048
# 15 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P048_Motorshield_v2.ino"
# include <Adafruit_MotorShield.h>


#define PLUGIN_048 
#define PLUGIN_ID_048 48
#define PLUGIN_NAME_048 "Motor - Adafruit Motorshield v2"
#define PLUGIN_VALUENAME1_048 "MotorShield v2"

#define Plugin_048_MotorShield_address PCONFIG(0)
#define Plugin_048_MotorStepsPerRevolution PCONFIG(1)
#define Plugin_048_StepperSpeed PCONFIG(2)

boolean Plugin_048(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  Adafruit_MotorShield AFMS;


  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_048;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].I2CNoDeviceCheck = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_048);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0],
               PSTR(PLUGIN_VALUENAME1_048));
      break;
    }

    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      addFormTextBox(F("I2C Address (Hex)"), F("i2c_addr"),
                     formatToHex_decimal(Plugin_048_MotorShield_address), 4);


      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = Plugin_048_MotorShield_address;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      Plugin_048_MotorShield_address = 0x60;
      Plugin_048_MotorStepsPerRevolution = 200;
      Plugin_048_StepperSpeed = 10;

      break;
    }


    case PLUGIN_WEBFORM_LOAD: {
      addFormNumericBox(F("Stepper: steps per revolution"), F("steps")
                        , Plugin_048_MotorStepsPerRevolution);

      addFormNumericBox(F("Stepper speed (rpm)"), F("speed")
                        , Plugin_048_StepperSpeed);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      String plugin1 = webArg(F("i2c_addr"));
      Plugin_048_MotorShield_address = (int)strtol(plugin1.c_str(), 0, 16);

      Plugin_048_MotorStepsPerRevolution = getFormItemInt(F("steps"));

      Plugin_048_StepperSpeed = getFormItemInt(F("speed"));
      success = true;
      break;
    }

    case PLUGIN_INIT: {
      success = true;
      break;
    }

    case PLUGIN_READ: {
      success = false;
      break;
    }

    case PLUGIN_WRITE: {
      # if FEATURE_I2C_DEVICE_CHECK

      if (!I2C_deviceCheck(Plugin_048_MotorShield_address, event->TaskIndex, 10, PLUGIN_I2C_GET_ADDRESS)) {
        break;
      }
      # endif
      String cmd = parseString(string, 1);




      if (cmd.equalsIgnoreCase(F("MotorShieldCMD")))
      {
        String param1 = parseString(string, 2);
        String param2 = parseString(string, 3);
        String param3 = parseString(string, 4);
        String param4 = parseString(string, 5);
        String param5 = parseString(string, 6);

        int32_t p2_int;
        int32_t p4_int;
        const bool param2_is_int = validIntFromString(param2, p2_int);
        const bool param4_is_int = validIntFromString(param4, p4_int);


        AFMS = Adafruit_MotorShield(Plugin_048_MotorShield_address);
        # ifndef BUILD_NO_DEBUG

        if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
          String log = F("MotorShield: Address: 0x");
          log += String(Plugin_048_MotorShield_address, HEX);
          addLogMove(LOG_LEVEL_DEBUG, log);
        }
        # endif

        if (param1.equalsIgnoreCase(F("DCMotor"))) {
          if (param2_is_int && (p2_int > 0) && (p2_int < 5))
          {
            Adafruit_DCMotor *myMotor;
            myMotor = AFMS.getMotor(p2_int);

            if (param3.equalsIgnoreCase(F("Forward")))
            {
              uint8_t speed = 255;

              if (param4_is_int && (p4_int >= 0) && (p4_int <= 255)) {
                speed = p4_int;
              }
              AFMS.begin();

              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log = F("DCMotor");
                log += param2;
                log += F("->Forward Speed: ");
                log += speed;
                addLogMove(LOG_LEVEL_INFO, log);
              }
              myMotor->setSpeed(speed);
              myMotor->run(FORWARD);
              success = true;
            }

            if (param3.equalsIgnoreCase(F("Backward")))
            {
              uint8_t speed = 255;

              if (param4_is_int && (p4_int >= 0) && (p4_int <= 255)) {
                speed = p4_int;
              }
              AFMS.begin();

              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log = F("DCMotor");
                log += param2;
                log += F("->Backward Speed: ");
                log += speed;
                addLogMove(LOG_LEVEL_INFO, log);
              }

              myMotor->setSpeed(speed);
              myMotor->run(BACKWARD);
              success = true;
            }

            if (param3.equalsIgnoreCase(F("Release")))
            {
              AFMS.begin();

              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log = F("DCMotor");
                log += param2;
                log += F("->Release");
                addLogMove(LOG_LEVEL_INFO, log);
              }
              myMotor->run(RELEASE);
              success = true;
            }
          }
        }


        if (param1.equalsIgnoreCase(F("Stepper")))
        {


          if (param2_is_int && (p2_int > 0) && (p2_int < 3))
          {
            Adafruit_StepperMotor *myStepper;
            myStepper = AFMS.getStepper(Plugin_048_MotorStepsPerRevolution, p2_int);
            myStepper->setSpeed(Plugin_048_StepperSpeed);

            # ifndef BUILD_NO_DEBUG

            if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE)) {
              String log = F("MotorShield: StepsPerRevolution: ");
              log += String(Plugin_048_MotorStepsPerRevolution);
              log += F(" Stepperspeed: ");
              log += String(Plugin_048_StepperSpeed);
              addLogMove(LOG_LEVEL_DEBUG_MORE, log);
            }
            # endif

            if (param3.equalsIgnoreCase(F("Forward")))
            {
              if (param4_is_int && (p4_int != 0))
              {
                int steps = p4_int;

                if (param5.equalsIgnoreCase(F("SINGLE")))
                {
                  AFMS.begin();
                  myStepper->step(steps, FORWARD, SINGLE);
                  success = true;
                }

                if (param5.equalsIgnoreCase(F("DOUBLE")))
                {
                  AFMS.begin();
                  myStepper->step(steps, FORWARD, DOUBLE);
                  success = true;
                }

                if (param5.equalsIgnoreCase(F("INTERLEAVE")))
                {
                  AFMS.begin();
                  myStepper->step(steps, FORWARD, INTERLEAVE);
                  success = true;
                }

                if (param5.equalsIgnoreCase(F("MICROSTEP")))
                {
                  AFMS.begin();
                  myStepper->step(steps, FORWARD, MICROSTEP);
                  success = true;
                }

                if (success && loglevelActiveFor(LOG_LEVEL_INFO)) {
                  String log = F("Stepper");
                  log += param2;
                  log += F("->Forward Steps: ");
                  log += steps;
                  log += ' ';
                  log += param5;
                  addLogMove(LOG_LEVEL_INFO, log);
                }
              }
            }

            if (param3.equalsIgnoreCase(F("Backward")))
            {
              if (param4_is_int && (p4_int != 0))
              {
                int steps = p4_int;

                if (param5.equalsIgnoreCase(F("SINGLE")))
                {
                  AFMS.begin();
                  myStepper->step(steps, BACKWARD, SINGLE);
                  success = true;
                }

                if (param5.equalsIgnoreCase(F("DOUBLE")))
                {
                  AFMS.begin();
                  myStepper->step(steps, BACKWARD, DOUBLE);
                  success = true;
                }

                if (param5.equalsIgnoreCase(F("INTERLEAVE")))
                {
                  AFMS.begin();
                  myStepper->step(steps, BACKWARD, INTERLEAVE);
                  success = true;
                }

                if (param5.equalsIgnoreCase(F("MICROSTEP")))
                {
                  AFMS.begin();
                  myStepper->step(steps, BACKWARD, MICROSTEP);
                  success = true;
                }

                if (success && loglevelActiveFor(LOG_LEVEL_INFO)) {
                  String log = F("Stepper");
                  log += param2;
                  log += F("->Backward Steps: ");
                  log += steps;
                  log += ' ';
                  log += param5;
                  addLogMove(LOG_LEVEL_INFO, log);
                }
              }
            }

            if (param3.equalsIgnoreCase(F("Release")))
            {
              AFMS.begin();

              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log = F("Stepper");
                log += param2;
                log += F("->Release.");
                addLogMove(LOG_LEVEL_INFO, log);
              }
              myStepper->release();
              success = true;
            }
          }
        }
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P049_MHZ19.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P049

# include "src/PluginStructs/P049_data_struct.h"
# 29 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P049_MHZ19.ino"
#define PLUGIN_049 
#define PLUGIN_ID_049 49
#define PLUGIN_NAME_049 "Gases - CO2 MH-Z19"
#define PLUGIN_VALUENAME1_049 "PPM"
#define PLUGIN_VALUENAME2_049 "Temperature"
#define PLUGIN_VALUENAME3_049 "U"


boolean Plugin_049(uint8_t function, struct EventStruct *event, String& string)
{
  bool success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_049;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_049);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_049));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_049));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_049));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      serialHelper_getGpioNames(event);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }


    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *options[2] = { F("Normal"), F("ABC disabled") };
        const int optionValues[2] = { P049_ABC_enabled, P049_ABC_disabled };
        addFormSelector(F("Auto Base Calibration"), F("abcdisable"), 2, options, optionValues, PCONFIG(0));
      }
      {
        const __FlashStringHelper *filteroptions[5] =
        { F("Skip Unstable"), F("Use Unstable"), F("Fast Response"), F("Medium Response"), F("Slow Response") };
        const int filteroptionValues[5] = {
          PLUGIN_049_FILTER_OFF,
          PLUGIN_049_FILTER_OFF_ALLSAMPLES,
          PLUGIN_049_FILTER_FAST,
          PLUGIN_049_FILTER_MEDIUM,
          PLUGIN_049_FILTER_SLOW };
        addFormSelector(F("Filter"), F("filter"), 5, filteroptions, filteroptionValues, PCONFIG(1));
      }
      P049_html_show_stats(event);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("abcdisable"));

      P049_data_struct *P049_data = static_cast<P049_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P049_data) {
        P049_data->setABCmode(PCONFIG(0));
      }
      PCONFIG(1) = getFormItemInt(F("filter"));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P049_data_struct());
      success = P049_perform_init(event);

      break;
    }

    case PLUGIN_EXIT: {
      success = true;
      break;
    }

    case PLUGIN_WRITE:
    {
      P049_data_struct *P049_data = static_cast<P049_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P049_data) {
        success = P049_data->plugin_write(event, string);
      }

      break;
    }

    case PLUGIN_READ:
    {
      P049_data_struct *P049_data = static_cast<P049_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P049_data) {
        return success;
      }
      bool expectReset = false;
      unsigned int ppm = 0;
      signed int temp = 0;
      unsigned int s = 0;
      float u = 0;

      if (P049_data->read_ppm(ppm, temp, s, u)) {
        const bool mustLog = loglevelActiveFor(LOG_LEVEL_INFO);
        String log;

        if (mustLog) {
          log = F("MHZ19: ");
        }



        if (approximatelyEqual(u, 15000)) {
          if (mustLog) {
            log += F("Bootup detected! ");
          }

          if (P049_data->ABC_Disable) {


            P049_data->ABC_MustApply = true;

            if (mustLog) {
              log += F("Will disable ABC when bootup complete. ");
            }
          }
          success = false;


        } else {
          const int filterValue = PCONFIG(1);

          if (Plugin_049_Check_and_ApplyFilter(UserVar[event->BaseVarIndex], ppm, s, filterValue, log)) {
            UserVar.setFloat(event->TaskIndex, 0, ppm);
            UserVar.setFloat(event->TaskIndex, 1, temp);
            UserVar.setFloat(event->TaskIndex, 2, u);
            success = true;
          } else {
            success = false;
          }
        }

        if ((s == 0) || (s == 64)) {

          if (P049_data->ABC_MustApply) {

            String log = F("MHZ19: Sent sensor ABC ");

            if (P049_data->ABC_Disable) {
              P049_data->send_mhzCmd(mhzCmdABCDisable);
              log += F("Disable!");
            } else {
              P049_data->send_mhzCmd(mhzCmdABCEnable);
              log += F("Enable!");
            }
            addLog(LOG_LEVEL_INFO, log);
            P049_data->ABC_MustApply = false;
          }
        }

        if (mustLog) {

          log += F("PPM value: ");
          log += ppm;
          log += F(" Temp/S/U values: ");
          log += temp;
          log += '/';
          log += s;
          log += '/';
          log += u;
          addLogMove(LOG_LEVEL_INFO, log);
        }
        break;



      } else if (P049_data->receivedCommandAcknowledgement(expectReset)) {
        addLog(LOG_LEVEL_INFO, F("MHZ19: Received command acknowledgment! "));

        if (expectReset) {
          addLog(LOG_LEVEL_INFO, F("Expecting sensor reset..."));
        }
        success = false;
        break;




      } else {
        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("MHZ19: Unknown response:");
          log += P049_data->getBufferHexDump();
          addLogMove(LOG_LEVEL_INFO, log);
        }


        if ((P049_data->nrUnknownResponses > 10) && P049_data->initTimePassed) {
          P049_perform_init(event);
        }
        success = false;
        break;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P050_TCS34725.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P050
# 22 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P050_TCS34725.ino"
# include "src/PluginStructs/P050_data_struct.h"


#define PLUGIN_050 
#define PLUGIN_ID_050 50
#define PLUGIN_NAME_050 "Color - TCS34725"
#define PLUGIN_VALUENAME1_050 "Red"
#define PLUGIN_VALUENAME2_050 "Green"
#define PLUGIN_VALUENAME3_050 "Blue"
#define PLUGIN_VALUENAME4_050 "ColorTemperature"


#define P050_OPTION_RGB_EVENTS 



boolean Plugin_050(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_050;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_050);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_050));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_050));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_050));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_050));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG(2) = 1;
      PCONFIG(3) = 1;

      # if FEATURE_I2C_DEVICE_CHECK

      if (!I2C_deviceCheck(0x29)) {
        break;
      }
      # endif
      P050_data_struct *P050_data = new (std::nothrow) P050_data_struct(PCONFIG(0), PCONFIG(1));

      if (nullptr != P050_data) {
        P050_data->resetTransformation();
        P050_data->saveSettings(event->TaskIndex);
        delete P050_data;
      }
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x29);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x29;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      uint8_t choiceMode = PCONFIG(0);
      {
        const __FlashStringHelper *optionsMode[] = {
          F("2.4 ms"),
          F("24 ms"),
          F("50 ms"),
          F("101 ms"),
          F("154 ms"),
          F("700 ms"),
        };
        const int optionValuesMode[] = {
          TCS34725_INTEGRATIONTIME_2_4MS,
          TCS34725_INTEGRATIONTIME_24MS,
          TCS34725_INTEGRATIONTIME_50MS,
          TCS34725_INTEGRATIONTIME_101MS,
          TCS34725_INTEGRATIONTIME_154MS,
          TCS34725_INTEGRATIONTIME_700MS,
        };
        addFormSelector(F("Integration Time"), F("inttime"), 6, optionsMode, optionValuesMode, choiceMode);
      }

      uint8_t choiceMode2 = PCONFIG(1);
      {
        const __FlashStringHelper *optionsMode2[] = {
          F("1x"),
          F("4x"),
          F("16x"),
          F("60x"),
        };
        const int optionValuesMode2[] = {
          TCS34725_GAIN_1X,
          TCS34725_GAIN_4X,
          TCS34725_GAIN_16X,
          TCS34725_GAIN_60X,
        };
        addFormSelector(F("Gain"), F("gain"), 4, optionsMode2, optionValuesMode2, choiceMode2);
      }

      addFormSubHeader(F("Output settings"));

      {
        # define P050_RGB_OPTIONS 6
        const __FlashStringHelper *optionsRGB[P050_RGB_OPTIONS] = {
          F("Raw RGB"),
          F("Raw RGB transformed (3x3 matrix, below)"),
          F("Normalized RGB (0..255)"),
          F("Normalized RGB transformed (3x3 matrix, below)"),
          F("Normalized RGB (0.0000..1.0000)"),
          F("Normalized RGB (0.0000..1.0000) transformed (3x3 matrix, below)"),
        };
        const int optionValuesRGB[P050_RGB_OPTIONS] = { 0, 1, 2, 3, 4, 5 };
        addFormSelector(F("Output RGB Values"), F("outputrgb"), P050_RGB_OPTIONS, optionsRGB, optionValuesRGB, PCONFIG(2));
        addFormNote(F("For 'normalized' or 'transformed' options, the Red/Green/Blue Decimals should best be increased."));

# ifdef P050_OPTION_RGB_EVENTS
        addFormCheckBox(F("Generate RGB events"), F("rgbevents"), PCONFIG(5) == 1);
        addFormNote(F("Eventnames: taskname + #RawRGB, #RawRGBtransformed, #NormRGB, #NormRGBtransformed, #NormSRGB, #NormSRGBtransformed"));
        addFormNote(F("Only generated for not selected outputs, 3 values per event, =&lt;r&gt;,&lt;g&gt;,&lt;b&gt;"));
# endif
      }

      {
        # define P050_VALUE4_OPTIONS 4
        const __FlashStringHelper *optionsOutput[P050_VALUE4_OPTIONS] = {
          F("Color Temperature (deprecated) [K]"),
          F("Color Temperature (DN40) [K]"),
          F("Ambient Light [Lux]"),
          F("Clear Channel"),
        };
        const int optionValuesOutput[P050_VALUE4_OPTIONS] = { 0, 1, 2, 3 };
        addFormSelector(F("Output at Values #4"), F("output4"), P050_VALUE4_OPTIONS, optionsOutput, optionValuesOutput, PCONFIG(3));
        addFormNote(F("Optionally adjust Values #4 name accordingly."));

        addFormCheckBox(F("Generate all as events"), F("allevents"), PCONFIG(4) == 1);
        addFormNote(F("Eventnames: taskname + #CCT, #CCT_DN40, #Lux, #Clear"));
      }

      {
        P050_data_struct *P050_data = new (std::nothrow) P050_data_struct(PCONFIG(0), PCONFIG(1));

        if (nullptr != P050_data) {
          addFormSubHeader(F("Transformation matrix"));

          P050_data->resetTransformation();
          P050_data->loadSettings(event->TaskIndex);


          const String RGB = F("RGB");

          for (int i = 0; i < 3; i++) {
            addRowLabel(RGB.substring(i, i + 1));
            for (int j = 0; j < 3; j++) {
              addHtml(strformat(F("%c<sub>%d</sub>:"), static_cast<char>('a' + i), j + 1));
              addFloatNumberBox(P050_data_struct::generate_cal_id(i, j),
                                P050_data->TransformationSettings.matrix[i][j],
                                -255.999f,
                                255.999f);
            }
          }
          addFormNote(F("Check plugin documentation (i) on how to calibrate and how to calculate transformation matrix."));

          addFormCheckBox(F("Reset transformation matrix"), F("resettrans"), false);
          addFormNote(F("Select then Submit to confirm. Reset transformation matrix can't be un-done!"));


          delete P050_data;
        }
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("inttime"));
      PCONFIG(1) = getFormItemInt(F("gain"));
      PCONFIG(2) = getFormItemInt(F("outputrgb"));
      PCONFIG(3) = getFormItemInt(F("output4"));
      PCONFIG(4) = isFormItemChecked(F("allevents")) ? 1 : 0;
# ifdef P050_OPTION_RGB_EVENTS
      PCONFIG(5) = isFormItemChecked(F("rgbevents")) ? 1 : 0;
# endif
      bool resetTransformation = isFormItemChecked(F("resettrans"));
      {
        P050_data_struct *P050_data = new (std::nothrow) P050_data_struct(PCONFIG(0), PCONFIG(1));

        if (nullptr != P050_data) {
          P050_data->resetTransformation();
          P050_data->loadSettings(event->TaskIndex);

          if (resetTransformation) {

            P050_data->resetTransformation();
          } else {

            for (int i = 0; i < 3; i++) {
              for (int j = 0; j < 3; j++) {
                P050_data->TransformationSettings.matrix[i][j] =
                  getFormItemFloat(P050_data_struct::generate_cal_id(i, j));
              }
            }
          }
          P050_data->saveSettings(event->TaskIndex);


          delete P050_data;
        }
      }
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {

      initPluginTaskData(event->TaskIndex, new (std::nothrow) P050_data_struct(PCONFIG(0), PCONFIG(1)));
      P050_data_struct *P050_data = static_cast<P050_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P050_data) {
        P050_data->resetTransformation();
        success = true;
      }
      break;
    }

    case PLUGIN_EXIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      P050_data_struct *P050_data = static_cast<P050_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P050_data) {
        return success;
      }

      if (P050_data->tcs.begin()) {
# ifndef BUILD_NO_DEBUG
        addLog(LOG_LEVEL_DEBUG, F("Found TCS34725 sensor"));
# endif

        uint16_t r, g, b, c;
        float value4 = 0.0f;

        P050_data->loadSettings(event->TaskIndex);

        P050_data->tcs.getRawData(&r, &g, &b, &c, true);

        switch (PCONFIG(3)) {
          case 0:
            value4 = P050_data->tcs.calculateColorTemperature(r, g, b);

            break;
          case 1:
            value4 = P050_data->tcs.calculateColorTemperature_dn40(r, g, b, c);
            break;
          case 2:
            value4 = P050_data->tcs.calculateLux(r, g, b);
            break;
          case 3:
            value4 = c;
            break;
        }

        float sRGBFactor = 1.0f;
        uint32_t t = r + g + b;

        if (t == 0) {
          UserVar.setFloat(event->TaskIndex, 0, 0.0f);
          UserVar.setFloat(event->TaskIndex, 1, 0.0f);
          UserVar.setFloat(event->TaskIndex, 2, 0.0f);
        }

        switch (PCONFIG(2)) {
          case 0:
            UserVar.setFloat(event->TaskIndex, 0, r);
            UserVar.setFloat(event->TaskIndex, 1, g);
            UserVar.setFloat(event->TaskIndex, 2, b);
            break;
          case 1:

            if (t != 0) {
              float r_f, g_f, b_f{};
              P050_data->applyTransformation(
                r, g, b,
                &r_f, &g_f, &b_f);
              UserVar.setFloat(event->TaskIndex, 0, r_f);
              UserVar.setFloat(event->TaskIndex, 1, g_f);
              UserVar.setFloat(event->TaskIndex, 2, b_f);

            }
            break;
          case 2:
            sRGBFactor = 255.0f;


          case 4:

            if (t != 0) {
              UserVar.setFloat(event->TaskIndex, 0, static_cast<float>(r) / t * sRGBFactor);
              UserVar.setFloat(event->TaskIndex, 1, static_cast<float>(g) / t * sRGBFactor);
              UserVar.setFloat(event->TaskIndex, 2, static_cast<float>(b) / t * sRGBFactor);
            }
            break;
          case 3:
            sRGBFactor = 255.0f;


          case 5:

            if (t != 0) {
              const float nr = static_cast<float>(r) / t * sRGBFactor;
              const float ng = static_cast<float>(g) / t * sRGBFactor;
              const float nb = static_cast<float>(b) / t * sRGBFactor;

              float r_f, g_f, b_f{};
              P050_data->applyTransformation(
                nr, ng, nb,
                &r_f, &g_f, &b_f);
              UserVar.setFloat(event->TaskIndex, 0, r_f);
              UserVar.setFloat(event->TaskIndex, 1, g_f);
              UserVar.setFloat(event->TaskIndex, 2, b_f);
            }
            break;
        }
        UserVar.setFloat(event->TaskIndex, 3, value4);

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("TCS34725: ");

          switch (PCONFIG(3)) {
            case 0:
            case 1:
              log += F("Color Temp (K): ");
              break;
            case 2:
              log += F("Lux : ");
              break;
            case 3:
              log += F("Clear : ");
              break;
          }
          log += strformat(
            F(" %s R: %s G: %s B: %s "),
            formatUserVarNoCheck(event->TaskIndex, 3).c_str(),
            formatUserVarNoCheck(event->TaskIndex, 0).c_str(),
            formatUserVarNoCheck(event->TaskIndex, 1).c_str(),
            formatUserVarNoCheck(event->TaskIndex, 2).c_str());
          addLogMove(LOG_LEVEL_INFO, log);
        }

# ifdef P050_OPTION_RGB_EVENTS


        if ((PCONFIG(5) == 1) && (t != 0)) {
          float tr, tg, tb, nr, ng, nb;

          for (int i = 0; i < 6; i++) {
            if (i != PCONFIG(2)) {
              const __FlashStringHelper* varName = F("");
              String eventValues;
              sRGBFactor = 1.0f;

              switch (i) {
                case 0:
                  varName = F("RawRGB");
                  eventValues += strformat(F("%u,%u,%u"), r, g, b);
                  break;
                case 3:
                  sRGBFactor = 255.0f;


                case 1:
                case 5:

                  if (i == 1) {
                    varName = F("RawRGBtransformed");
                    P050_data->applyTransformation(r, g, b, &tr, &tg, &tb);
                  } else {
                    if (i == 3) {
                      varName = F("NormRGBtransformed");
                    } else {
                      varName = F("NormSRGBtransformed");
                    }
                    nr = static_cast<float>(r) / t * sRGBFactor;
                    ng = static_cast<float>(g) / t * sRGBFactor;
                    nb = static_cast<float>(b) / t * sRGBFactor;
                    P050_data->applyTransformation(nr, ng, nb, &tr, &tg, &tb);
                  }

                  eventValues += strformat(F("%.4f,%.4f,%.4f"), tr, tg, tb);
                  break;
                case 2:
                  sRGBFactor = 255.0f;


                case 4:

                  if (i == 2) {
                    varName = F("NormRGB");
                  } else {
                    varName = F("NormSRGB");
                  }
                  eventValues += strformat(
                    F("%.4f,%.4f,%.4f"),
                    static_cast<float>(r) / t * sRGBFactor,
                    static_cast<float>(g) / t * sRGBFactor,
                    static_cast<float>(b) / t * sRGBFactor);
                  break;
                default:
                  eventValues.clear();
                  break;
              }

              if (!eventValues.isEmpty()) {
                eventQueue.add(event->TaskIndex, varName, eventValues);
              }
            }
          }
        }
# endif


        if (PCONFIG(4) == 1) {
          for (int i = 0; i < 4; i++) {
            switch (i) {
              case 0:
                eventQueue.add(event->TaskIndex, F("CCT"), P050_data->tcs.calculateColorTemperature(r, g, b));
                break;
              case 1:
                eventQueue.add(event->TaskIndex, F("CCT_DN40"), P050_data->tcs.calculateColorTemperature_dn40(r, g, b, c));
                break;
              case 2:
                eventQueue.add(event->TaskIndex, F("Lux"), P050_data->tcs.calculateLux(r, g, b));
                break;
              case 3:
                eventQueue.add(event->TaskIndex, F("Clear"), String(c));
                break;
              default:
                break;
            }
          }
        }

        success = true;
      } else {
# ifndef BUILD_NO_DEBUG
        addLog(LOG_LEVEL_DEBUG, F("No TCS34725 found"));
# endif
        success = false;
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P051_AM2320.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P051
# 21 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P051_AM2320.ino"
# include <AM2320.h>

#define PLUGIN_051 
#define PLUGIN_ID_051 51
#define PLUGIN_NAME_051 "Environment - AM2320"
#define PLUGIN_VALUENAME1_051 "Temperature"
#define PLUGIN_VALUENAME2_051 "Humidity"


boolean Plugin_051(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_051;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_HUM;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].I2CNoDeviceCheck = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_051);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_051));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_051));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x5c);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x5c;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    case PLUGIN_WEBFORM_SAVE:
    case PLUGIN_INIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      AM2320 th;

      switch (th.Read()) {
        case 2:
          addLog(LOG_LEVEL_ERROR, F("AM2320: CRC failed"));
          break;
        case 1:
          addLog(LOG_LEVEL_ERROR, F("AM2320: Sensor offline"));
          break;
        case 0:
        {
          UserVar.setFloat(event->TaskIndex, 0, th.t);
          UserVar.setFloat(event->TaskIndex, 1, th.h);

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log = F("AM2320: Temperature: ");
            log += formatUserVarNoCheck(event->TaskIndex, 0);
            addLogMove(LOG_LEVEL_INFO, log);
            log = F("AM2320: Humidity: ");
            log += formatUserVarNoCheck(event->TaskIndex, 1);
            addLogMove(LOG_LEVEL_INFO, log);
          }
          success = true;
          break;
        }
      }
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P052_SenseAir.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P052

# include "src/PluginStructs/P052_data_struct.h"
# 27 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P052_SenseAir.ino"
#define PLUGIN_052 
#define PLUGIN_ID_052 52
#define PLUGIN_NAME_052 "Gases - CO2 Senseair"


boolean Plugin_052(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_052;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].ExitTaskBeforeSave = false;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_052);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < P052_NR_OUTPUT_VALUES) {
          const uint8_t pconfigIndex = i + P052_QUERY1_CONFIG_POS;
          uint8_t choice = PCONFIG(pconfigIndex);
          ExtraTaskSettings.setTaskDeviceValueName(i, P052_data_struct::Plugin_052_valuename(choice, false));
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P052_NR_OUTPUT_VALUES;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(P052_SENSOR_TYPE_INDEX));
      event->idx = P052_SENSOR_TYPE_INDEX;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES: {
      serialHelper_getGpioNames(event);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG(P052_SENSOR_TYPE_INDEX) = static_cast<int16_t>(Sensor_VType::SENSOR_TYPE_SINGLE);
      PCONFIG(0) = 1;

      for (uint8_t i = 1; i < VARS_PER_TASK; ++i) {
        PCONFIG(i) = 0;
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      const __FlashStringHelper *options[P052_NR_OUTPUT_OPTIONS];

      for (uint8_t i = 0; i < P052_NR_OUTPUT_OPTIONS; ++i) {
        options[i] = P052_data_struct::Plugin_052_valuename(i, true);
      }

      for (uint8_t i = 0; i < P052_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P052_QUERY1_CONFIG_POS;
        sensorTypeHelper_loadOutputSelector(event, pconfigIndex, i, P052_NR_OUTPUT_OPTIONS, options);
      }
      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
      P052_data_struct *P052_data =
        static_cast<P052_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P052_data) && P052_data->isInitialized()) {
        addFormSubHeader(F("Device Information"));
        {
          int value = 0;

          if (P052_data->modbus.detected_device_description.length() > 0) {
            addRowLabel(F("Detected Device"));
            addHtml(P052_data->modbus.detected_device_description);
          }

          if (P052_data->readInputRegister(P052_IR29_FW_REV, value)) {
            addRowLabel(F("FW rev."));
            addHtmlInt(value);
          }

          addRowLabel(F("Sensor ID"));
          addHtml(formatToHex_decimal(P052_data->getSensorID()));


          addRowLabel(F("Checksum (pass/fail/nodata)"));
          {
            uint32_t reads_pass, reads_crc_failed, reads_nodata;
            P052_data->modbus.getStatistics(reads_pass, reads_crc_failed, reads_nodata);
            String chksumStats;
            chksumStats = reads_pass;
            chksumStats += '/';
            chksumStats += reads_crc_failed;
            chksumStats += '/';
            chksumStats += reads_nodata;
            addHtml(chksumStats);
          }

          bool hasFactorySettings = false;
          bool enabledABC = false;

          if (P052_data->readHoldingRegister(P052_HR19_METER_CONTROL, value)) {
            hasFactorySettings = value == 255;
            enabledABC = bitRead(value, 1) == 0;
            addRowLabel(F("Using Factory Settings"));
            addEnabled(hasFactorySettings);

            if (!hasFactorySettings) {


              addRowLabel(F("nRDY"));
              addEnabled(bitRead(value, 0) == 0);
              addRowLabel(F("ABC"));
              addEnabled(enabledABC);
              addRowLabel(F("Static IIR filter"));
              addEnabled(bitRead(value, 2) == 0);
              addRowLabel(F("Dynamic IIR filter"));
              addEnabled(bitRead(value, 3) == 0);
              addRowLabel(F("Pressure Compensation"));
              addEnabled(bitRead(value, 4) == 0);
            }
          }


          if (P052_data->readInputRegister(P052_IR7_MEASUREMENT_COUNT, value)) {
            addRowLabel(F("Measurement Count"));
            addHtmlInt(value);
          }

          if (P052_data->readInputRegister(P052_IR8_MEASUREMENT_CYCLE_TIME, value)) {
            addRowLabel(F("Measurement Cycle time"));
            addHtmlInt(value * 2);
            addUnit('s');
          }

          if (P052_data->readInputRegister(P052_IR9_MEASURED_UNFILTERED_CO2, value)) {
            addRowLabel(F("Unfiltered CO2"));
            addHtmlInt(value);
          }

          if (P052_data->readHoldingRegister(P052_HR11_MEASUREMENT_MODE, value)) {
            addRowLabel(F("Measurement Mode"));
            addHtml(value == 0 ? F("Continuous") : F("Single Measurement"));
          }

          if (enabledABC) {
            if (P052_data->readHoldingRegister(P052_HR14_ABC_PERIOD, value)) {
              addRowLabel(F("ABC Period"));
              addHtmlInt(value);
              addUnit('h');
            }

            if (P052_data->readHoldingRegister(P052_HR5_ABC_TIME, value)) {
              addRowLabel(F("Time Since ABC"));
              addHtmlInt(value);
              addUnit('h');
            }
          }
        }

        {
          int value = 0;
# 237 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P052_SenseAir.ino"
          if (P052_data->readHoldingRegister(P052_HR12_MEASUREMENT_PERIOD, value)) {
            addFormNumericBox(F("Measurement Period"), F("period"), value, 2, 65534);
            addUnit('s');
          }

          if (P052_data->readHoldingRegister(P052_HR13_NR_OF_SAMPLES, value)) {
            addFormNumericBox(F("Samples per measurement"), F("samp_meas"), value, 1, 1024);
          }
        }
        {

        }
      }
# 262 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P052_SenseAir.ino"
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {

      for (uint8_t i = 0; i < P052_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P052_QUERY1_CONFIG_POS;
        const uint8_t choice = PCONFIG(pconfigIndex);
        sensorTypeHelper_saveOutputSelector(event, pconfigIndex, i, P052_data_struct::Plugin_052_valuename(choice, false));
      }

      P052_data_struct *P052_data =
        static_cast<P052_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P052_data) && P052_data->isInitialized()) {
        bool changed = false;
        uint16_t mode = getFormItemInt(F("mode"), 65535);

        if (((mode == 0) || (mode == 1))) {
          uint8_t errorcode;
          int readVal = P052_data->modbus.readHoldingRegister(0x0A, errorcode);

          if ((errorcode == 0) && (readVal != mode)) {
            P052_data->modbus.writeMultipleRegisters(0x0A, mode);
            delay(0);
            changed = true;
          }
        }
        uint16_t period = getFormItemInt(F("period"), 0);

        if (period > 1) {
          uint8_t errorcode;
          int readVal = P052_data->modbus.readHoldingRegister(0x0B, errorcode);

          if ((errorcode == 0) && (readVal != period)) {
            P052_data->modbus.writeMultipleRegisters(0x0B, period);
            delay(0);
            changed = true;
          }
        }
        uint16_t samp_meas = getFormItemInt(F("samp_meas"), 0);

        if ((samp_meas > 0) && (samp_meas <= 1024)) {
          uint8_t errorcode;
          int readVal = P052_data->modbus.readHoldingRegister(0x0C, errorcode);

          if ((errorcode == 0) && (readVal != samp_meas)) {
            P052_data->modbus.writeMultipleRegisters(0x0C, samp_meas);
            delay(0);
            changed = true;
          }
        }

        if (changed) {

          P052_data->modbus.writeMultipleRegisters(0x11, 0xFF);


          delay(35);
        }
      }
# 332 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P052_SenseAir.ino"
      success = true;
      break;
    }

    case PLUGIN_INIT: {
      const int16_t serial_rx = CONFIG_PIN1;
      const int16_t serial_tx = CONFIG_PIN2;
      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);

      initPluginTaskData(event->TaskIndex, new (std::nothrow) P052_data_struct());
      P052_data_struct *P052_data =
        static_cast<P052_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P052_data) {
        return success;
      }


      if (P052_data->init(port, serial_rx, serial_tx)) {
# 360 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P052_SenseAir.ino"
        P052_data->modbus.setModbusTimeout(P052_MODBUS_TIMEOUT);





        success = true;
      } else {
        clearPluginTaskData(event->TaskIndex);
      }
      break;
    }

    case PLUGIN_EXIT: {
      success = true;
      break;
    }

    case PLUGIN_READ: {
      P052_data_struct *P052_data =
        static_cast<P052_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P052_data) && P052_data->isInitialized()) {
        event->sensorType = static_cast<Sensor_VType>(PCONFIG(P052_SENSOR_TYPE_INDEX));
        String log = F("Senseair: ");
        String logPrefix;

        for (int varnr = 0; varnr < P052_NR_OUTPUT_VALUES; ++varnr) {
          uint8_t errorcode = 0;
          float value = 0;

          switch (PCONFIG(varnr)) {
            case 1: {
              value = P052_data->modbus.readInputRegister(P052_IR4_MEASURED_FILTERED_CO2, errorcode);
              logPrefix = F("co2=");
              break;
            }
            case 2: {
              int temperatureX100 = P052_data->modbus.readInputRegister(P052_IR5_TEMPERATURE, errorcode);

              if (errorcode == 2) {


                temperatureX100 = P052_data->modbus.read_RAM_EEPROM(
                  P052_CMD_READ_RAM, P052_RAM_ADDR_DET_TEMPERATURE, 2, errorcode);
              }

              if (temperatureX100 >= 32768) {

                temperatureX100 -= 65536;
              }
              value = static_cast<float>(temperatureX100) / 100.0f;
              logPrefix = F("temp=");
              break;
            }
            case 3: {
              int rhX100 = P052_data->modbus.readInputRegister(P052_IR6_SPACE_HUMIDITY, errorcode);
              value = static_cast<float>(rhX100) / 100.0f;
              logPrefix = F("hum=");
              break;
            }
            case 4: {
              int status = P052_data->modbus.readInputRegister(P052_IR29_FW_REV, errorcode);

              if (errorcode == 0) {
                int relayStatus = (status >> 8) & 0x1;
                UserVar.setFloat(event->TaskIndex, varnr, relayStatus);
                log += F("relay status=");
                log += relayStatus;
              }
              break;
            }
            case 5: {
              int temperatureAdjustment = P052_data->modbus.readInputRegister(P052_IR11_MEASURED_CONCENTRATION_UNFILTERED, errorcode);
              value = static_cast<float>(temperatureAdjustment);
              logPrefix = F("temp adj=");
              break;
            }

            case 7: {
              const int errorWord = P052_data->modbus.readInputRegister(P052_IR_ERRORSTATUS, errorcode);

              if (errorcode == 0) {
                value = errorWord;

                for (size_t i = 0; i < 9; i++) {
                  if (bitRead(errorWord, i)) {
                    log += F("err=");
                    log += i;
                    break;
                  }
                }
              } else {
                value = -1;
                log += F("err=");
                log += -1;
              }
              break;
            }
            case 0:
            default: {
              UserVar.setFloat(event->TaskIndex, varnr, 0);
              break;
            }
          }

          if ((errorcode == 0) && (P052_data->modbus.getLastError() == 0)) {
            success = true;
            UserVar.setFloat(event->TaskIndex, varnr, value);
            log += logPrefix;
            log += value;
          }
        }
        addLogMove(LOG_LEVEL_INFO, log);
        break;
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P052_data_struct *P052_data =
        static_cast<P052_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P052_data) && P052_data->plugin_write(event, string)) {
        success = true;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P053_PMSx003.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P053
# 14 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P053_PMSx003.ino"
# include "src/PluginStructs/P053_data_struct.h"

#define PLUGIN_053 
#define PLUGIN_ID_053 53
#define PLUGIN_NAME_053 "Dust - PMSx003"
# ifdef PLUGIN_053_ENABLE_EXTRA_SENSORS
# ifdef PLUGIN_NAME_053
#undef PLUGIN_NAME_053
# endif
#define PLUGIN_NAME_053 "Dust - PMSx003 / PMSx003ST"
# endif
#define PLUGIN_VALUENAME1_053 "pm1.0"
#define PLUGIN_VALUENAME2_053 "pm2.5"
#define PLUGIN_VALUENAME3_053 "pm10"
#define PLUGIN_VALUENAME4_053 "HCHO"


boolean Plugin_053(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_053;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      # ifdef PLUGIN_053_ENABLE_EXTRA_SENSORS
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      # else
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 3;
      # endif
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_053);
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      const bool oversample = bitRead(PLUGIN_053_DATA_PROCESSING_FLAGS, PLUGIN_053_OVERSAMPLING_BIT);

      switch (GET_PLUGIN_053_OUTPUT_SELECTOR) {
        case PMSx003_output_selection::Particles_ug_m3:
        {
          const uint8_t indices[] = {
            PMS_PM1_0_ug_m3_normal,
            PMS_PM2_5_ug_m3_normal,
            PMS_PM10_0_ug_m3_normal };
          P053_data_struct::setTaskValueNames(ExtraTaskSettings, indices, 3, oversample);
          break;
        }
        case PMSx003_output_selection::PM2_5_TempHum_Formaldehyde:
        {
          const uint8_t indices[] = {
            PMS_PM2_5_ug_m3_normal,
            PMS_Temp_C,
            PMS_Hum_pct,
            PMS_Formaldehyde_mg_m3 };
          P053_data_struct::setTaskValueNames(ExtraTaskSettings, indices, 4, oversample);
          break;
        }
        case PMSx003_output_selection::ParticlesCount_100ml_cnt0_3__cnt_2_5:
        {
          const uint8_t indices[] = {
            PMS_cnt0_3_100ml,
            PMS_cnt0_5_100ml,
            PMS_cnt1_0_100ml,
            PMS_cnt2_5_100ml };
          P053_data_struct::setTaskValueNames(ExtraTaskSettings, indices, 4, oversample);
          break;
        }
        case PMSx003_output_selection::ParticlesCount_100ml_cnt1_0_cnt2_5_cnt10:
        {
          const uint8_t indices[] = {
            PMS_cnt1_0_100ml,
            PMS_cnt2_5_100ml,
            PMS_cnt5_0_100ml,
            PMS_cnt10_0_100ml };
          P053_data_struct::setTaskValueNames(ExtraTaskSettings, indices, 4, oversample);
          break;
        }
      }
      success = true;
      break;
    }

    # ifdef PLUGIN_053_ENABLE_EXTRA_SENSORS
    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = GET_PLUGIN_053_OUTPUT_SELECTOR == PMSx003_output_selection::Particles_ug_m3 ? 3 : 4;
      success = true;
      break;
    }
    # endif

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      serialHelper_getGpioNames(event);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      string = F("RST: ");
      string += formatGpioLabel(PLUGIN_053_RST_PIN, false);
      string += event->String1;
      string += F("SET: ");
      string += formatGpioLabel(PLUGIN_053_PWR_PIN, false);
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      PLUGIN_053_RST_PIN = -1;
      PLUGIN_053_PWR_PIN = -1;

      PLUGIN_053_SENSOR_MODEL_SELECTOR = static_cast<int>(PMSx003_type::PMS1003_5003_7003);
      PLUGIN_053_SEC_IGNORE_AFTER_WAKE = 0;

      bitSet(PLUGIN_053_DATA_PROCESSING_FLAGS, PLUGIN_053_OVERSAMPLING_BIT);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
      addFormPinSelect(PinSelectPurpose::Generic_output, formatGpioName_output_optional(F("RST")), F("rstpin"), PLUGIN_053_RST_PIN);
      addFormPinSelect(PinSelectPurpose::Generic_output, formatGpioName_output_optional(F("SET")), F("pwrpin"), PLUGIN_053_PWR_PIN);
      addFormNote(F("RST and SET pins on sensor are pulled up internal in the sensor"));
      # ifdef PLUGIN_053_ENABLE_EXTRA_SENSORS
      {
        addFormSubHeader(F("Device"));
        int unitModelCount = 5;
        const __FlashStringHelper *unitModels[] = {
          toString(PMSx003_type::PMS1003_5003_7003),
          toString(PMSx003_type::PMS2003_3003),
          toString(PMSx003_type::PMS5003_S),
          toString(PMSx003_type::PMS5003_T),
          toString(PMSx003_type::PMS5003_ST)
        };
        const int unitModelOptions[] = {
          static_cast<int>(PMSx003_type::PMS1003_5003_7003),
          static_cast<int>(PMSx003_type::PMS2003_3003),
          static_cast<int>(PMSx003_type::PMS5003_S),
          static_cast<int>(PMSx003_type::PMS5003_T),
          static_cast<int>(PMSx003_type::PMS5003_ST)
        };
        addFormSelector(F("Sensor model"), F("model"), unitModelCount, unitModels, unitModelOptions, PLUGIN_053_SENSOR_MODEL_SELECTOR);
      }

      addFormSubHeader(F("Output"));
      {
        const __FlashStringHelper *outputOptions[] = {
          toString(PMSx003_output_selection::Particles_ug_m3),
          toString(PMSx003_output_selection::PM2_5_TempHum_Formaldehyde),
          toString(PMSx003_output_selection::ParticlesCount_100ml_cnt0_3__cnt_2_5),
          toString(PMSx003_output_selection::ParticlesCount_100ml_cnt1_0_cnt2_5_cnt10) };
        const int outputOptionValues[] = {
          static_cast<int>(PMSx003_output_selection::Particles_ug_m3),
          static_cast<int>(PMSx003_output_selection::PM2_5_TempHum_Formaldehyde),
          static_cast<int>(PMSx003_output_selection::ParticlesCount_100ml_cnt0_3__cnt_2_5),
          static_cast<int>(PMSx003_output_selection::ParticlesCount_100ml_cnt1_0_cnt2_5_cnt10) };
        addFormSelector(F("Output values"), F("output"), 4, outputOptions, outputOptionValues, PLUGIN_053_OUTPUT_SELECTOR, true);
        addFormNote(F("Changing this reloads the page and updates task value names + nr decimals."));
      }
      {
        const __FlashStringHelper *eventOptions[] = {
          toString(PMSx003_event_datatype::Event_None),
          toString(PMSx003_event_datatype::Event_PMxx_TempHum_Formaldehyde),
          toString(PMSx003_event_datatype::Event_All_count_bins),
          toString(PMSx003_event_datatype::Event_All) };
        const int eventOptionValues[] = {
          static_cast<int>(PMSx003_event_datatype::Event_None),
          static_cast<int>(PMSx003_event_datatype::Event_PMxx_TempHum_Formaldehyde),
          static_cast<int>(PMSx003_event_datatype::Event_All_count_bins),
          static_cast<int>(PMSx003_event_datatype::Event_All) };
        addFormSelector(F("Events for non-output values"), F("events"), 4, eventOptions, eventOptionValues,
                        PLUGIN_053_EVENT_OUT_SELECTOR);
        addFormNote(F(
                      "Only generates the 'missing' events, (taskname#temp/humi/hcho, taskname#pm1.0/pm2.5/pm10, taskname#cnt0.3/cnt0.5/cnt1.0/cnt2.5/cnt5/cnt10)."));
      }
      # endif

      addFormSubHeader(F("Data Processing"));
      {
        addFormNumericBox(F("Sensor init time after wake"), F("delay_wake"),
                          PLUGIN_053_SEC_IGNORE_AFTER_WAKE, 0, 30);
        addUnit(F("sec"));

        # ifdef PLUGIN_053_ENABLE_EXTRA_SENSORS
        addFormCheckBox(F("Oversampling"), F("oversample"),
                        bitRead(PLUGIN_053_DATA_PROCESSING_FLAGS, PLUGIN_053_OVERSAMPLING_BIT));


        addFormCheckBox(F("Split count bins"), F("split_bins"),
                        bitRead(PLUGIN_053_DATA_PROCESSING_FLAGS, PLUGIN_053_SPLIT_CNT_BINS_BIT));
        addFormNote(F("Subtract next \"count/0.1L\" bin counts to get counts per bin, not a range of bins"));
        # endif
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      int rstPin, pwrPin = -1;
      update_whenset_FormItemInt(F("rstpin"), rstPin);
      update_whenset_FormItemInt(F("pwrpin"), pwrPin);
      PLUGIN_053_RST_PIN = rstPin;
      PLUGIN_053_PWR_PIN = pwrPin;
      success = true;

      # ifdef PLUGIN_053_ENABLE_EXTRA_SENSORS
      const int oldOutputSelector = PLUGIN_053_OUTPUT_SELECTOR;
      PLUGIN_053_SENSOR_MODEL_SELECTOR = getFormItemInt(F("model"));
      PLUGIN_053_OUTPUT_SELECTOR = getFormItemInt(F("output"));
      PLUGIN_053_EVENT_OUT_SELECTOR = getFormItemInt(F("events"));
      PLUGIN_053_SEC_IGNORE_AFTER_WAKE = getFormItemInt(F("delay_wake"));

      if (isFormItemChecked(F("oversample"))) {
        bitSet(PLUGIN_053_DATA_PROCESSING_FLAGS, PLUGIN_053_OVERSAMPLING_BIT);
      } else {
        bitClear(PLUGIN_053_DATA_PROCESSING_FLAGS, PLUGIN_053_OVERSAMPLING_BIT);
      }

      if (isFormItemChecked(F("split_bins"))) {
        bitSet(PLUGIN_053_DATA_PROCESSING_FLAGS, PLUGIN_053_SPLIT_CNT_BINS_BIT);
      } else {
        bitClear(PLUGIN_053_DATA_PROCESSING_FLAGS, PLUGIN_053_SPLIT_CNT_BINS_BIT);
      }

      switch (GET_PLUGIN_053_SENSOR_MODEL_SELECTOR) {
        case PMSx003_type::PMS1003_5003_7003:


          if (GET_PLUGIN_053_OUTPUT_SELECTOR == PMSx003_output_selection::PM2_5_TempHum_Formaldehyde) {
            PLUGIN_053_OUTPUT_SELECTOR = static_cast<int>(PMSx003_output_selection::Particles_ug_m3);
          }

          if (GET_PLUGIN_053_EVENT_OUT_SELECTOR == PMSx003_event_datatype::Event_PMxx_TempHum_Formaldehyde) {
            PLUGIN_053_EVENT_OUT_SELECTOR = static_cast<int>(PMSx003_event_datatype::Event_None);
          }
          break;
        case PMSx003_type::PMS2003_3003:
          PLUGIN_053_OUTPUT_SELECTOR = static_cast<int>(PMSx003_output_selection::Particles_ug_m3);
          PLUGIN_053_EVENT_OUT_SELECTOR = static_cast<int>(PMSx003_event_datatype::Event_None);
          break;
        default:
          break;
      }

      if (oldOutputSelector != PLUGIN_053_OUTPUT_SELECTOR) {
        struct EventStruct TempEvent(event->TaskIndex);



        ExtraTaskSettings.TaskIndex = event->TaskIndex;
        String dummy;
        PluginCall(PLUGIN_GET_DEVICEVALUENAMES, &TempEvent, dummy);
      }

      # endif
      break;
    }

    case PLUGIN_INIT:
    {
      const int8_t rxPin = CONFIG_PIN1;
      const int8_t txPin = CONFIG_PIN2;
      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);

      PMSx003_type Plugin_053_sensortype = PMSx003_type::PMS1003_5003_7003;

      # ifdef PLUGIN_053_ENABLE_EXTRA_SENSORS
      Plugin_053_sensortype = GET_PLUGIN_053_SENSOR_MODEL_SELECTOR;
      # endif

      initPluginTaskData(
        event->TaskIndex,
        new (std::nothrow) P053_data_struct(
          event->TaskIndex,
          rxPin, txPin, port,
          PLUGIN_053_RST_PIN,
          PLUGIN_053_PWR_PIN,
          Plugin_053_sensortype,
          PLUGIN_053_SEC_IGNORE_AFTER_WAKE * 1000u
          # ifdef PLUGIN_053_ENABLE_EXTRA_SENSORS
          , bitRead(PLUGIN_053_DATA_PROCESSING_FLAGS, PLUGIN_053_OVERSAMPLING_BIT)
          , bitRead(PLUGIN_053_DATA_PROCESSING_FLAGS, PLUGIN_053_SPLIT_CNT_BINS_BIT)
          # endif
          ));
      P053_data_struct *P053_data =
        static_cast<P053_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P053_data) {
        success = P053_data->init();
      }

      break;
    }




    case PLUGIN_TEN_PER_SECOND:
    {
      P053_data_struct *P053_data =
        static_cast<P053_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P053_data) && P053_data->initialized()) {
        if (P053_data->packetAvailable()) {

          # ifndef BUILD_NO_DEBUG
          addLog(LOG_LEVEL_DEBUG_MORE, F("PMSx003 : Packet available"));
          # endif
          success = P053_data->processData(event);
          P053_data->clearPacket();
        }
      }
      break;
    }
    case PLUGIN_READ:
    {
      P053_data_struct *P053_data =
        static_cast<P053_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P053_data) && P053_data->initialized()) {

        success = P053_data->checkAndClearValuesReceived(event);
      }
      break;
    }
    case PLUGIN_WRITE:
    {
      P053_data_struct *P053_data =
        static_cast<P053_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P053_data) && P053_data->initialized()) {
        String command = parseString(string, 1);
        String subcommand = parseString(string, 2);

        if (equals(command, F("pmsx003"))) {
          if (equals(subcommand, F("wake"))) {
            success = P053_data->wakeSensor();
          } else if (equals(subcommand, F("sleep"))) {
            success = P053_data->sleepSensor();
          } else if (equals(subcommand, F("reset"))) {
            success = P053_data->resetSensor();
          }
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P054_DMX512.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P054
# 55 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P054_DMX512.ino"
#define PLUGIN_054 
#define PLUGIN_ID_054 54
#define PLUGIN_NAME_054 "Communication - DMX512 TX"

uint8_t* Plugin_054_DMXBuffer = 0;
int16_t Plugin_054_DMXSize = 32;

static inline void PLUGIN_054_Limit(int16_t& value, int16_t min, int16_t max)
{
  if (value < min)
    value = min;
  if (value > max)
    value = max;
}


boolean Plugin_054(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_054;
        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = false;
        Device[deviceCount].ValueCount = 0;
        Device[deviceCount].SendDataOption = false;
        Device[deviceCount].TimerOption = false;
        Device[deviceCount].TimerOptional = false;
        Device[deviceCount].GlobalSyncOption = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_054);
        break;
      }

    case PLUGIN_WEBFORM_LOAD:
      {
        CONFIG_PIN1 = 2;
        PCONFIG(0) = Plugin_054_DMXSize;
        addFormNote(F("Only GPIO-2 (D4) can be used as TX1!"));
        addFormNumericBox(F("Channels"), F("channels"), Plugin_054_DMXSize, 1, 512);
        success = true;
        break;
      }

    case PLUGIN_WEBFORM_SAVE:
      {
        CONFIG_PIN1 = 2;
        if (Settings.Pin_status_led == 2)
          Settings.Pin_status_led = -1;
        Plugin_054_DMXSize = getFormItemInt(F("channels"));
        PLUGIN_054_Limit (Plugin_054_DMXSize, 1, 512);
        PCONFIG(0) = Plugin_054_DMXSize;
        success = true;
        break;
      }

    case PLUGIN_INIT:
      {
        CONFIG_PIN1 = 2;
        Plugin_054_DMXSize = PCONFIG(0);

        if (Plugin_054_DMXBuffer) {
          delete [] Plugin_054_DMXBuffer;
        }
        Plugin_054_DMXBuffer = new (std::nothrow) uint8_t[Plugin_054_DMXSize];
        if (Plugin_054_DMXBuffer != nullptr) {
          memset(Plugin_054_DMXBuffer, 0, Plugin_054_DMXSize);
        }

        success = Plugin_054_DMXBuffer != nullptr;
        break;
      }

    case PLUGIN_EXIT:
      {
        if (Plugin_054_DMXBuffer) {
          delete [] Plugin_054_DMXBuffer;
        }
        break;
      }

    case PLUGIN_WRITE:
      {
        String lowerString=string;
        lowerString.toLowerCase();
        String command = parseString(lowerString, 1);

        if (equals(command, F("dmx")))
        {
          String param;
          String paramKey;
          String paramVal;
          uint8_t paramIdx = 2;
          int16_t channel = 1;
          int16_t value = 0;

          lowerString.replace(F("  "), " ");
          lowerString.replace(F(" ="), "=");
          lowerString.replace(F("= "), "=");

          param = parseString(lowerString, paramIdx++);
          if (param.length())
          {
            while (param.length())
            {
              #ifndef BUILD_NO_DEBUG
              addLog(LOG_LEVEL_DEBUG_MORE, param);
              #endif

              if (equals(param, F("log")))
              {
                if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                  String log = F("DMX  : ");
                  for (int16_t i = 0; i < Plugin_054_DMXSize; i++)
                  {
                    log += Plugin_054_DMXBuffer[i];
                    log += F(", ");
                  }
                  addLogMove(LOG_LEVEL_INFO, log);
                }
                success = true;
              }

              else if (equals(param, F("test")))
              {
                for (int16_t i = 0; i < Plugin_054_DMXSize; i++)

                  Plugin_054_DMXBuffer[i] = rand()&255;
                success = true;
              }

              else if (equals(param, F("on")))
              {
                memset(Plugin_054_DMXBuffer, 255, Plugin_054_DMXSize);
                success = true;
              }

              else if (equals(param, F("off")))
              {
                memset(Plugin_054_DMXBuffer, 0, Plugin_054_DMXSize);
                success = true;
              }

              else
              {
                int16_t index = param.indexOf('=');
                if (index > 0)
                {
                  paramKey = param.substring(0, index);
                  paramVal = param.substring(index+1);
                  channel = paramKey.toInt();
                }
                else
                {
                  paramVal = param;
                }

                value = paramVal.toInt();
                PLUGIN_054_Limit (value, 0, 255);

                if (channel > 0 && channel <= Plugin_054_DMXSize)
                  Plugin_054_DMXBuffer[channel-1] = value;
                channel++;
              }

              param = parseString(lowerString, paramIdx++);
            }
          }
          else
          {

          }

          success = true;
        }

        break;
      }

    case PLUGIN_TEN_PER_SECOND:
      {
        if (Plugin_054_DMXBuffer)
        {
          int16_t sendPin = 2;


          Serial1.flush();


          Serial1.end();
          pinMode(sendPin, OUTPUT);
          digitalWrite(sendPin, LOW);
          delayMicroseconds(120);
          digitalWrite(sendPin, HIGH);
          delayMicroseconds(12);


          Serial1.begin(250000, SERIAL_8N2);
          Serial1.write(0);
          Serial1.write(Plugin_054_DMXBuffer, Plugin_054_DMXSize);
        }
        break;
      }

  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P055_Chiming.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P055
# 53 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P055_Chiming.ino"
#include "src/WebServer/Markup_Buttons.h"

#define PLUGIN_055 
#define PLUGIN_ID_055 55
#define PLUGIN_NAME_055 "Notify - Chiming"

#define PLUGIN_055_FIFO_SIZE 64
#define PLUGIN_055_FIFO_MASK (PLUGIN_055_FIFO_SIZE-1)

class CPlugin_055_Data
{
public:
  long millisStateEnd = 0;
  long millisChimeTime = 60;
  long millisPauseTime = 400;

  int pin[4] = {0};
  uint8_t lowActive = false;
  uint8_t chimeClock = true;

  char FIFO[PLUGIN_055_FIFO_SIZE] = {0};
  uint8_t FIFO_IndexR = 0;
  uint8_t FIFO_IndexW = 0;
};

static CPlugin_055_Data* Plugin_055_Data = nullptr;


boolean Plugin_055(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_055;
        Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = true;
        Device[deviceCount].FormulaOption = false;
        Device[deviceCount].ValueCount = 0;
        Device[deviceCount].SendDataOption = false;
        Device[deviceCount].TimerOption = false;
        Device[deviceCount].TimerOptional = false;
        Device[deviceCount].GlobalSyncOption = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_055);
        break;
      }

    case PLUGIN_GET_DEVICEGPIONAMES:
      {
        event->String1 = formatGpioName_output(F("Driver#1"));
        event->String2 = formatGpioName_output(F("Driver#2"));
        event->String3 = formatGpioName_output(F("Driver#4"));
        break;
      }

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      string = F("Driver#8: ");
      string += formatGpioLabel(static_cast<int>(Settings.TaskDevicePin[3][event->TaskIndex]), false);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
      {

        if (PCONFIG(0) <= 0)
          PCONFIG(0) = 60;
        if (PCONFIG(1) <= 0)
          PCONFIG(1) = 400;


        addFormPinSelect(PinSelectPurpose::Generic_output, formatGpioName_output(F("Driver#8")), F("TDP4"), static_cast<int>(Settings.TaskDevicePin[3][event->TaskIndex]));

        addFormSubHeader(F("Timing"));

        addFormNumericBox(F("Chiming/Strike Time (ct)"), F("chimetime"), PCONFIG(0));
        addUnit(F("ms"));

        addFormNumericBox(F("Normal Pause Time (t)"), F("pausetime"), PCONFIG(1));
        addUnit(F("ms"));

        addFormNote(F("'1=1'&rArr;3t, '1-1' or '11'&rArr;1t, '1.1'&rArr;&#8531;t, '1|1'&rArr;&frac12;ct"));


        addFormSubHeader(F("Chiming Clock"));

        addFormCheckBox(F("Hourly Chiming Clock Strike"), F("chimeclock"), PCONFIG(2));

        addButton(F("'control?cmd=chimeplay,hours'"), F("Test 1&hellip;12"));

        if (PCONFIG(2) && !(Settings.UseNTP()))
          addFormNote(F("Enable and configure NTP!"));

        success = true;
        break;
      }

    case PLUGIN_WEBFORM_SAVE:
      {
        Settings.TaskDevicePin[3][event->TaskIndex] = (int8_t)getFormItemInt(F("TDP4"));

        PCONFIG(0) = getFormItemInt(F("chimetime"));
        PCONFIG(1) = getFormItemInt(F("pausetime"));
        PCONFIG(2) = isFormItemChecked(F("chimeclock"));

        success = true;
        break;
      }

    case PLUGIN_INIT:
      {
        if (!Plugin_055_Data)
          Plugin_055_Data = new (std::nothrow) CPlugin_055_Data();

        if (Plugin_055_Data != nullptr) {
          Plugin_055_Data->lowActive = Settings.TaskDevicePin1Inversed[event->TaskIndex];
          Plugin_055_Data->millisChimeTime = PCONFIG(0);
          Plugin_055_Data->millisPauseTime = PCONFIG(1);
          Plugin_055_Data->chimeClock = PCONFIG(2);

          String log = F("Chime: GPIO: ");
          for (uint8_t i=0; i<4; i++)
          {
            int pin = Settings.TaskDevicePin[i][event->TaskIndex];
            Plugin_055_Data->pin[i] = pin;
            if (pin >= 0)
            {
              pinMode(pin, OUTPUT);
              digitalWrite(pin, Plugin_055_Data->lowActive);
            }
            log += pin;
            log += ' ';
          }
          if (Plugin_055_Data->lowActive)
            log += F("!");
          addLogMove(LOG_LEVEL_INFO, log);
          success = true;
        }

        break;
      }

    case PLUGIN_EXIT:
      {
        if (Plugin_055_Data != nullptr) {
          delete Plugin_055_Data;
          Plugin_055_Data = nullptr;
        }
        break;
      }

    case PLUGIN_WRITE:
      {
        if (!Plugin_055_Data)
          break;

        String command = parseString(string, 1);

        if (equals(command, F("chime")))
        {
          String param = parseStringToEndKeepCase(string, 2);
          if (param.length() > 0) {
            Plugin_055_AddStringFIFO(param);
          }
          success = true;
        }
        if (equals(command, F("chimeplay")))
        {
          String name = parseString(string, 2);
          if (name.length() > 0) {
            String param;
            Plugin_055_ReadChime(name, param);
            Plugin_055_AddStringFIFO(param);
          }
          success = true;
        }
        if (equals(command, F("chimesave")))
        {
          String name = parseString(string, 2);
          String param = parseStringToEndKeepCase(string, 3);
          if (name.length() > 0 && param.length() > 0) {
            Plugin_055_WriteChime(name, param);
            Plugin_055_AddStringFIFO("1");
          }
          success = true;
        }

        break;
      }

      case PLUGIN_CLOCK_IN:
        {
          if (!Plugin_055_Data)
            break;

          String tokens;
          uint8_t hours = node_time.hour();
          uint8_t minutes = node_time.minute();

          if (Plugin_055_Data->chimeClock)
          {
            char tmpString[8] = {0};

            sprintf_P(tmpString, PSTR("%02d%02d"), hours, minutes);
            if (Plugin_055_ReadChime(tmpString, tokens))
              Plugin_055_AddStringFIFO(tokens);

            if (minutes == 0)
            {
              if (Plugin_055_ReadChime("hours", tokens) == 0)
                tokens = F("1111!,111!1,111!1!,11!11,11!11!,11!1!1,11!1!1!,1!111,1!111!,1!11!1,1!11!1!,1!1!11");


              hours = hours % 12;
              if (hours == 0)
                hours = 12;

              uint8_t index = hours;

              tokens = parseString(tokens, index);
              Plugin_055_AddStringFIFO(tokens);
            }
          }

          success = true;
          break;
        }


    case PLUGIN_FIFTY_PER_SECOND:

      {
        if (!Plugin_055_Data)
          break;

        long millisAct = millis();

        if (Plugin_055_Data->millisStateEnd > 0)
        {
          if (timeDiff(millisAct, Plugin_055_Data->millisStateEnd) <= 0)
          {
            for (uint8_t i=0; i<4; i++)
            {
              if (Plugin_055_Data->pin[i] >= 0)
                digitalWrite(Plugin_055_Data->pin[i], Plugin_055_Data->lowActive);
            }
            Plugin_055_Data->millisStateEnd = 0;
          }
        }

        if (Plugin_055_Data->millisStateEnd == 0)
        {
          if (! Plugin_055_IsEmptyFIFO())
          {
            char c = Plugin_055_ReadFIFO();
            # ifndef BUILD_NO_DEBUG
            if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
              String log = F("Chime: Process '");
              log += c;
              log += '\'';
              addLogMove(LOG_LEVEL_DEBUG, log);
            }
            #endif

            switch (c)
            {
              case 'a':
              case 'b':
              case 'c':
              case 'd':
              case 'e':
              case 'f':
              case 'A':
              case 'B':
              case 'C':
              case 'D':
              case 'E':
              case 'F':
                c -= 'A' - '0' - 10;


              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
              {
                uint8_t mask = 1;
                for (uint8_t i=0; i<4; i++)
                {
                  if (Plugin_055_Data->pin[i] >= 0)
                    if (c & mask)
                      digitalWrite(Plugin_055_Data->pin[i], !Plugin_055_Data->lowActive);
                  mask <<= 1;
                }
                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisChimeTime;
                break;
              }
              case '=':
              case ' ':
              case ',':
                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisPauseTime*3;
                break;
              case '-':
                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisPauseTime;
                break;
              case '.':
                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisPauseTime/3;
                break;
              case '|':
                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisChimeTime/2;
                break;
              case '#':
                while (Plugin_055_ReadFIFO());
                break;
              default:
                break;
            }
          }

        }
        success = true;
        break;
      }

  }
  return success;
}



void Plugin_055_WriteFIFO(char c)
{
  if (Plugin_055_Data->FIFO_IndexR == ((Plugin_055_Data->FIFO_IndexW+1) & PLUGIN_055_FIFO_MASK))
    return;

  Plugin_055_Data->FIFO[Plugin_055_Data->FIFO_IndexW] = c;
  Plugin_055_Data->FIFO_IndexW++;
  Plugin_055_Data->FIFO_IndexW &= PLUGIN_055_FIFO_MASK;
}

char Plugin_055_ReadFIFO()
{
  if (Plugin_055_IsEmptyFIFO())
    return '\0';

  char c = Plugin_055_Data->FIFO[Plugin_055_Data->FIFO_IndexR];
  Plugin_055_Data->FIFO_IndexR++;
  Plugin_055_Data->FIFO_IndexR &= PLUGIN_055_FIFO_MASK;

  return c;
}

char Plugin_055_PeekFIFO()
{
  if (Plugin_055_IsEmptyFIFO())
    return '\0';

  return Plugin_055_Data->FIFO[Plugin_055_Data->FIFO_IndexR];
}

boolean Plugin_055_IsEmptyFIFO()
{
  return (Plugin_055_Data->FIFO_IndexR == Plugin_055_Data->FIFO_IndexW);
}

void Plugin_055_AddStringFIFO(const String& param)
{
  if (param.isEmpty())
    return;

  uint8_t i = 0;
  char c = param[i];
  char c_last = '\0';

  while (c != 0)
  {
    if (isDigit(c) && isDigit(c_last))
      Plugin_055_WriteFIFO('-');
    if (c == '!')
    {
      Plugin_055_WriteFIFO('|');
      c = c_last;
    }
    Plugin_055_WriteFIFO(c);
    c_last = c;

    c = param[++i];
  }

  Plugin_055_WriteFIFO('=');
}



void Plugin_055_WriteChime(const String& name, const String& tokens)
{
  const String fileName = strformat(F("chime_%s.txt"), name.c_str());

  String log;
  if (loglevelActiveFor(LOG_LEVEL_INFO))
    log = strformat(F("Chime: write %s "), fileName.c_str());

  fs::File f = tryOpenFile(fileName, "w");
  if (f)
  {
    f.print(tokens);
    f.close();

    if (loglevelActiveFor(LOG_LEVEL_INFO))
      log += tokens;
  }

  addLogMove(LOG_LEVEL_INFO, log);
}

uint8_t Plugin_055_ReadChime(const String& name, String& tokens)
{
  const String fileName = strformat(F("chime_%s.txt"), name.c_str());

  String log;
  if (loglevelActiveFor(LOG_LEVEL_INFO))
    log = strformat(F("Chime: read %s "), fileName.c_str());

  tokens = String();
  fs::File f = tryOpenFile(fileName, "r");
  if (f)
  {
    tokens.reserve(f.size());
    char c;
    while (f.available())
    {
      c = f.read();
      tokens += c;
    }
    f.close();
    if (loglevelActiveFor(LOG_LEVEL_INFO))
      log += tokens;
  }

  addLogMove(LOG_LEVEL_INFO, log);

  return tokens.length();
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P056_SDS011-Dust.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P056
# 18 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P056_SDS011-Dust.ino"
#define PLUGIN_056 
#define PLUGIN_ID_056 56
#define PLUGIN_NAME_056 "Dust - SDS011/018/198"
#define PLUGIN_VALUENAME1_056 "PM2.5"
#define PLUGIN_VALUENAME2_056 "PM10"

# include <jkSDS011.h>

#include "ESPEasy-Globals.h"


CjkSDS011 *Plugin_056_SDS = nullptr;


boolean Plugin_056(uint8_t function, struct EventStruct *event, String& string)
{
  bool success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_056;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = false;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_056);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_056));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_056));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      serialHelper_getGpioNames(event, false, true);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {

      if (Plugin_056_hasTxPin(event)) {
        addFormNumericBox(F("Sleep time"), F("sleeptime"),
                          PCONFIG(0),
                          0, 30);
        addUnit(F("Minutes"));
        addFormNote(F("0 = continous, 1..30 = Work 30 seconds and sleep n*60-30 seconds"));
      }
      break;
    }
    case PLUGIN_WEBFORM_SAVE:
    {
      if (Plugin_056_hasTxPin(event)) {

        const int newsleeptime = getFormItemInt(F("sleeptime"));

        if (PCONFIG(0) != newsleeptime) {
          PCONFIG(0) = newsleeptime;
          Plugin_056_setWorkingPeriod(newsleeptime);
        }
      }
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      if (Plugin_056_SDS) {
        delete Plugin_056_SDS;
      }

      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);
      Plugin_056_SDS = new (std::nothrow) CjkSDS011(port, CONFIG_PIN1, CONFIG_PIN2);

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log = F("SDS  : Init OK  ESP GPIO-pin RX:");
        log += CONFIG_PIN1;
        log += F(" TX:");
        log += CONFIG_PIN2;
        addLogMove(LOG_LEVEL_INFO, log);
      }

      success = true;
      break;
    }

    case PLUGIN_EXIT:
    {






      shouldReboot = true;
      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      if (!Plugin_056_SDS) {
        break;
      }

      Plugin_056_SDS->Process();

      if (Plugin_056_SDS->available())
      {
        const float pm2_5 = Plugin_056_SDS->GetPM2_5();
        const float pm10 = Plugin_056_SDS->GetPM10_();
          # ifndef BUILD_NO_DEBUG

        if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
          String log = F("SDS  : act ");
          log += pm2_5;
          log += ' ';
          log += pm10;
          addLogMove(LOG_LEVEL_DEBUG, log);
        }
          # endif

        if (Settings.TaskDeviceTimer[event->TaskIndex] == 0)
        {
          UserVar.setFloat(event->TaskIndex, 0, pm2_5);
          UserVar.setFloat(event->TaskIndex, 1, pm10);
          event->sensorType = Sensor_VType::SENSOR_TYPE_DUAL;
          sendData(event);
        }
      }

      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      if (!Plugin_056_SDS) {
        break;
      }

      float pm25, pm10;

      if (Plugin_056_SDS->ReadAverage(pm25, pm10)) {
        UserVar.setFloat(event->TaskIndex, 0, pm25);
        UserVar.setFloat(event->TaskIndex, 1, pm10);
        success = true;
      }
      break;
    }
  }

  return success;
}

boolean Plugin_056_hasTxPin(struct EventStruct *event) {
  const int16_t serial_tx = CONFIG_PIN2;

  return serial_tx >= 0;
}

String Plugin_056_ErrorToString(int error) {
  String log;

  if (error < 0) {
    log = F("comm error: ");
    log += error;
  }
  return log;
}

String Plugin_056_WorkingPeriodToString(int workingPeriod) {
  if (workingPeriod < 0) {
    return Plugin_056_ErrorToString(workingPeriod);
  }
  String log;

  if (workingPeriod > 0) {
    log += workingPeriod;
    log += F(" minutes");
  } else {
    log += F(" continuous");
  }
  return log;
}

void Plugin_056_setWorkingPeriod(int minutes) {
  if (!Plugin_056_SDS) {
    return;
  }
  Plugin_056_SDS->SetWorkingPeriod(minutes);

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {
    String log = F("SDS  : Working Period set to: ");
    log += Plugin_056_WorkingPeriodToString(minutes);
    addLogMove(LOG_LEVEL_INFO, log);
  }
}


#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P057_HT16K33_LED.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P057
# 68 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P057_HT16K33_LED.ino"
#define PLUGIN_057 
#define PLUGIN_ID_057 57
#define PLUGIN_NAME_057 "Display - HT16K33"


#include "src/PluginStructs/P057_data_struct.h"

boolean Plugin_057(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_057;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].TimerOptional = false;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_057);
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77 };
      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 8, i2cAddressValues, PCONFIG(0));
      } else {
        success = intArrayContains(8, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("7-Seg. Clock"));

      {
        int16_t choice = PCONFIG(1);
        const __FlashStringHelper * options[3] = { F("none"), F("7-Seg. HH:MM (24 hour)"), F("7-Seg. HH:MM (12 hour)") };
        addFormSelector(F("Clock Type"), F("clocktype"), 3, options, nullptr, choice);
      }

      addFormNumericBox(F("Seg. for <b>X</b>x:xx"), F("clocksegh10"), PCONFIG(2), 0, 7);
      addFormNumericBox(F("Seg. for x<b>X</b>:xx"), F("clocksegh1"), PCONFIG(3), 0, 7);
      addFormNumericBox(F("Seg. for xx:<b>X</b>x"), F("clocksegm10"), PCONFIG(4), 0, 7);
      addFormNumericBox(F("Seg. for xx:x<b>X</b>"), F("clocksegm1"), PCONFIG(5), 0, 7);

      addFormNumericBox(F("Seg. for Colon"), F("clocksegcol"), PCONFIG(6), -1, 7);
      addHtml(F(" Value "));
      addNumericBox(F("clocksegcolval"), PCONFIG(7), 0, 255);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("i2c_addr"));

      PCONFIG(1) = getFormItemInt(F("clocktype"));

      PCONFIG(2) = getFormItemInt(F("clocksegh10"));
      PCONFIG(3) = getFormItemInt(F("clocksegh1"));
      PCONFIG(4) = getFormItemInt(F("clocksegm10"));
      PCONFIG(5) = getFormItemInt(F("clocksegm1"));
      PCONFIG(6) = getFormItemInt(F("clocksegcol"));
      PCONFIG(7) = getFormItemInt(F("clocksegcolval"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P057_data_struct(PCONFIG(0)));
      break;
    }

    case PLUGIN_WRITE:
    {
      P057_data_struct *P057_data =
        static_cast<P057_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P057_data) {
        return false;
      }

      String command = parseString(string, 1);

      if (equals(command, F("mprint")))
      {
        String text = parseStringToEnd(string, 2);

        if (!text.isEmpty()) {
          uint8_t seg = 0;
          uint8_t txt = 0;
          bool setDot;

          P057_data->ledMatrix.ClearRowBuffer();

          while (txt < text.length() && text[txt] && seg < 8)
          {
            setDot = (txt < text.length() - 1 && text[txt + 1] == '.');
            char c = text[txt];
            P057_data->ledMatrix.SetDigit(seg, c, setDot);
            seg++;
            txt++;
            if (setDot) { txt++; }
          }
          P057_data->ledMatrix.TransmitRowBuffer();
          success = true;
        }
      }
      else if (equals(command, F("mbr"))) {
        String param = parseString(string, 2);
        int32_t brightness;

        if (validIntFromString(param, brightness)) {
          if ((brightness >= 0) && (brightness <= 255)) {
            P057_data->ledMatrix.SetBrightness(brightness);
          }
        }
        success = true;
      }
      else if ((equals(command, 'm')) || (equals(command, F("mx"))) || (equals(command, F("mnum"))))
      {
        String param;
        String paramKey;
        String paramVal;
        uint8_t paramIdx = 2;
        uint8_t seg = 0;
        uint16_t value = 0;

        String lowerString = string;
        lowerString.toLowerCase();
        lowerString.replace(F("  "), F(" "));
        lowerString.replace(F(" ="), F("="));
        lowerString.replace(F("= "), F("="));

        param = parseString(lowerString, paramIdx++);

        if (param.length())
        {
          while (param.length())
          {
            #ifndef BUILD_NO_DEBUG
            addLog(LOG_LEVEL_DEBUG_MORE, param);
            #endif

            if (equals(param, F("log")))
            {
              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log = F("MX   : ");

                for (uint8_t i = 0; i < 8; i++)
                {
                  log += String(P057_data->ledMatrix.GetRow(i), 16);
                  log += F("h, ");
                }
                addLogMove(LOG_LEVEL_INFO, log);
              }
              success = true;
            }

            else if (equals(param, F("test")))
            {
              for (uint8_t i = 0; i < 8; i++) {
                P057_data->ledMatrix.SetRow(i, 1 << i);
              }
              success = true;
            }

            else if (equals(param, F("clear")))
            {
              P057_data->ledMatrix.ClearRowBuffer();
              success = true;
            }

            else
            {
              int index = param.indexOf('=');

              if (index > 0)
              {
                paramKey = param.substring(0, index);
                paramVal = param.substring(index + 1);
                seg = paramKey.toInt();
              }
              else
              {
                paramVal = param;
              }

              if (equals(command, F("mnum")))
              {
                value = paramVal.toInt();

                if (value < 16) {
                  P057_data->ledMatrix.SetDigit(seg, value);
                }
                else {
                  P057_data->ledMatrix.SetRow(seg, value);
                }
              }
              else if (equals(command, F("mx")))
              {
                char *ep;
                value = strtol(paramVal.c_str(), &ep, 16);
                P057_data->ledMatrix.SetRow(seg, value);
              }
              else
              {
                value = paramVal.toInt();
                P057_data->ledMatrix.SetRow(seg, value);
              }

              success = true;
              seg++;
            }

            param = parseString(lowerString, paramIdx++);
          }
        }
        else
        {

        }

        if (success) {
          P057_data->ledMatrix.TransmitRowBuffer();
        }
        success = true;
      }

      break;
    }

    case PLUGIN_CLOCK_IN:
    {
            P057_data_struct *P057_data =
        static_cast<P057_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P057_data || (PCONFIG(1) == 0)) {
        break;
      }

      uint8_t hours = node_time.hour();
      uint8_t minutes = node_time.minute();


      P057_data->ledMatrix.SetDigit(PCONFIG(5), minutes % 10);
      P057_data->ledMatrix.SetDigit(PCONFIG(4), minutes / 10);

      if (PCONFIG(1) == 1) {

        P057_data->ledMatrix.SetDigit(PCONFIG(2), hours / 10);
        P057_data->ledMatrix.SetDigit(PCONFIG(3), hours % 10);
      } else if (PCONFIG(1) == 2) {
        if (hours < 12) {

          P057_data->ledMatrix.SetRow(PCONFIG(5), (P057_data->ledMatrix.GetRow(PCONFIG(5)) | 0x80));
        }

        hours = hours % 12;

        if (hours == 0) {
          hours = 12;
        }

        P057_data->ledMatrix.SetDigit(PCONFIG(3), hours % 10);

        if (hours < 10) {

          P057_data->ledMatrix.SetRow(PCONFIG(2), 0);
        } else {
          P057_data->ledMatrix.SetDigit(PCONFIG(2), hours / 10);
        }
      }



      P057_data->ledMatrix.TransmitRowBuffer();

      success = true;

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
                  P057_data_struct *P057_data =
        static_cast<P057_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P057_data || (PCONFIG(1) == 0)) {
        break;
      }

      if (PCONFIG(6) >= 0)
      {
        uint8_t act = ((uint16_t)millis() >> 9) & 1;
        static uint8_t last = 0;

        if (act != last)
        {
          last = act;
          P057_data->ledMatrix.SetRow(PCONFIG(6), (act) ? PCONFIG(7) : 0);
          P057_data->ledMatrix.TransmitRowBuffer();
        }
      }
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P058_HT16K33_KeyPad.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P058
# 32 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P058_HT16K33_KeyPad.ino"
#define PLUGIN_058 
#define PLUGIN_ID_058 58
#define PLUGIN_NAME_058 "Keypad - HT16K33"
#define PLUGIN_VALUENAME1_058 "ScanCode"


#include "src/PluginStructs/P058_data_struct.h"


boolean Plugin_058(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_058;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_058);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_058));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77 };
      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 8, i2cAddressValues, PCONFIG(0));
      } else {
        success = intArrayContains(8, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("i2c_addr"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P058_data_struct(PCONFIG(0)));
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P058_data_struct *P058_data =
        static_cast<P058_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P058_data) {
        uint8_t key;

        if (P058_data->readKey(key))
        {
          UserVar.setFloat(event->TaskIndex, 0, key);
          event->sensorType = Sensor_VType::SENSOR_TYPE_SWITCH;

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log = F("Mkey : key=0x");
            log += String(key, 16);
            addLogMove(LOG_LEVEL_INFO, log);
          }

          sendData(event);
        }
      }
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      success = true;
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P059_Encoder.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P059
# 20 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P059_Encoder.ino"
#define PLUGIN_059 
#define PLUGIN_ID_059 59
#define PLUGIN_NAME_059 "Switch Input - Rotary Encoder"
#define PLUGIN_VALUENAME1_059 "Counter"

# include <QEIx4.h>

std::map<unsigned int, std::shared_ptr<QEIx4> > P_059_sensordefs;

boolean Plugin_059(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_059;
      Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_059);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_059));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_input(F("A (CLK)"));
      event->String2 = formatGpioName_input(F("B (DT)"));
      event->String3 = formatGpioName_input_optional(F("I (Z)"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {

      if ((PCONFIG_LONG(0) == 0) && (PCONFIG_LONG(1) == 0)) {
        PCONFIG_LONG(1) = 100;
      }

      {
        const __FlashStringHelper *options[3] = { F("1"), F("2"), F("4") };
        int optionValues[3] = { 1, 2, 4 };
        addFormSelector(F("Mode"), F("mode"), 3, options, optionValues, PCONFIG(0));
        addUnit(F("pulses per cycle"));
      }

      addFormNumericBox(F("Limit min."), F("limitmin"), PCONFIG_LONG(0));
      addFormNumericBox(F("Limit max."), F("limitmax"), PCONFIG_LONG(1));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("mode"));

      PCONFIG_LONG(0) = getFormItemInt(F("limitmin"));
      PCONFIG_LONG(1) = getFormItemInt(F("limitmax"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      portStatusStruct newStatus;


      P_059_sensordefs.erase(event->TaskIndex);
      P_059_sensordefs[event->TaskIndex] = std::shared_ptr<QEIx4>(new QEIx4);

      P_059_sensordefs[event->TaskIndex]->begin(CONFIG_PIN1, CONFIG_PIN2, CONFIG_PIN3, PCONFIG(0));
      P_059_sensordefs[event->TaskIndex]->setLimit(PCONFIG_LONG(0), PCONFIG_LONG(1));
      P_059_sensordefs[event->TaskIndex]->setIndexTrigger(true);

      ExtraTaskSettings.TaskDeviceValueDecimals[event->BaseVarIndex] = 0;

      String log = F("QEI  : GPIO: ");

      for (uint8_t i = 0; i < 3; i++)
      {
        int pin = PIN(i);

        if (pin >= 0)
        {

          constexpr pluginID_t P059_PLUGIN_ID{PLUGIN_ID_059};

          const uint32_t key = createKey(P059_PLUGIN_ID, pin);


          newStatus = globalMapPortStatus[key];
          newStatus.task++;
          newStatus.mode = PIN_MODE_INPUT;
          newStatus.state = 0;
          savePortStatus(key, newStatus);


        }
        log += pin;
        log += ' ';
      }
      addLogMove(LOG_LEVEL_INFO, log);

      success = true;
      break;
    }

    case PLUGIN_EXIT:
    {
      P_059_sensordefs.erase(event->TaskIndex);
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      if (P_059_sensordefs.count(event->TaskIndex) != 0)
      {
        if (P_059_sensordefs[event->TaskIndex]->hasChanged())
        {
          long c = P_059_sensordefs[event->TaskIndex]->read();
          UserVar.setFloat(event->TaskIndex, 0, c);
          event->sensorType = Sensor_VType::SENSOR_TYPE_SWITCH;

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log = F("QEI  : ");
            log += c;
            addLogMove(LOG_LEVEL_INFO, log);
          }

          sendData(event);
        }
      }
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      if (P_059_sensordefs.count(event->TaskIndex) != 0)
      {
        UserVar.setFloat(event->TaskIndex, 0, P_059_sensordefs[event->TaskIndex]->read());
      }
      success = true;
      break;
    }

    case PLUGIN_WRITE:
    {
      if (P_059_sensordefs.count(event->TaskIndex) != 0)
      {
        String command = parseString(string, 1);

        if (equals(command, F("encwrite")))
        {
          if (event->Par1 >= 0)
          {
            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("QEI  : ");
              log += string;
              addLogMove(LOG_LEVEL_INFO, log);
            }
            P_059_sensordefs[event->TaskIndex]->write(event->Par1);
            Scheduler.schedule_task_device_timer(event->TaskIndex, millis());
          }
          success = true;
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P060_MCP3221.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P060
# 12 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P060_MCP3221.ino"
# include "src/PluginStructs/P060_data_struct.h"

#define PLUGIN_060 
#define PLUGIN_ID_060 60
#define PLUGIN_NAME_060 "Analog input - MCP3221"
#define PLUGIN_VALUENAME1_060 "Analog"


boolean Plugin_060(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_060;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_060);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_060));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x4D, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4E, 0x4F };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 8, i2cAddressValues, PCONFIG(0));
      } else {
        success = intArrayContains(8, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormCheckBox(F("Oversampling"), F("oversampling"), PCONFIG(1));

      addFormSubHeader(F("Two Point Calibration"));

      addFormCheckBox(F("Calibration Enabled"), F("cal"), PCONFIG(3));

      addFormNumericBox(F("Point 1"), F("adc1"), PCONFIG_LONG(0), 0, 4095);
      html_add_estimate_symbol();
      addTextBox(F("out1"), toString(PCONFIG_FLOAT(0), 3), 10);

      addFormNumericBox(F("Point 2"), F("adc2"), PCONFIG_LONG(1), 0, 4095);
      html_add_estimate_symbol();
      addTextBox(F("out2"), toString(PCONFIG_FLOAT(1), 3), 10);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("i2c_addr"));

      PCONFIG(1) = isFormItemChecked(F("oversampling"));

      PCONFIG(3) = isFormItemChecked(F("cal"));

      PCONFIG_LONG(0) = getFormItemInt(F("adc1"));
      PCONFIG_FLOAT(0) = getFormItemFloat(F("out1"));

      PCONFIG_LONG(1) = getFormItemInt(F("adc2"));
      PCONFIG_FLOAT(1) = getFormItemFloat(F("out2"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P060_data_struct(PCONFIG(0)));
      break;
    }


    case PLUGIN_TEN_PER_SECOND:
    {
      if (PCONFIG(1))
      {
        P060_data_struct *P060_data =
          static_cast<P060_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P060_data) {
          P060_data->overSampleRead();
          success = true;
        }
      }
      break;
    }

    case PLUGIN_READ:
    {
      P060_data_struct *P060_data =
        static_cast<P060_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P060_data) {
        UserVar.setFloat(event->TaskIndex, 0, P060_data->getValue());

        String log = F("ADMCP: Analog value: ");
        log += formatUserVarNoCheck(event->TaskIndex, 0);

        if (PCONFIG(3))
        {
          int adc1 = PCONFIG_LONG(0);
          int adc2 = PCONFIG_LONG(1);
          float out1 = PCONFIG_FLOAT(0);
          float out2 = PCONFIG_FLOAT(1);

          if (adc1 != adc2)
          {
            const float normalized = (UserVar[event->BaseVarIndex] - adc1) / static_cast<float>(adc2 - adc1);
            UserVar.setFloat(event->TaskIndex, 0, normalized * (out2 - out1) + out1);

            log += F(" = ");
            log += formatUserVarNoCheck(event->TaskIndex, 0);
          }
        }

        addLogMove(LOG_LEVEL_INFO, log);
        success = true;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P061_KeyPad.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P061
# 76 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P061_KeyPad.ino"
# include "src/PluginStructs/P061_data_struct.h"

#define PLUGIN_061 
#define PLUGIN_ID_061 61
#define PLUGIN_NAME_061 "Keypad - PCF8574 / MCP23017 / PCF8575"
#define PLUGIN_VALUENAME1_061 "ScanCode"


boolean Plugin_061(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_061;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_061);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_061));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"),
                           (P061_CONFIG_KEYPAD_TYPE == 0 || P061_CONFIG_KEYPAD_TYPE > 2) ? 8 : 16,
                           i2cAddressValues,
                           P061_CONFIG_I2C_ADDRESS);

        if ((P061_CONFIG_KEYPAD_TYPE == 1) || (P061_CONFIG_KEYPAD_TYPE == 2)) {
          addFormNote(F("PCF8574 uses address 0x20+; PCF8574<b>A</b> uses address 0x38+"));
        }
      } else {
        success = intArrayContains(16, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P061_CONFIG_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      const __FlashStringHelper *options[] = {
        F("MCP23017 (Matrix 9x8)"),
        F("PCF8574 (Matrix 5x4)"),
        F("PCF8574 (Direct 8)"),
        F("MCP23017 (Direct 16)"),
        # ifdef P061_ENABLE_PCF8575
        F("PCF8575 (Matrix 9x8)"),
        F("PCF8575 (Direct 16)")
        # endif
      };
      int optionsCount =
      # ifdef P061_ENABLE_PCF8575
        6;
      # else
        4;
      # endif
      addFormSelector(F("Chip (Mode)"), F("chip"), optionsCount, options, nullptr, P061_CONFIG_KEYPAD_TYPE);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P061_CONFIG_I2C_ADDRESS = getFormItemInt(F("i2c_addr"));

      P061_CONFIG_KEYPAD_TYPE = getFormItemInt(F("chip"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P061_data_struct(P061_CONFIG_I2C_ADDRESS, P061_CONFIG_KEYPAD_TYPE));
      P061_data_struct *P061_data = static_cast<P061_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P061_data) {
        return success;
      }

      success = P061_data->plugin_init(event);

      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P061_data_struct *P061_data = static_cast<P061_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P061_data) {
        return success;
      }

      success = P061_data->plugin_fifty_per_second(event);
      break;
    }

    case PLUGIN_READ:
    {

      success = true;
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P062_MPR121_KeyPad.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P062
# 24 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P062_MPR121_KeyPad.ino"
#define PLUGIN_062 
#define PLUGIN_ID_062 62
#define PLUGIN_NAME_062 "Keypad - MPR121 Touch"
#define PLUGIN_VALUENAME1_062 "ScanCode"


# include "src/PluginStructs/P062_data_struct.h"

#define P062_FLAGS_USE_CALIBRATION 0

#define P062_CONFIG_FLAGS PCONFIG_LONG(0)

#define P062_DEFAULT_TOUCH_TRESHOLD 12
#define P062_DEFAULT_RELEASE_TRESHOLD 6

boolean Plugin_062(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_062;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].ExitTaskBeforeSave = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_062);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_062));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x5A, 0x5B, 0x5C, 0x5D };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 4, i2cAddressValues, PCONFIG(0));
      } else {
        success = intArrayContains(4, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormCheckBox(F("ScanCode"), F("scancode"), PCONFIG(1));

      addFormSubHeader(F("Sensitivity"));
      {
        uint8_t touch_treshold = PCONFIG(2);

        if (touch_treshold == 0) {
          touch_treshold = P062_DEFAULT_TOUCH_TRESHOLD;
        }
        addFormNumericBox(F("Touch treshold (1..255)"), F("touch_treshold"), touch_treshold, 0, 255);
        String unit_ = F("Default: ");
        unit_ += P062_DEFAULT_TOUCH_TRESHOLD;
        addUnit(unit_);
      }

      {
        uint8_t release_treshold = PCONFIG(3);

        if (release_treshold == 0) {
          release_treshold = P062_DEFAULT_RELEASE_TRESHOLD;
        }
        addFormNumericBox(F("Release treshold (1..255)"), F("release_treshold"), release_treshold, 0, 255);
        String unit_ = F("Default: ");
        unit_ += P062_DEFAULT_RELEASE_TRESHOLD;
        addUnit(unit_);
      }
      {
        const __FlashStringHelper *sensitivityOptions[] = {
          F("Normal"),
          F("Extra sensitive (behind 4-6mm glass cover)")
        };
        const int sensitivityValues[] = {
          MPR212_NORMAL_SENSITIVITY,
          MPR212_EXTRA_SENSITIVITY
        };
        addFormSelector(F("Panel sensitivity"), F("panel_sensitivity"), 2, sensitivityOptions, sensitivityValues, PCONFIG(4));
      }
      {
        bool canCalibrate = true;
        bool tbUseCalibration = bitRead(P062_CONFIG_FLAGS, P062_FLAGS_USE_CALIBRATION);

        P062_data_struct *P062_data = static_cast<P062_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr == P062_data) {
          P062_data = new (std::nothrow) P062_data_struct();
          canCalibrate = false;

          if (P062_data == nullptr) {
            return success;
          }
        }
        P062_data->loadTouchObjects(event->TaskIndex);

        addRowLabel(F("Object"));
        html_table(EMPTY_STRING, false);
        html_table_header(F("&nbsp;#&nbsp;"));
        html_table_header(F("Touch (0..255)"));
        html_table_header(F("Release (0..255)"));

        if (tbUseCalibration && canCalibrate) {
          html_table_header(F("Current"));
          html_table_header(F("Min"));
          html_table_header(F("Max"));
        }

        for (int objectNr = 0; objectNr < P062_MaxTouchObjects; objectNr++) {
          html_TR_TD();
          addHtml(F("&nbsp;"));
          addHtmlInt(objectNr + 1);
          html_TD();
          addNumericBox(getPluginCustomArgName(objectNr + 100), P062_data->StoredSettings.TouchObjects[objectNr].touch, 0, 255);
          html_TD();
          addNumericBox(getPluginCustomArgName(objectNr + 200), P062_data->StoredSettings.TouchObjects[objectNr].release, 0, 255);

          if (tbUseCalibration && canCalibrate) {
            uint16_t current = 0;
            uint16_t min = 0;
            uint16_t max = 0;
            P062_data->getCalibrationData(objectNr, &current, &min, &max);
            html_TD();
            addHtmlInt(current);
            html_TD();
            addHtmlInt(min);
            html_TD();
            addHtmlInt(max);
          }
        }
        html_end_table();

        if (canCalibrate) {
          const int choice1 = tbUseCalibration ? 1 : 0;
          addFormSelector_YesNo(F("Enable Calibration"), F("use_calibration"), choice1, true);

          if (tbUseCalibration) {
            addFormCheckBox(F("Clear calibrationdata"), F("clear_calibrate"), false);
          }
        }
        delete P062_data;
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("i2c_addr"));

      PCONFIG(1) = isFormItemChecked(F("scancode"));

      PCONFIG(2) = getFormItemInt(F("touch_treshold"));
      PCONFIG(3) = getFormItemInt(F("release_treshold"));
      PCONFIG(4) = getFormItemInt(F("panel_sensitivity"));

      uint32_t lSettings = 0;
      bool tbUseCalibration = getFormItemInt(F("use_calibration")) == 1;
      bitWrite(lSettings, P062_FLAGS_USE_CALIBRATION, tbUseCalibration);
      P062_CONFIG_FLAGS = lSettings;

      {
        bool canCalibrate = true;
        P062_data_struct *P062_data = static_cast<P062_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr == P062_data) {
          P062_data = new (std::nothrow) P062_data_struct();
          canCalibrate = false;

          if (P062_data == nullptr) {
            return success;
          }
        }
        P062_data->loadTouchObjects(event->TaskIndex);

        for (int objectNr = 0; objectNr < P062_MaxTouchObjects; objectNr++) {
          P062_data->StoredSettings.TouchObjects[objectNr].touch = getFormItemIntCustomArgName(objectNr + 100);
          P062_data->StoredSettings.TouchObjects[objectNr].release = getFormItemIntCustomArgName(objectNr + 200);
        }
        # ifdef PLUGIN_062_DEBUG

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("P062_data save size: ");
          log += sizeof(P062_data->StoredSettings);
          addLogMove(LOG_LEVEL_INFO, log);
        }
        # endif
        SaveCustomTaskSettings(event->TaskIndex, reinterpret_cast<const uint8_t *>(&(P062_data->StoredSettings)),
                               sizeof(P062_data->StoredSettings));

        if (!canCalibrate) {
          delete P062_data;
          P062_data = nullptr;
        } else {
          bool clearCalibration = isFormItemChecked(F("clear_calibrate"));

          if (clearCalibration) {
            P062_data->clearCalibrationData();
            # ifdef PLUGIN_062_DEBUG
            addLog(LOG_LEVEL_INFO, F("p062 clear calibration"));
            # endif
          }
        }
      }
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      bool tbUseCalibration = bitRead(P062_CONFIG_FLAGS, P062_FLAGS_USE_CALIBRATION);

      initPluginTaskData(event->TaskIndex, new (std::nothrow) P062_data_struct());
      P062_data_struct *P062_data = static_cast<P062_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P062_data) {
        if (!P062_data->init(event->TaskIndex, PCONFIG(0), PCONFIG(1), tbUseCalibration, PCONFIG(4))) {
          clearPluginTaskData(event->TaskIndex);
          P062_data = nullptr;
        } else {
          success = true;

          uint8_t touch_treshold = PCONFIG(2);

          if (touch_treshold == 0) {
            touch_treshold = P062_DEFAULT_TOUCH_TRESHOLD;
          }
          uint8_t release_treshold = PCONFIG(3);

          if (release_treshold == 0) {
            release_treshold = P062_DEFAULT_RELEASE_TRESHOLD;
          }

          if ((touch_treshold != P062_DEFAULT_TOUCH_TRESHOLD) && (release_treshold != P062_DEFAULT_RELEASE_TRESHOLD)) {
            P062_data->setThresholds(touch_treshold, release_treshold);
          }

          for (uint8_t objectNr = 0; objectNr < P062_MaxTouchObjects; objectNr++) {
            if ((P062_data->StoredSettings.TouchObjects[objectNr].touch != 0) &&
                (P062_data->StoredSettings.TouchObjects[objectNr].release != 0)) {
              P062_data->setThreshold(objectNr,
                                      P062_data->StoredSettings.TouchObjects[objectNr].touch,
                                      P062_data->StoredSettings.TouchObjects[objectNr].release);
            }
          }
        }
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P062_data_struct *P062_data =
        static_cast<P062_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P062_data) {
        return success;
      } else {
        uint16_t key;

        if (P062_data->readKey(key))
        {
          UserVar.setFloat(event->TaskIndex, 0, key);
          event->sensorType = Sensor_VType::SENSOR_TYPE_SWITCH;

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log = F("Tkey : ");

            if (PCONFIG(1)) {
              log = F("ScanCode=0x");
            }
            else {
              log = F("KeyMap=0x");
            }
            log += String(key, 16);
            addLogMove(LOG_LEVEL_INFO, log);

            bool tbUseCalibration = bitRead(P062_CONFIG_FLAGS, P062_FLAGS_USE_CALIBRATION);

            if (tbUseCalibration) {
              uint16_t colMask = 0x01;
              log.reserve(55);

              for (uint8_t col = 0; col < P062_MaxTouchObjects; col++)
              {
                if (key & colMask)
                {
                  uint16_t current = 0;
                  uint16_t min = 0;
                  uint16_t max = 0;
                  P062_data->getCalibrationData(col, &current, &min, &max);
                  log = F("P062 touch #");
                  log += col;
                  log += F(" current: ");
                  log += current;
                  log += F(" min: ");
                  log += min;
                  log += F(" max: ");
                  log += max;
                  addLogMove(LOG_LEVEL_INFO, log);

                  if (!PCONFIG(1)) {
                    break;
                  }
                }
                colMask <<= 1;
              }
            }
          }

          sendData(event);
        }
      }
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      success = true;
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P063_TTP229_KeyPad.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P063
# 27 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P063_TTP229_KeyPad.ino"
#define PLUGIN_063 
#define PLUGIN_ID_063 63
#define PLUGIN_NAME_063 "Keypad - TTP229 Touch"
#define PLUGIN_VALUENAME1_063 "ScanCode"



uint16_t readTTP229(int16_t pinSCL, int16_t pinSDO)
{
  uint16_t value = 0;
  uint16_t mask = 1;

  pinMode(pinSDO, OUTPUT);
  digitalWrite(pinSDO, HIGH);
  delayMicroseconds(100);

  digitalWrite(pinSDO, LOW);
  delayMicroseconds(10);

  pinMode(pinSDO, INPUT);
  for (uint8_t i = 0; i < 16; i++)
  {
    digitalWrite(pinSCL, HIGH);
    delayMicroseconds(1);
    digitalWrite(pinSCL, LOW);
    if (!digitalRead(pinSDO))
      value |= mask;
    delayMicroseconds(1);
    mask <<= 1;
  }

  return value;
}


boolean Plugin_063(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_063;
        Device[deviceCount].Type = DEVICE_TYPE_DUAL;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = false;
        Device[deviceCount].ValueCount = 1;
        Device[deviceCount].SendDataOption = true;
        Device[deviceCount].TimerOption = true;
        Device[deviceCount].TimerOptional = true;
        Device[deviceCount].GlobalSyncOption = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_063);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_063));
        break;
      }

    case PLUGIN_GET_DEVICEGPIONAMES:
      {
        event->String1 = formatGpioName_output(F("SCL"));
        event->String2 = formatGpioName_bidirectional(F("SDO"));
        break;
      }

    case PLUGIN_WEBFORM_LOAD:
      {
        addFormCheckBox(F("ScanCode"), F("scancode"), PCONFIG(1));

        success = true;
        break;
      }

    case PLUGIN_WEBFORM_SAVE:
      {
        PCONFIG(1) = isFormItemChecked(F("scancode"));

        success = true;
        break;
      }

    case PLUGIN_INIT:
      {
        portStatusStruct newStatus;

        int16_t pinSCL = CONFIG_PIN1;
        int16_t pinSDO = CONFIG_PIN2;

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("Tkey : GPIO: ");
          log += pinSCL;
          log += ' ';
          log += pinSDO;
          addLogMove(LOG_LEVEL_INFO, log);
        }

        if (pinSCL >= 0 && pinSDO >= 0)
        {
          pinMode(pinSCL, OUTPUT);
          digitalWrite(pinSCL, LOW);

          constexpr pluginID_t P063_PLUGIN_ID{PLUGIN_ID_063};

          uint32_t key = createKey(P063_PLUGIN_ID, pinSCL);

          newStatus = globalMapPortStatus[key];
          newStatus.task++;
          newStatus.mode = PIN_MODE_OUTPUT;
          newStatus.state = 0;
          savePortStatus(key,newStatus);


          pinMode(pinSDO, OUTPUT);
          digitalWrite(pinSDO, LOW);
          key = createKey(P063_PLUGIN_ID, pinSDO);

          newStatus = globalMapPortStatus[key];
          newStatus.task++;
          newStatus.mode = PIN_MODE_INPUT;
          newStatus.state = 0;
          savePortStatus(key,newStatus);

        }

        success = true;
        break;
      }

    case PLUGIN_TEN_PER_SECOND:
      {
        static uint16_t keyLast = 0;
        int16_t pinSCL = CONFIG_PIN1;
        int16_t pinSDO = CONFIG_PIN2;

        if (pinSCL >= 0 && pinSDO >= 0)
        {
          uint16_t key = readTTP229(pinSCL, pinSDO);

          if (key && PCONFIG(1))
          {
            uint16_t colMask = 0x01;
            for (uint8_t col = 1; col <= 16; col++)
            {
              if (key & colMask)
              {
                key = col;
                break;
              }
              colMask <<= 1;
            }
          }

          if (keyLast != key)
          {
            keyLast = key;
            UserVar.setFloat(event->TaskIndex, 0, key);
            event->sensorType = Sensor_VType::SENSOR_TYPE_SWITCH;

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("Tkey : ");
              if (PCONFIG(1))
                log = F("ScanCode=0x");
              else
                log = F("KeyMap=0x");
              log += String(key, 16);
              addLogMove(LOG_LEVEL_INFO, log);
            }

            sendData(event);
          }
        }

        success = true;
        break;
      }

    case PLUGIN_READ:
      {

        success = true;
        break;
      }

  }
  return success;
}
#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P064_APDS9960.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P064
# 35 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P064_APDS9960.ino"
#define PLUGIN_064 
#define PLUGIN_ID_064 64
#define PLUGIN_NAME_064 "Gesture - APDS9960"
#define PLUGIN_GPL_VALUENAME1_064 "Gesture"
#define PLUGIN_GPL_VALUENAME2_064 "Proximity"
#define PLUGIN_GPL_VALUENAME3_064 "Light"

#define PLUGIN_RGB_VALUENAME1_064 "R"
#define PLUGIN_RGB_VALUENAME2_064 "G"
#define PLUGIN_RGB_VALUENAME3_064 "B"

#define PLUGIN_MODE_GPL_064 0
#define PLUGIN_MODE_RGB_064 1

#define P064_MODE PCONFIG(1)
#define P064_GGAIN PCONFIG(2)
#define P064_GLDRIVE PCONFIG(3)
#define P064_LED_BOOST PCONFIG(4)
#define P064_PGAIN PCONFIG(5)
#define P064_AGAIN PCONFIG(6)
#define P064_LDRIVE PCONFIG(7)

#define P064_IS_GPL_SENSOR (P064_MODE == PLUGIN_MODE_GPL_064)
#define P064_IS_RGB_SENSOR (P064_MODE == PLUGIN_MODE_RGB_064)


# include "src/PluginStructs/P064_data_struct.h"


boolean Plugin_064(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_064;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SWITCH;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_064);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      if (P064_IS_GPL_SENSOR) {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_GPL_VALUENAME1_064));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_GPL_VALUENAME2_064));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_GPL_VALUENAME3_064));
      } else {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_RGB_VALUENAME1_064));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_RGB_VALUENAME2_064));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_RGB_VALUENAME3_064));
      }
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x39);

      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x39;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *optionsPluginMode[2] = {
          F("Gesture/Proximity/Ambient Light Sensor"),
          F("R/G/B Colors") };
        const int optionsPluginModeValues[2] = { PLUGIN_MODE_GPL_064, PLUGIN_MODE_RGB_064 };
        addFormSelector(F("Plugin Mode"), F("mode"), 2, optionsPluginMode, optionsPluginModeValues, P064_MODE, true);
        # ifndef BUILD_NO_DEBUG
        addFormNote(F("After changing Plugin Mode you may want to change the Values names, below."));
        # endif
      }

      if (P064_IS_RGB_SENSOR
          && (strcmp_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_GPL_VALUENAME1_064)) == 0)
          && (strcmp_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_GPL_VALUENAME2_064)) == 0)
          && (strcmp_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_GPL_VALUENAME3_064)) == 0)) {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_RGB_VALUENAME1_064));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_RGB_VALUENAME2_064));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_RGB_VALUENAME3_064));


        UserVar.setFloat(event->TaskIndex, 0, 0.0f);
        UserVar.setFloat(event->TaskIndex, 1, 0.0f);
        UserVar.setFloat(event->TaskIndex, 2, 0.0f);
      }

      if (P064_IS_GPL_SENSOR
          && (strcmp_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_RGB_VALUENAME1_064)) == 0)
          && (strcmp_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_RGB_VALUENAME2_064)) == 0)
          && (strcmp_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_RGB_VALUENAME3_064)) == 0)) {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_GPL_VALUENAME1_064));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_GPL_VALUENAME2_064));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_GPL_VALUENAME3_064));


        UserVar.setFloat(event->TaskIndex, 0, 0.0f);
        UserVar.setFloat(event->TaskIndex, 1, 0.0f);
        UserVar.setFloat(event->TaskIndex, 2, 0.0f);
      }

      {

        const __FlashStringHelper *optionsGain[4] = {
          F("1x"),
          F("2x"),
          F("4x (default)"),
          F("8x") };
        const int optionsGainValues[4] = { PGAIN_1X, PGAIN_2X, PGAIN_4X, PGAIN_8X };


        const __FlashStringHelper *optionsLedDrive[4] = {
          F("100 mA (default)"),
          F("50 mA"),
          F("25 mA"),
          F("12.5 mA") };
        const int optionsLedDriveValues[4] = { LED_DRIVE_100MA, LED_DRIVE_50MA, LED_DRIVE_25MA, LED_DRIVE_12_5MA };


        String lightSensorGainLabel;
        String lightSensorDriveLabel;

        if (P064_IS_GPL_SENSOR) {
          addFormSubHeader(F("Gesture parameters"));

          addFormSelector(F("Gesture Gain"), F("ggain"), 4, optionsGain, optionsGainValues, P064_GGAIN);

          addFormSelector(F("Gesture LED Drive"), F("gldrive"), 4, optionsLedDrive, optionsLedDriveValues, P064_GLDRIVE);
          {

            const __FlashStringHelper *optionsLedBoost[4] = {
              F("100 %"),
              F("150 %"),
              F("200 %"),
              F("300 % (default)") };
            const int optionsLedBoostValues[4] = { LED_BOOST_100, LED_BOOST_150, LED_BOOST_200, LED_BOOST_300 };
            addFormSelector(F("Gesture LED Boost"), F("lboost"), 4, optionsLedBoost, optionsLedBoostValues, P064_LED_BOOST);
          }

          addFormSubHeader(F("Proximity & Ambient Light Sensor parameters"));

          addFormSelector(F("Proximity Gain"), F("pgain"), 4, optionsGain, optionsGainValues, P064_PGAIN);

          lightSensorGainLabel = F("Ambient Light Sensor Gain");
          lightSensorDriveLabel = F("Proximity & ALS LED Drive");
        } else {
          addFormSubHeader(F("R/G/B Colors parameters"));

          lightSensorGainLabel = F("Light Sensor Gain");
          lightSensorDriveLabel = F("Light Sensor LED Drive");
        }
        {

          const __FlashStringHelper *optionsALSGain[4] = {
            F("1x"),
            F("4x (default)"),
            F("16x"),
            F("64x") };
          addFormSelector(lightSensorGainLabel, F("again"), 4, optionsALSGain, optionsGainValues, P064_AGAIN);
        }
        addFormSelector(lightSensorDriveLabel, F("ldrive"), 4, optionsLedDrive, optionsLedDriveValues, P064_LDRIVE);
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P064_MODE = getFormItemInt(F("mode"));

      if (P064_IS_GPL_SENSOR) {
        P064_GGAIN = getFormItemInt(F("ggain"));
        P064_GLDRIVE = getFormItemInt(F("gldrive"));
        P064_LED_BOOST = getFormItemInt(F("lboost"));
        P064_PGAIN = getFormItemInt(F("pgain"));
      }
      P064_AGAIN = getFormItemInt(F("again"));
      P064_LDRIVE = getFormItemInt(F("ldrive"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P064_data_struct());
      P064_data_struct *P064_data = static_cast<P064_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P064_data) {
        String log = F("APDS : ");
        success = true;

        if (P064_data->sensor.init(P064_GGAIN, P064_GLDRIVE, P064_PGAIN, P064_AGAIN, P064_LDRIVE)) {
          log += F("Init");

          P064_data->sensor.enablePower();

          if (!P064_data->sensor.enableLightSensor(false)) {
            log += F("Error during light sensor init!");
            success = false;
          }

          if (P064_IS_GPL_SENSOR) {
            if (!P064_data->sensor.enableProximitySensor(false)) {
              log += F("Error during proximity sensor init!");
              success = false;
            }

            if (!P064_data->sensor.enableGestureSensor(false, P064_LED_BOOST)) {
              log += F("Error during gesture sensor init!");
              success = false;
            }
          }
        } else {
          log += F("Error during APDS-9960 init!");
          success = false;
        }

        addLogMove(LOG_LEVEL_INFO, log);
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P064_data_struct *P064_data = static_cast<P064_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr == P064_data) || (P064_MODE != PLUGIN_MODE_GPL_064) || !P064_data->sensor.isGestureAvailable()) {
        break;
      }

      const int gesture = P064_data->sensor.readGesture();

      if (gesture >= 0) {
        # ifndef BUILD_NO_DEBUG

        if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
          String log = F("APDS : Gesture=");

          switch (gesture) {
            case DIR_UP: log += F("UP"); break;
            case DIR_DOWN: log += F("DOWN"); break;
            case DIR_LEFT: log += F("LEFT"); break;
            case DIR_RIGHT: log += F("RIGHT"); break;
            case DIR_NEAR: log += F("NEAR"); break;
            case DIR_FAR: log += F("FAR"); break;
            default: log += F("NONE"); break;
          }
          log += F(" (");
          log += gesture;
          log += ')';
          addLogMove(LOG_LEVEL_DEBUG, log);
        }
        # endif

        UserVar.setFloat(event->TaskIndex, 0, static_cast<float>(gesture));
        event->sensorType = Sensor_VType::SENSOR_TYPE_SWITCH;

        sendData(event);
        success = true;
      }

      break;
    }

    case PLUGIN_READ:
    {
      P064_data_struct *P064_data = static_cast<P064_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P064_data) {

        success = true;

        if (P064_IS_GPL_SENSOR) {
          uint8_t proximity_data = 0;
          success = success && P064_data->sensor.readProximity(proximity_data);
          UserVar.setFloat(event->TaskIndex, 1, static_cast<float>(proximity_data));

          uint16_t ambient_light = 0;
          success = success && P064_data->sensor.readAmbientLight(ambient_light);
          UserVar.setFloat(event->TaskIndex, 2, static_cast<float>(ambient_light));
        } else {
          uint16_t red_light = 0;
          uint16_t green_light = 0;
          uint16_t blue_light = 0;
          success = success && (P064_data->sensor.readRedLight(red_light) &&
                                P064_data->sensor.readGreenLight(green_light) &&
                                P064_data->sensor.readBlueLight(blue_light));
          UserVar.setFloat(event->TaskIndex, 0, static_cast<float>(red_light));
          UserVar.setFloat(event->TaskIndex, 1, static_cast<float>(green_light));
          UserVar.setFloat(event->TaskIndex, 2, static_cast<float>(blue_light));
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P065_DRF0299_MP3.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P065
# 43 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P065_DRF0299_MP3.ino"
#define PLUGIN_065 
#define PLUGIN_ID_065 65
#define PLUGIN_NAME_065 "Notify - DFPlayer-Mini MP3"
#define PLUGIN_VALUENAME1_065 ""

# include <ESPeasySerial.h>

#define P065_DEFAULT_VOLUME 15
#define P065_VOLUME_DELAY 6

ESPeasySerial *P065_easySerial = nullptr;
uint8_t P065_initialVolumeSet = P065_VOLUME_DELAY;


boolean Plugin_065(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_065;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].GlobalSyncOption = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_065);
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      serialHelper_getGpioNames(event, true);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      # ifdef ESP8266
      CONFIG_PORT = static_cast<uint8_t>(ESPEasySerialPort::software);
      # endif
      # ifdef ESP32
      CONFIG_PORT = static_cast<uint8_t>(ESPEasySerialPort::serial1);
      # endif
      PCONFIG(0) = P065_DEFAULT_VOLUME;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_SERIAL_PARAMS:
    {
      if ((CONFIG_PIN1 != -1) && (CONFIG_PIN2 == -1)) {
        CONFIG_PIN2 = CONFIG_PIN1;
        CONFIG_PIN1 = -1;
      }
      # ifdef ESP32
      addFormNote(F("MP3 TX pin is unused, and will be reset to '- None -' on save!"));
      # endif
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Volume"), F("volume"), PCONFIG(0), 1, 30);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      CONFIG_PIN1 = -1;
      PCONFIG(0) = getFormItemInt(F("volume"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      if (P065_easySerial) {
        delete P065_easySerial;
      }

      if ((CONFIG_PIN1 != -1) && (CONFIG_PIN2 == -1)) {
        CONFIG_PIN2 = CONFIG_PIN1;
        CONFIG_PIN1 = -1;
      }

      P065_easySerial = new (std::nothrow) ESPeasySerial(static_cast<ESPEasySerialPort>(CONFIG_PORT), -1, CONFIG_PIN2);

      if (P065_easySerial != nullptr) {
        P065_easySerial->begin(9600);
        P065_initialVolumeSet = P065_VOLUME_DELAY;

        success = true;
      }
      break;
    }

    case PLUGIN_EXIT:
    {
      if (P065_easySerial != nullptr) {
        delete P065_easySerial;
        P065_easySerial = nullptr;
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      if ((P065_easySerial != nullptr) && (P065_initialVolumeSet > 0)) {
        P065_initialVolumeSet--;

        if (P065_initialVolumeSet == 0) {
          Plugin_065_SetVol(PCONFIG(0));
        }
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      if (!P065_easySerial) {
        break;
      }

      String command = parseString(string, 1);
      String param = parseString(string, 2);
      int32_t value;
      bool valueValid = validIntFromString(param, value);

      if (valueValid && equals(command, F("play")))
      {
        Plugin_065_Play(value);
        success = true;
      }

      if (equals(command, F("stop")))
      {
        Plugin_065_SendCmd(0x0E, 0);
        success = true;
      }

      if (valueValid && equals(command, F("vol")))
      {
        if (value == 0) { value = 30; }
        PCONFIG(0) = value;
        Plugin_065_SetVol(value);
        success = true;
      }

      if (valueValid && equals(command, F("eq")))
      {
        Plugin_065_SetEQ(value);
        success = true;
      }

      if (valueValid && equals(command, F("mode")))
      {
        Plugin_065_SetMode(value);
        success = true;
      }

      if (valueValid && equals(command, F("repeat")))
      {
        Plugin_065_SetRepeat(value);
        success = true;
      }

      if (success && loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log;
        log.reserve(20);
        log = F("MP3  : ");
        log += command;

        if (!equals(command, F("stop"))) {
          log += '=';
          log += value;
        }
        addLogMove(LOG_LEVEL_INFO, log);
      }
      break;
    }
  }
  return success;
}

void Plugin_065_Play(uint16_t track)
{
  if (track < 0) { track = 0; }

  if (track > 2999) { track = 2999; }

  Plugin_065_SendCmd(0x03, track);
}

void Plugin_065_SetVol(int8_t vol)
{
  if (vol < 1) { vol = 1; }

  if (vol > 30) { vol = 30; }

  Plugin_065_SendCmd(0x06, vol);
}

void Plugin_065_SetEQ(int8_t eq)
{
  if (eq < 0) { eq = 0; }

  if (eq > 5) { eq = 5; }

  Plugin_065_SendCmd(0x07, eq);
}

void Plugin_065_SetMode(int8_t mode)
{
  if (mode < 0) { mode = 0; }

  if (mode > 3) { mode = 3; }

  Plugin_065_SendCmd(0x08, mode);
}

void Plugin_065_SetRepeat(int8_t repeat)
{
  Plugin_065_SendCmd(0x11, (repeat <= 0) ? 0 : 1);
}

void Plugin_065_SendCmd(uint8_t cmd, int16_t data)
{
  if (!P065_easySerial) {
    return;
  }

  uint8_t buffer[10] = { 0x7E, 0xFF, 0x06, 0, 0x00, 0, 0, 0, 0, 0xEF };

  buffer[3] = cmd;
  buffer[5] = data >> 8;
  buffer[6] = data & 0xFF;

  int16_t checksum = -(buffer[1] + buffer[2] + buffer[3] + buffer[4] + buffer[5] + buffer[6]);

  buffer[7] = checksum >> 8;
  buffer[8] = checksum & 0xFF;

  P065_easySerial->write(buffer, 10);

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
    String log = F("MP3  : Send Cmd ");

    for (uint8_t i = 0; i < 10; i++) {
      log += String(buffer[i], 16);
      log += ' ';
    }
    addLogMove(LOG_LEVEL_DEBUG, log);
  }
  # endif
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P066_VEML6040.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P066
# 15 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P066_VEML6040.ino"
#define PLUGIN_066 
#define PLUGIN_ID_066 66
#define PLUGIN_NAME_066 "Color - VEML6040"
#define PLUGIN_VALUENAME1_066 "R"
#define PLUGIN_VALUENAME2_066 "G"
#define PLUGIN_VALUENAME3_066 "B"
#define PLUGIN_VALUENAME4_066 "W"

#define VEML6040_ADDR 0x10

#include <math.h>

boolean Plugin_066(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_066;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = false;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_066);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_066));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_066));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_066));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_066));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { VEML6040_ADDR };
      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 1, i2cAddressValues, VEML6040_ADDR);
      } else {
        success = (event->Par1 == VEML6040_ADDR);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = VEML6040_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper * optionsMode[6] = { F("40ms (16496)"), F("80ms (8248)"), F("160ms (4124)"), F("320ms (2062)"), F("640ms (1031)"), F(
                                    "1280ms (515)") };
        addFormSelector(F("Integration Time (Max Lux)"), F("itime"), 6, optionsMode, nullptr, PCONFIG(1));
      }

      {
        const __FlashStringHelper * optionsVarMap[6] = {
          F("R, G, B, W"),
          F("r, g, b, W - relative rgb [&#37;]"),
          F("r, g, b, W - relative rgb^Gamma [&#37;]"),
          F("R, G, B, Color Temperature [K]"),
          F("R, G, B, Ambient Light [Lux]"),
          F("Color Temperature [K], Ambient Light [Lux], Y, W") };
        addFormSelector(F("Value Mapping"), F("map"), 6, optionsVarMap, nullptr, PCONFIG(2));
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {

      PCONFIG(1) = getFormItemInt(F("itime"));
      PCONFIG(2) = getFormItemInt(F("map"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      VEML6040_Init(PCONFIG(1));

      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      float R, G, B, W;

      R = VEML6040_GetValue(0x08);
      G = VEML6040_GetValue(0x09);
      B = VEML6040_GetValue(0x0A);
      W = VEML6040_GetValue(0x0B);

      switch (PCONFIG(2))
      {
        default:
        case 0:
        {
          UserVar.setFloat(event->TaskIndex, 0, R);
          UserVar.setFloat(event->TaskIndex, 1, G);
          UserVar.setFloat(event->TaskIndex, 2, B);
          UserVar.setFloat(event->TaskIndex, 3, W);
          break;
        }
        case 1:
        {
          UserVar.setFloat(event->TaskIndex, 0, Plugin_066_CalcRelW(R, W) * 100.0f);
          UserVar.setFloat(event->TaskIndex, 1, Plugin_066_CalcRelW(G, W) * 100.0f);
          UserVar.setFloat(event->TaskIndex, 2, Plugin_066_CalcRelW(B, W) * 100.0f);
          UserVar.setFloat(event->TaskIndex, 3, W);
          break;
        }
        case 2:
        {
          UserVar.setFloat(event->TaskIndex, 0, powf(Plugin_066_CalcRelW(R, W), 0.4545) * 100.0f);
          UserVar.setFloat(event->TaskIndex, 1, powf(Plugin_066_CalcRelW(G, W), 0.4545) * 100.0f);
          UserVar.setFloat(event->TaskIndex, 2, powf(Plugin_066_CalcRelW(B, W), 0.4545) * 100.0f);
          UserVar.setFloat(event->TaskIndex, 3, W);
          break;
        }
        case 3:
        {
          UserVar.setFloat(event->TaskIndex, 0, R);
          UserVar.setFloat(event->TaskIndex, 1, G);
          UserVar.setFloat(event->TaskIndex, 2, B);
          UserVar.setFloat(event->TaskIndex, 3, Plugin_066_CalcCCT(R, G, B));
          break;
        }
        case 4:
        {
          UserVar.setFloat(event->TaskIndex, 0, R);
          UserVar.setFloat(event->TaskIndex, 1, G);
          UserVar.setFloat(event->TaskIndex, 2, B);
          UserVar.setFloat(event->TaskIndex, 3, Plugin_066_CalcAmbientLight(G, PCONFIG(1)));
          break;
        }
        case 5:
        {
          UserVar.setFloat(event->TaskIndex, 0, Plugin_066_CalcCCT(R, G, B));
          UserVar.setFloat(event->TaskIndex, 1, Plugin_066_CalcAmbientLight(G, PCONFIG(1)));
          UserVar.setFloat(event->TaskIndex, 2, (R + G + B) / 3.0f);
          UserVar.setFloat(event->TaskIndex, 3, W);
          break;
        }
      }
      success = true;
      break;
    }
  }
  return success;
}



void VEML6040_setControlReg(uint8_t data)
{
  Wire.beginTransmission(VEML6040_ADDR);
  Wire.write(0);
  Wire.write(data);
  Wire.write(0);
  Wire.endTransmission();
}

float VEML6040_GetValue(uint8_t reg)
{
  Wire.beginTransmission(VEML6040_ADDR);
  Wire.write(reg);
  Wire.endTransmission(false);
  Wire.requestFrom((uint8_t)VEML6040_ADDR, (uint8_t)0x2);

  if (Wire.available() == 2)
  {
    uint16_t lsb = Wire.read();
    uint16_t msb = Wire.read();
    return static_cast<float>((msb << 8) | lsb);
  }
  return -1.0f;
}

void VEML6040_Init(uint8_t it)
{
  VEML6040_setControlReg(it << 4);
}

float Plugin_066_CalcCCT(float R, float G, float B)
{
  if (G == 0) {
    return 0;
  }

  float CCTi = (R - B) / G + 0.5f;
  float CCT = 4278.6f * powf(CCTi, -1.2455f);

  return CCT;
}

float Plugin_066_CalcAmbientLight(float G, uint8_t it)
{
  float Sensitivity[6] = { 0.25168f, 0.12584f, 0.06292f, 0.03146f, 0.01573f, 0.007865f };

  return G * Sensitivity[it];
}

float Plugin_066_CalcRelW(float X, float W)
{
  if (W == 0) {
    return 0;
  }

  return X / W;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P067_HX711_Load_Cell.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P067
# 29 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P067_HX711_Load_Cell.ino"
#define PLUGIN_067 
#define PLUGIN_ID_067 67
#define PLUGIN_NAME_067 "Weight - HX711 Load Cell"
#define PLUGIN_VALUENAME1_067 "WeightChanA"
#define PLUGIN_VALUENAME2_067 "WeightChanB"

# include "./src/PluginStructs/P067_data_struct.h"

boolean Plugin_067(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_067;
      Device[deviceCount].Type = DEVICE_TYPE_DUAL;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = false;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_067);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_067));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_067));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("SCK"));
      event->String2 = formatGpioName_input(F("DT"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      float valFloat;


      addFormSubHeader(F("Measurement Channel A"));

      addFormCheckBox(F("Oversampling"), F("osChA"), P067_GET_CHANNEL_A_OS);

      {
        const __FlashStringHelper *optionsModeChanA[] = { F("Off"), F("Gain 64"), F("Gain 128") };
        addFormSelector(F("Mode"), F("modeChA"), 3, optionsModeChanA, nullptr, P067_GET_CHANNEL_A_MODE);
      }

      P067_int2float(P067_OFFSET_CHANNEL_A_1, P067_OFFSET_CHANNEL_A_2, &valFloat);
      addFormTextBox(F("Offset"), F("offsChA"), toString(valFloat, 3), 25);
      addHtml(F("&nbsp; &nbsp;&#8617; Tare: "));
      addCheckBox(F("tareChA"), 0);


      addFormSubHeader(F("Measurement Channel B"));

      addFormCheckBox(F("Oversampling"), F("osChB"), P067_GET_CHANNEL_B_OS);

      {
        const __FlashStringHelper *optionsModeChanB[] = { F("Off"), F("Gain 32") };
        addFormSelector(F("Mode"), F("modeChB"), 2, optionsModeChanB, nullptr, P067_GET_CHANNEL_B_MODE);
      }

      P067_int2float(P067_OFFSET_CHANNEL_B_1, P067_OFFSET_CHANNEL_B_2, &valFloat);
      addFormTextBox(F("Offset"), F("offsChB"), toString(valFloat, 3), 25);
      addHtml(F("&nbsp; &nbsp;&#8617; Tare: "));
      addCheckBox(F("tareChB"), 0);


      addFormSubHeader(F("Two Point Calibration Channel A"));
      addFormCheckBox(F("Calibration Enabled"), F("calChA"), P067_GET_CHANNEL_A_CALIB);

      addFormNumericBox(F("Point 1"), F("adc1ChA"), P067_CONFIG_CHANNEL_A_ADC1);
      html_add_estimate_symbol();
      addTextBox(F("out1ChA"), toString(P067_CONFIG_CHANNEL_A_OUT1, 3), 10);

      addFormNumericBox(F("Point 2"), F("adc2ChA"), P067_CONFIG_CHANNEL_A_ADC2);
      html_add_estimate_symbol();
      addTextBox(F("out2ChA"), toString(P067_CONFIG_CHANNEL_A_OUT2, 3), 10);


      addFormSubHeader(F("Two Point Calibration Channel B"));

      addFormCheckBox(F("Calibration Enabled"), F("calChB"), P067_GET_CHANNEL_B_CALIB);

      addFormNumericBox(F("Point 1"), F("adc1ChB"), P067_CONFIG_CHANNEL_B_ADC1);
      html_add_estimate_symbol();
      addTextBox(F("out1ChB"), toString(P067_CONFIG_CHANNEL_B_OUT1, 3), 10);

      addFormNumericBox(F("Point 2"), F("adc2ChB"), P067_CONFIG_CHANNEL_B_ADC2);
      html_add_estimate_symbol();
      addTextBox(F("out2ChB"), toString(P067_CONFIG_CHANNEL_B_OUT2, 3), 10);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      float valFloat;

      P067_CONFIG_FLAGS = 0;

      P067_SET_CHANNEL_A_OS(isFormItemChecked(F("osChA")));
      P067_SET_CHANNEL_B_OS(isFormItemChecked(F("osChB")));

      uint32_t tmp = P067_CONFIG_FLAGS;
      set2BitToUL(tmp, P067_CONFIG_CHANNEL_A_MODE, getFormItemInt(F("modeChA")));
      P067_CONFIG_FLAGS = tmp;

      P067_SET_CHANNEL_B_MODE(getFormItemInt(F("modeChB")));

      P067_SET_CHANNEL_A_CALIB(isFormItemChecked(F("calChA")));
      P067_SET_CHANNEL_B_CALIB(isFormItemChecked(F("calChB")));

      if (isFormItemChecked(F("tareChA"))) {
        valFloat = -UserVar[event->BaseVarIndex + 2];
      } else {
        valFloat = getFormItemFloat(F("offsChA"));
      }
      P067_float2int(valFloat, &P067_OFFSET_CHANNEL_A_1, &P067_OFFSET_CHANNEL_A_2);

      if (isFormItemChecked(F("tareChB"))) {
        valFloat = -UserVar[event->BaseVarIndex + 3];
      } else {
        valFloat = getFormItemFloat(F("offsChB"));
      }
      P067_float2int(valFloat, &P067_OFFSET_CHANNEL_B_1, &P067_OFFSET_CHANNEL_B_2);

      P067_CONFIG_CHANNEL_A_ADC1 = getFormItemInt(F("adc1ChA"));
      P067_CONFIG_CHANNEL_A_OUT1 = getFormItemFloat(F("out1ChA"));

      P067_CONFIG_CHANNEL_A_ADC2 = getFormItemInt(F("adc2ChA"));
      P067_CONFIG_CHANNEL_A_OUT2 = getFormItemFloat(F("out2ChA"));

      P067_CONFIG_CHANNEL_B_ADC1 = getFormItemInt(F("adc1ChB"));
      P067_CONFIG_CHANNEL_B_OUT1 = getFormItemFloat(F("out1ChB"));

      P067_CONFIG_CHANNEL_B_ADC2 = getFormItemInt(F("adc2ChB"));
      P067_CONFIG_CHANNEL_B_OUT2 = getFormItemFloat(F("out2ChB"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P067_data_struct(event,
                                                                               CONFIG_PIN1,
                                                                               CONFIG_PIN2));
      P067_data_struct *P067_data = static_cast<P067_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P067_data) {
        success = P067_data->init(event);
      }

      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P067_data_struct *P067_data = static_cast<P067_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P067_data) {
        success = P067_data->plugin_fifty_per_second(event);
      }

      break;
    }

    case PLUGIN_READ:
    {
      P067_data_struct *P067_data = static_cast<P067_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P067_data) {
        success = P067_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_WRITE:
    {
      P067_data_struct *P067_data = static_cast<P067_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P067_data) {
        success = P067_data->plugin_write(event, string);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P068_SHT3x.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P068

# include "src/PluginStructs/P068_data_struct.h"

# include "src/Helpers/Convert.h"
# include "src/Helpers/ESPEasy_math.h"
# 26 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P068_SHT3x.ino"
#define PLUGIN_068 
#define PLUGIN_ID_068 68
#define PLUGIN_NAME_068 "Environment - SHT3x"
#define PLUGIN_VALUENAME1_068 "Temperature"
#define PLUGIN_VALUENAME2_068 "Humidity"






boolean Plugin_068(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_068;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_HUM;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_068);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_068));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_068));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x44, 0x45 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, PCONFIG(0));
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Temperature offset"), F("tempoffset"), PCONFIG(1));
      addUnit(F("x 0.1C"));
      addFormNote(F("Offset in units of 0.1 degree Celsius"));
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("i2c_addr"));
      PCONFIG(1) = getFormItemInt(F("tempoffset"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P068_SHT3X(PCONFIG(0)));
      break;
    }

    case PLUGIN_READ:
    {
      P068_SHT3X *sht3x = static_cast<P068_SHT3X *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == sht3x) {
        addLog(LOG_LEVEL_ERROR, F("SHT3x: not initialised!"));
        return success;
      }

      sht3x->tmpOff = PCONFIG(1) / 10.0f;
      sht3x->readFromSensor();
      UserVar.setFloat(event->TaskIndex, 0, sht3x->tmp);
      UserVar.setFloat(event->TaskIndex, 1, sht3x->hum);

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log;

        if (log.reserve(25)) {
          log = F("SHT3x: Temperature: ");
          log += formatUserVarNoCheck(event->TaskIndex, 0);
          addLogMove(LOG_LEVEL_INFO, log);
          log = F("SHT3x: Humidity: ");
          log += formatUserVarNoCheck(event->TaskIndex, 1);
          addLogMove(LOG_LEVEL_INFO, log);
        }
      }
      success = true;
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P069_LM75A.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P069
# 16 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P069_LM75A.ino"
#define PLUGIN_069 
#define PLUGIN_ID_069 69
#define PLUGIN_NAME_069 "Environment - LM75A"
#define PLUGIN_VALUENAME1_069 "Temperature"


#include "src/PluginStructs/P069_data_struct.h"


boolean Plugin_069(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_069;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_069);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_069));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F };
      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 8, i2cAddressValues, PCONFIG(0));
      } else {
        success = intArrayContains(8, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("i2c_addr"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P069_data_struct(static_cast<uint8_t>(PCONFIG(0))));
      break;
    }

    case PLUGIN_READ:
    {
      P069_data_struct *P069_data =
        static_cast<P069_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P069_data) {
        return success;
      }

      P069_data->setAddress((uint8_t)PCONFIG(0));

      const float tempC = P069_data->getTemperatureInDegrees();
      UserVar.setFloat(event->TaskIndex, 0, tempC);
      success = !isnan(tempC);

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        if (!success) {
          addLog(LOG_LEVEL_INFO, F("LM75A: No reading!"));
        }
        else
        {
          String log = F("LM75A: Temperature: ");
          log += tempC;
          addLogMove(LOG_LEVEL_INFO, log);
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P070_NeoPixel_Clock.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P070

# include "src/PluginStructs/P070_data_struct.h"
# 23 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P070_NeoPixel_Clock.ino"
#define PLUGIN_070 
#define PLUGIN_ID_070 70
#define PLUGIN_NAME_070 "Output - NeoPixel Ring Clock"
#define PLUGIN_VALUENAME1_070 "Enabled"
#define PLUGIN_VALUENAME2_070 "Brightness"
#define PLUGIN_VALUENAME3_070 "Marks"


boolean Plugin_070(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_070;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].GlobalSyncOption = false;


      Device[deviceCount].ExitTaskBeforeSave = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_070);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_070));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_070));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_070));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("LED"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Clock configuration"));
      addFormNumericBox(F("12 o'clock LED position"), F("offset"), PCONFIG(3), 0, 59);
      addFormNote(F("Position of the 12 o'clock LED in the strip"));
      addFormCheckBox(F("Thick 12 o'clock mark"), F("thick_12_mark"), PCONFIG(4));
      addFormNote(F("Check to have 3 LEDs marking the 12 o'clock position"));
      addFormCheckBox(F("Clock display enabled"), F("enabled"), PCONFIG(0));
      addFormNote(F("LED activation"));
      addFormNumericBox(F("LED brightness"), F("brightness"), PCONFIG(1), 0, 255);
      addFormNote(F("Brightness level of the H/M/S hands (0-255)"));
      addFormNumericBox(F("Hour mark brightness"), F("marks"), PCONFIG(2), 0, 255);
      addFormNote(F("Brightness level of the hour marks (0-255)"));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = isFormItemChecked(F("enabled"));
      PCONFIG(1) = getFormItemInt(F("brightness"));
      PCONFIG(2) = getFormItemInt(F("marks"));
      PCONFIG(3) = getFormItemInt(F("offset"));
      PCONFIG(4) = isFormItemChecked(F("thick_12_mark"));
      P070_data_struct *P070_data = static_cast<P070_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P070_data) {
        P070_data->display_enabled = PCONFIG(0);
        P070_data->brightness = PCONFIG(1);
        P070_data->brightness_hour_marks = PCONFIG(2);
        P070_data->offset_12h_mark = PCONFIG(3);
        P070_data->thick_12_mark = PCONFIG(4);
        P070_data->calculateMarks();
      }

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P070_data_struct());
      P070_data_struct *P070_data = static_cast<P070_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P070_data) {
        return success;
      }
      P070_data->init(event);
      P070_data->calculateMarks();

      success = true;
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P070_data_struct *P070_data = static_cast<P070_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P070_data) {
        P070_data->Clock_update();
      }
      success = true;
      break;
    }

    case PLUGIN_WRITE:
    {
      String lowerString = string;
      lowerString.toLowerCase();
      String command = parseString(lowerString, 1);
      String param1 = parseString(lowerString, 2);
      String param2 = parseString(lowerString, 3);
      String param3 = parseString(lowerString, 4);

      P070_data_struct *P070_data = static_cast<P070_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P070_data) && (equals(command, F("clock")))) {
        int32_t val_Mode{};

        if (validIntFromString(param1, val_Mode)) {
          if ((val_Mode > -1) && (val_Mode < 2)) {
            P070_data->display_enabled = val_Mode;
            PCONFIG(0) = P070_data->display_enabled;
          }
        }
        int32_t val_Bright{};

        if (validIntFromString(param2, val_Bright)) {
          if ((val_Bright > -1) && (val_Bright < 256)) {
            P070_data->brightness = val_Bright;
            PCONFIG(1) = P070_data->brightness;
          }
        }
        int32_t val_Marks{};

        if (validIntFromString(param3, val_Marks)) {
          if ((val_Marks > -1) && (val_Marks < 256)) {
            P070_data->brightness_hour_marks = val_Marks;
            PCONFIG(2) = P070_data->brightness_hour_marks;
          }
        }
# 192 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P070_NeoPixel_Clock.ino"
        success = true;
      }
      break;
    }

    case PLUGIN_READ:
    {
      P070_data_struct *P070_data = static_cast<P070_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P070_data) {
        UserVar.setFloat(event->TaskIndex, 0, P070_data->display_enabled);
        UserVar.setFloat(event->TaskIndex, 1, P070_data->brightness);
        UserVar.setFloat(event->TaskIndex, 2, P070_data->brightness_hour_marks);

        success = true;
      }
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P071_Kamstrup401.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P071
# 15 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P071_Kamstrup401.ino"
#include <ESPeasySerial.h>

#include "src/ESPEasyCore/Serial.h"

#define PLUGIN_071 
#define PLUGIN_ID_071 71
#define PLUGIN_NAME_071 "Communication - Kamstrup Multical 401"
#define PLUGIN_VALUENAME1_071 "Heat"
#define PLUGIN_VALUENAME2_071 "Volume"

boolean Plugin_071_init = false;
uint8_t PIN_KAMSER_RX = 0;
uint8_t PIN_KAMSER_TX = 0;

boolean Plugin_071(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_071;
        Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = true;
        Device[deviceCount].ValueCount = 2;
        Device[deviceCount].SendDataOption = true;
        Device[deviceCount].TimerOption = true;
        Device[deviceCount].GlobalSyncOption = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_071);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_071));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_071));
        break;
      }

    case PLUGIN_GET_DEVICEGPIONAMES:
      {
        serialHelper_getGpioNames(event);
        break;
      }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
      {
        string += serialHelper_getSerialTypeLabel(event);
        success = true;
        break;
      }

    case PLUGIN_INIT:
      {
        Plugin_071_init = true;

        success = true;
        break;
      }

    case PLUGIN_WEBFORM_LOAD:
      {
        success = true;
        break;
      }

    case PLUGIN_WEBFORM_SAVE: {
      success = true;
      break;
    }

    case PLUGIN_READ:
      {
        PIN_KAMSER_RX = CONFIG_PIN1;
        PIN_KAMSER_TX = CONFIG_PIN2;
        const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);

        ESPeasySerial kamSer(port, PIN_KAMSER_RX, PIN_KAMSER_TX, false);

        pinMode(PIN_KAMSER_RX,INPUT);
        pinMode(PIN_KAMSER_TX,OUTPUT);


        uint8_t sendmsg1[] = { 175,163,177 };

        uint8_t r = 0;
        uint8_t to = 0;
        uint8_t i;
        char message[255];
        int parityerrors;


        kamSer.begin(300);
        for (int x = 0; x < 3; x++) {
          kamSer.write(sendmsg1[x]);
        }

        kamSer.flush();

        kamSer.begin(1200);

        to = 0;
        r = 0;
        i = 0;
        parityerrors = 0;
        char *tmpstr;
        ESPEASY_RULES_FLOAT_TYPE m_energy, m_volume;
        float m_tempin, m_tempout, m_tempdiff, m_power;
        long m_hours, m_flow;

        while(r != 0x0A)
        {
          if (kamSer.available())
          {

            r = kamSer.read();

            if (parity_check(r))
            {
               parityerrors += 1;
            }
            r = r & 127;

            message[i++] = char(r);
          }
          else
          {
            to++;
            delay(25);
          }

          if (i>=79)
          {
            if ( parityerrors == 0 )
            {


              message[i] = 0;

              tmpstr = strtok(message, " ");
              if (tmpstr){
               m_energy = atol(tmpstr)/3.6*1000;
              }
              else
               m_energy = 0;

              tmpstr = strtok(nullptr, " ");
              if (tmpstr)
               m_volume = atol(tmpstr);
              else
               m_volume = 0;

              tmpstr = strtok(nullptr, " ");
              if (tmpstr)
               m_hours = atol(tmpstr);
              else
               m_hours = 0;

              tmpstr = strtok(nullptr, " ");
              if (tmpstr)
               m_tempin = atol(tmpstr)/100.0f;
              else
               m_tempin = 0;

              tmpstr = strtok(nullptr, " ");
              if (tmpstr)
               m_tempout = atol(tmpstr)/100.0f;
              else
               m_tempout = 0;

              tmpstr = strtok(nullptr, " ");
              if (tmpstr)
               m_tempdiff = atol(tmpstr)/100.0f;
              else
               m_tempdiff = 0;

              tmpstr = strtok(nullptr, " ");
              if (tmpstr)
               m_power = atol(tmpstr)/10.0f;
              else
               m_power = 0;

              tmpstr = strtok(nullptr, " ");
              if (tmpstr)
               m_flow = atol(tmpstr);
              else
               m_flow = 0;
              {
               String log = F("Kamstrup output: ");
               log += m_energy;
               log += F(" MJ;  ");
               log += m_volume;
               log += F(" L; ");
               log += m_hours;
               log += F(" h; ");
               log += m_tempin;
               log += F(" C; ");
               log += m_tempout;
               log += F(" C; ");
               log += m_tempdiff;
               log += F(" C; ");
               log += m_power;
               log += ' ';
               log += m_flow;
               log += F(" L/H");

              }
              UserVar.setFloat(event->TaskIndex, 0, m_energy);
              UserVar.setFloat(event->TaskIndex, 1, m_volume);

              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log = F("Kamstrup  : Heat value: ");
                log += m_energy/1000;
                log += F(" kWh");
                addLogMove(LOG_LEVEL_INFO, log);
                log = F("Kamstrup  : Volume value: ");
                log += m_volume;
                log += F(" Liter");
                addLogMove(LOG_LEVEL_INFO, log);
              }
            }
            else
            {
              message[i] = 0;
              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log = F("ERR(PARITY):" );
                serialPrint("par");
                log += message;
                addLogMove(LOG_LEVEL_INFO, log);
              }


            }
            break;
          }
          if (to>100)
          {
            message[i] = 0;
            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("ERR(TIMEOUT):" );
              log += message;
              addLogMove(LOG_LEVEL_INFO, log);
            }



            break;
          }
        }




        success = true;
        break;
      }
  }
  return success;
}

bool parity_check(unsigned input) {
    bool inputparity = input & 128;
    int x = input & 127;

    int parity = 0;
    while(x != 0) {
        parity ^= x;
        x >>= 1;
    }

    if ( (parity & 0x1) != inputparity )
      return(1);
    else
      return(0);
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P072_HDC1080.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P072
# 14 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P072_HDC1080.ino"
#define PLUGIN_072 
#define PLUGIN_ID_072 72
#define PLUGIN_NAME_072 "Environment - HDC10xx (I2C)"
#define PLUGIN_VALUENAME1_072 "Temperature"
#define PLUGIN_VALUENAME2_072 "Humidity"


#define HDC1080_I2C_ADDRESS 0x40

boolean Plugin_072(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_072;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_HUM;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].I2CNoDeviceCheck = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_072);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_072));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_072));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == HDC1080_I2C_ADDRESS);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = HDC1080_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_INIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      uint8_t hdc1080_msb, hdc1080_lsb;
      uint16_t hdc1080_rawtemp, hdc1080_rawhum;
      float hdc1080_temp, hdc1080_hum;

      Wire.beginTransmission(HDC1080_I2C_ADDRESS);
      Wire.write(0x02);
      Wire.write(0b00000000);
      Wire.write(0x00);
      Wire.endTransmission();
      delay(10);

      Wire.beginTransmission(HDC1080_I2C_ADDRESS);
      Wire.write(0x00);
      Wire.endTransmission();
      delay(9);
      Wire.requestFrom(HDC1080_I2C_ADDRESS, 2);
      hdc1080_msb = Wire.read();
      hdc1080_lsb = Wire.read();
      hdc1080_rawtemp = hdc1080_msb << 8 | hdc1080_lsb;
      hdc1080_temp = (static_cast<float>(hdc1080_rawtemp) / 65536.0f) * 165.0f - 40.0f;

      Wire.beginTransmission(HDC1080_I2C_ADDRESS);
      Wire.write(0x01);
      Wire.endTransmission();
      delay(9);
      Wire.requestFrom(HDC1080_I2C_ADDRESS, 2);
      hdc1080_msb = Wire.read();
      hdc1080_lsb = Wire.read();
      hdc1080_rawhum = hdc1080_msb << 8 | hdc1080_lsb;
      hdc1080_hum = (static_cast<float>(hdc1080_rawhum) / 65536.0f) * 100.0f;

      UserVar.setFloat(event->TaskIndex, 0, hdc1080_temp);
      UserVar.setFloat(event->TaskIndex, 1, hdc1080_hum);

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        addLogMove(LOG_LEVEL_INFO, concat(F("HDC10xx: Temperature: "), formatUserVarNoCheck(event->TaskIndex, 0)));
        addLogMove(LOG_LEVEL_INFO, concat(F("HDC10xx: Humidity: "), formatUserVarNoCheck(event->TaskIndex, 1)));
      }
      success = true;
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P073_7DGT.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P073
# 71 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P073_7DGT.ino"
#define PLUGIN_073 
#define PLUGIN_ID_073 73
#define PLUGIN_NAME_073 "Display - 7-segment display"

# include "src/PluginStructs/P073_data_struct.h"

void tm1637_ShowDate6(struct EventStruct *event,
                      bool showTime = false);
void tm1637_ShowBuffer(struct EventStruct *event,
                       uint8_t firstPos,
                       uint8_t lastPos,
                       bool useBinaryData = false);


boolean Plugin_073(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_073;
      Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].TimerOptional = false;
      Device[deviceCount].GlobalSyncOption = true;

      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_073);
      break;
    }

    # ifdef P073_SCROLL_TEXT
    case PLUGIN_SET_DEFAULTS: {
      PCONFIG(3) = 10;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD: {
      addFormNote(F("TM1637:  1st=CLK-Pin, 2nd=DIO-Pin"));
      addFormNote(F("MAX7219: 1st=DIN-Pin, 2nd=CLK-Pin, 3rd=CS-Pin"));
      {
        const __FlashStringHelper *displtype[] = { F("TM1637 - 4 digit (colon)"),
                                                   F("TM1637 - 4 digit (dots)"),
                                                   F("TM1637 - 6 digit"),
                                                   F("MAX7219 - 8 digit") };
        addFormSelector(F("Display Type"), F("displtype"), 4, displtype, nullptr, PCONFIG(0));
      }
      {
        const __FlashStringHelper *displout[] = { F("Manual"),
                                                  F("Clock 24h - Blink"),
                                                  F("Clock 24h - No Blink"),
                                                  F("Clock 12h - Blink"),
                                                  F("Clock 12h - No Blink"),
                                                  F("Date") };
        addFormSelector(F("Display Output"), F("displout"), 6, displout, nullptr, PCONFIG(1));
      }

      addFormNumericBox(F("Brightness"), F("brightness"), PCONFIG(2), 0, 15);
      addUnit(F("0..15"));

      # ifdef P073_EXTRA_FONTS
      {
        const __FlashStringHelper *fontset[4] = { F("Default"),
                                                  F("Siekoo"),
                                                  F("Siekoo with uppercase 'CHNORUX'"),
                                                  F("dSEG7") };
        addFormSelector(F("Font set"), F("fontset"), 4, fontset, nullptr, PCONFIG(4));
        addFormNote(F("Check documentation for examples of the font sets."));
      }
      # endif

      addFormSubHeader(F("Options"));

      addFormCheckBox(F("Text show periods as dot"), F("periods"), bitRead(PCONFIG_LONG(0), P073_OPTION_PERIOD));

      addFormCheckBox(F("Hide &deg; for Temperatures"), F("hide_degree"), bitRead(PCONFIG_LONG(0), P073_OPTION_HIDEDEGREE));
      # ifdef P073_7DDT_COMMAND
      addFormNote(F("Commands 7dt,&lt;temp&gt; and 7ddt,&lt;temp1&gt;,&lt;temp2&gt;"));
      # else
      addFormNote(F("Command 7dt,&lt;temp&gt;"));
      # endif
      # ifdef P073_SUPPRESS_ZERO
      addFormCheckBox(F("Suppress leading 0 on day/hour"), F("supp0"), bitRead(PCONFIG_LONG(0), P073_OPTION_SUPPRESS0));
      # endif

      # ifdef P073_SCROLL_TEXT
      addFormCheckBox(F("Scroll text &gt; display width"), F("scroll_text"), bitRead(PCONFIG_LONG(0), P073_OPTION_SCROLLTEXT));
      addFormCheckBox(F("Scroll text in from right"), F("scroll_full"), bitRead(PCONFIG_LONG(0), P073_OPTION_SCROLLFULL));

      if (PCONFIG(3) == 0) { PCONFIG(3) = 10; }
      addFormNumericBox(F("Scroll speed (0.1 sec/step)"), F("scrollspeed"), PCONFIG(3), 1, 600);
      addUnit(F("1..600 = 0.1..60 sec/step"));
      # endif

      addFormSubHeader(F("Options for MAX7219 - 8 digit"));

      bool bRightAlign = bitRead(PCONFIG_LONG(0), P073_OPTION_RIGHTALIGN);
      addFormCheckBox(F("Right-align Temperature (7dt)"), F("temp_rightalign"), bRightAlign);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      PCONFIG(0) = getFormItemInt(F("displtype"));
      PCONFIG(1) = getFormItemInt(F("displout"));
      PCONFIG(2) = getFormItemInt(F("brightness"));
      uint32_t lSettings = 0;
      bitWrite(lSettings, P073_OPTION_PERIOD, isFormItemChecked(F("periods")));
      bitWrite(lSettings, P073_OPTION_HIDEDEGREE, isFormItemChecked(F("hide_degree")));
      bitWrite(lSettings, P073_OPTION_RIGHTALIGN, isFormItemChecked(F("temp_rightalign")));
      # ifdef P073_SCROLL_TEXT
      bitWrite(lSettings, P073_OPTION_SCROLLTEXT, isFormItemChecked(F("scroll_text")));
      bitWrite(lSettings, P073_OPTION_SCROLLFULL, isFormItemChecked(F("scroll_full")));
      PCONFIG(3) = getFormItemInt(F("scrollspeed"));
      # endif
      # ifdef P073_SUPPRESS_ZERO
      bitWrite(lSettings, P073_OPTION_SUPPRESS0, isFormItemChecked(F("supp0")));
      # endif
      # ifdef P073_EXTRA_FONTS
      PCONFIG(4) = getFormItemInt(F("fontset"));
      # endif
      PCONFIG_LONG(0) = lSettings;

      success = true;
      break;
    }

    case PLUGIN_EXIT: {
      success = true;
      break;
    }

    case PLUGIN_INIT: {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P073_data_struct());
      P073_data_struct *P073_data =
        static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P073_data) {
        P073_data->init(event);

        switch (P073_data->displayModel) {
          case P073_TM1637_4DGTCOLON:
          case P073_TM1637_4DGTDOTS:
          case P073_TM1637_6DGT: {
            tm1637_InitDisplay(CONFIG_PIN1, CONFIG_PIN2);
            tm1637_SetPowerBrightness(CONFIG_PIN1, CONFIG_PIN2, PCONFIG(2) / 2, true);

            if (PCONFIG(1) == P073_DISP_MANUAL) {
              tm1637_ClearDisplay(CONFIG_PIN1, CONFIG_PIN2);
            }
            break;
          }
          case P073_MAX7219_8DGT: {
            max7219_InitDisplay(event, CONFIG_PIN1, CONFIG_PIN2, CONFIG_PIN3);
            delay(10);
            max7219_SetPowerBrightness(event, CONFIG_PIN1, CONFIG_PIN2, CONFIG_PIN3, PCONFIG(2), true);

            if (PCONFIG(1) == P073_DISP_MANUAL) {
              max7219_ClearDisplay(event, CONFIG_PIN1, CONFIG_PIN2, CONFIG_PIN3);
            }
            break;
          }
        }
        success = true;
      }
      break;
    }

    case PLUGIN_WRITE: {
      success = p073_plugin_write(event, string);
      break;
    }

    case PLUGIN_ONCE_A_SECOND: {
      P073_data_struct *P073_data =
        static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr == P073_data) || (P073_data->output == P073_DISP_MANUAL)) {
        break;
      }

      if ((P073_data->output == P073_DISP_CLOCK24BLNK) ||
          (P073_data->output == P073_DISP_CLOCK12BLNK)) {
        P073_data->timesep = !P073_data->timesep;
      } else {
        P073_data->timesep = true;
      }

      if (P073_data->output == P073_DISP_DATE) {
        P073_data->FillBufferWithDate(true, 0, 0, 0,
                                      # ifdef P073_SUPPRESS_ZERO
                                      bitRead(PCONFIG_LONG(0), P073_OPTION_SUPPRESS0)
                                      # else
                                      false
                                      # endif
                                      );
      } else {
        P073_data->FillBufferWithTime(true, 0, 0, 0, !((P073_data->output == P073_DISP_CLOCK24BLNK) ||
                                                       (P073_data->output == P073_DISP_CLOCK24)),
                                      # ifdef P073_SUPPRESS_ZERO
                                      bitRead(PCONFIG_LONG(0), P073_OPTION_SUPPRESS0)
                                      # else
                                      false
                                      # endif
                                      );
      }

      switch (P073_data->displayModel) {
        case P073_TM1637_4DGTCOLON:
        case P073_TM1637_4DGTDOTS: {
          tm1637_ShowTimeTemp4(event, P073_data->timesep, 0);
          break;
        }
        case P073_TM1637_6DGT: {
          if (PCONFIG(1) == P073_DISP_DATE) {
            tm1637_ShowDate6(event);
          } else {
            tm1637_ShowTime6(event);
          }
          break;
        }
        case P073_MAX7219_8DGT: {
          if (PCONFIG(1) == P073_DISP_DATE) {
            max7219_ShowDate(event, P073_data->pin1, P073_data->pin2,
                             P073_data->pin3);
          } else {
            max7219_ShowTime(event, P073_data->pin1, P073_data->pin2,
                             P073_data->pin3, P073_data->timesep);
          }
          break;
        }
      }
      break;
    }

    # ifdef P073_SCROLL_TEXT
    case PLUGIN_TEN_PER_SECOND: {
      P073_data_struct *P073_data =
        static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P073_data) {
        break;
      }

      if ((P073_data->output != P073_DISP_MANUAL) || !P073_data->isScrollEnabled()) {
        break;
      }

      if (P073_data->NextScroll()) {
        switch (P073_data->displayModel) {
          case P073_TM1637_4DGTCOLON:
          case P073_TM1637_4DGTDOTS: {
            tm1637_ShowBuffer(event, 0, 4
                              # ifdef P073_7DBIN_COMMAND
                              , P073_data->binaryData
                              # endif
                              );
            break;
          }
          case P073_TM1637_6DGT: {
            tm1637_SwapDigitInBuffer(event, 0);
            tm1637_ShowBuffer(event, 0, 6
                              # ifdef P073_7DBIN_COMMAND
                              , P073_data->binaryData
                              # endif
                              );
            break;
          }
          case P073_MAX7219_8DGT: {
            P073_data->dotpos = -1;
            max7219_ShowBuffer(event, P073_data->pin1, P073_data->pin2,
                               P073_data->pin3);
            break;
          }
        }
      }
      break;
    }
    # endif
  }
  return success;
}

bool p073_plugin_write(struct EventStruct *event,
                       const String & string) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return false;
  }

  const String cmd = parseString(string, 1);

  if ((cmd.length() < 3) || (cmd[0] != '7')) { return false; }

  # ifdef P073_SCROLL_TEXT
  const bool currentScroll = P073_data->isScrollEnabled();
  bool newScroll = false;
  P073_data->setScrollEnabled(false);
  # endif

  const String text = parseStringToEndKeepCase(string, 2);

  if (equals(cmd, F("7dn"))) {
    return p073_plugin_write_7dn(event, text);
  } else if (equals(cmd, F("7dt"))) {
    return p073_plugin_write_7dt(event, text);
  # ifdef P073_7DDT_COMMAND
  } else if (equals(cmd, F("7ddt"))) {
    return p073_plugin_write_7ddt(event, text);
  # endif
  } else if (equals(cmd, F("7dst"))) {
    return p073_plugin_write_7dst(event);
  } else if (equals(cmd, F("7dsd"))) {
    return p073_plugin_write_7dsd(event);
  } else if (equals(cmd, F("7dtext"))) {
    # ifdef P073_SCROLL_TEXT
    P073_data->setScrollEnabled(true);
    # endif
    return p073_plugin_write_7dtext(event, text);
  # ifdef P073_EXTRA_FONTS
  } else if (equals(cmd, F("7dfont"))) {
    # ifdef P073_SCROLL_TEXT
    P073_data->setScrollEnabled(currentScroll);
    # endif
    return p073_plugin_write_7dfont(event, text);
  # endif
  # ifdef P073_7DBIN_COMMAND
  } else if (equals(cmd, F("7dbin"))) {
    # ifdef P073_SCROLL_TEXT
    P073_data->setScrollEnabled(true);
    # endif
    return p073_plugin_write_7dbin(event, text);
  # endif
  } else {
    bool p073_validcmd = false;
    bool p073_displayon = false;

    if (equals(cmd, F("7don"))) {
      # ifdef P073_SCROLL_TEXT
      newScroll = currentScroll;
      # endif
      # ifndef BUILD_NO_DEBUG
      addLog(LOG_LEVEL_INFO, F("7DGT : Display ON"));
      # endif
      p073_displayon = true;
      p073_validcmd = true;
    } else if (equals(cmd, F("7doff"))) {
      # ifdef P073_SCROLL_TEXT
      newScroll = currentScroll;
      # endif
      # ifndef BUILD_NO_DEBUG
      addLog(LOG_LEVEL_INFO, F("7DGT : Display OFF"));
      # endif
      p073_displayon = false;
      p073_validcmd = true;
    } else if (equals(cmd, F("7db"))) {
      # ifdef P073_SCROLL_TEXT
      newScroll = currentScroll;
      # endif

      if ((event->Par1 >= 0) && (event->Par1 < 16)) {
        # ifndef BUILD_NO_DEBUG

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          addLog(LOG_LEVEL_INFO, concat(F("7DGT : Brightness="), event->Par1));
        }
        # endif
        P073_data->brightness = event->Par1;
        PCONFIG(2) = event->Par1;
        p073_displayon = true;
        p073_validcmd = true;
      }
    } else if (equals(cmd, F("7output"))) {
      if ((event->Par1 >= 0) && (event->Par1 < 6)) {

        # ifndef BUILD_NO_DEBUG

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          addLog(LOG_LEVEL_INFO, concat(F("7DGT : Display output="), event->Par1));
        }
        # endif
        P073_data->output = event->Par1;
        PCONFIG(1) = event->Par1;
        p073_displayon = true;
        p073_validcmd = true;
        # ifdef P073_SCROLL_TEXT

        if (event->Par1 == 0) { newScroll = currentScroll; }
        # endif
      }
    }

    if (p073_validcmd) {
      # ifdef P073_SCROLL_TEXT
      P073_data->setScrollEnabled(newScroll);
      # endif

      switch (P073_data->displayModel) {
        case P073_TM1637_4DGTCOLON:
        case P073_TM1637_4DGTDOTS:
        case P073_TM1637_6DGT:
        {
          tm1637_SetPowerBrightness(P073_data->pin1, P073_data->pin2,
                                    P073_data->brightness / 2, p073_displayon);
          break;
        }
        case P073_MAX7219_8DGT:
        {
          max7219_SetPowerBrightness(event, P073_data->pin1, P073_data->pin2,
                                     P073_data->pin3, P073_data->brightness,
                                     p073_displayon);
          break;
        }
      }
    }
    return p073_validcmd;
  }
  return false;
}

bool p073_plugin_write_7dn(struct EventStruct *event,
                           const String & text) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P073_data) || (P073_data->output != P073_DISP_MANUAL)) {
    return false;
  }

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {
    addLog(LOG_LEVEL_INFO, concat(F("7DGT : Show Number="), event->Par1));
  }
  # endif

  switch (P073_data->displayModel) {
    case P073_TM1637_4DGTCOLON:
    case P073_TM1637_4DGTDOTS:
    {
      if ((event->Par1 > -1000) && (event->Par1 < 10000)) {
        P073_data->FillBufferWithNumber(text.c_str());
      } else {
        P073_data->FillBufferWithDash();
      }
      tm1637_ShowBuffer(event, TM1637_4DIGIT, 8);
      break;
    }
    case P073_TM1637_6DGT:
    {
      if ((event->Par1 > -100000) && (event->Par1 < 1000000)) {
        P073_data->FillBufferWithNumber(text.c_str());
      } else {
        P073_data->FillBufferWithDash();
      }
      tm1637_SwapDigitInBuffer(event, 2);
      tm1637_ShowBuffer(event, TM1637_6DIGIT, 8);
      break;
    }
    case P073_MAX7219_8DGT:
    {
      if (!text.isEmpty()) {
        if ((event->Par1 > -10000000) && (event->Par1 < 100000000)) {
          P073_data->FillBufferWithNumber(text.c_str());
        } else {
          P073_data->FillBufferWithDash();
        }
        max7219_ShowBuffer(event, P073_data->pin1, P073_data->pin2,
                           P073_data->pin3);
      }
      break;
    }
  }
  return true;
}

bool p073_plugin_write_7dt(struct EventStruct *event,
                           const String & text) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P073_data) || (P073_data->output != P073_DISP_MANUAL)) {
    return false;
  }

  float p073_temptemp = 0;
  bool p073_tempflagdot = false;

  if (!text.isEmpty()) {
    validFloatFromString(text, p073_temptemp);
  }

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {
    addLog(LOG_LEVEL_INFO, concat(F("7DGT : Show Temperature="), p073_temptemp));
  }
  # endif

  switch (P073_data->displayModel) {
    case P073_TM1637_4DGTCOLON:
    case P073_TM1637_4DGTDOTS:
    case P073_TM1637_6DGT:
    {
      if ((p073_temptemp > 999.0f) || (p073_temptemp < -99.9f)) {
        P073_data->FillBufferWithDash();
      } else {
        if ((p073_temptemp < 100.0f) && (p073_temptemp > -10.0f)) {
          p073_temptemp = roundf(p073_temptemp * 10.0f);
          p073_tempflagdot = true;
        }
        P073_data->FillBufferWithTemp(p073_temptemp);

        if ((p073_temptemp == 0) && p073_tempflagdot) {
          P073_data->showbuffer[5] = 0;
        }
      }

      if (P073_TM1637_6DGT == P073_data->displayModel) {
        tm1637_ShowTemp6(event, p073_tempflagdot);
      } else {
        tm1637_ShowTimeTemp4(event, p073_tempflagdot, 4);
      }
      break;
    }
    case P073_MAX7219_8DGT:
    {
      p073_temptemp = roundf(p073_temptemp * 10.0f);
      P073_data->FillBufferWithTemp(p073_temptemp);

      # ifdef P073_DEBUG

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        addLogMove(LOG_LEVEL_INFO, concat(F("7DGT : 7dt preprocessed ="), p073_temptemp));
      }
      # endif

      max7219_ShowTemp(event, P073_data->pin1, P073_data->pin2, P073_data->pin3, P073_data->hideDegree ? 6 : 5, -1);
      break;
    }
  }
  # ifdef P073_DEBUG
  P073_data->LogBufferContent(F("7dt"));
  # endif
  return true;
}

# ifdef P073_7DDT_COMMAND
bool p073_plugin_write_7ddt(struct EventStruct *event,
                            const String & text) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P073_data) || (P073_data->output != P073_DISP_MANUAL)) {
    return false;
  }

  float p073_lefttemp = 0.0f;
  float p073_righttemp = 0.0f;
  bool p073_tempflagdot = false;

  if (!text.isEmpty()) {
    validFloatFromString(parseString(text, 1), p073_lefttemp);

    if (text.indexOf(',') > -1) {
      validFloatFromString(parseString(text, 2), p073_righttemp);
    }
  }

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {
    addLog(LOG_LEVEL_INFO, strformat(F("7DGT : Show Temperature 1st=%.2f 2nd=%.2f"), p073_lefttemp, p073_righttemp));
  }

  switch (P073_data->displayModel) {
    case P073_TM1637_4DGTCOLON:
    case P073_TM1637_4DGTDOTS:
    case P073_TM1637_6DGT:
    {
      P073_data->FillBufferWithDash();

      if (P073_data->displayModel == P073_TM1637_6DGT) {
        tm1637_ShowTemp6(event, p073_tempflagdot);
      } else {
        tm1637_ShowTimeTemp4(event, p073_tempflagdot, 4);
      }
      break;
    }
    case P073_MAX7219_8DGT:
    {
      uint8_t firstDot = -1;
      uint8_t secondDot = -1;
      float hideFactor = P073_data->hideDegree ? 10.0f : 1.0f;
      bool firstDecimals = false;
      bool secondDecimals = false;

      if ((p073_lefttemp > 999.99f * hideFactor) || (p073_lefttemp < -99.99f * hideFactor)) {
        p073_lefttemp = -101.0f * hideFactor;
      } else {
        if ((p073_lefttemp < 100.0f * hideFactor) && (p073_lefttemp > -10.0f * hideFactor)) {
          p073_lefttemp = roundf(p073_lefttemp * 10.0f);
          firstDot = P073_data->hideDegree ? 2 : 1;
          firstDecimals = true;
        }
      }

      if ((p073_righttemp > 999.99f * hideFactor) || (p073_righttemp < -99.99f * hideFactor)) {
        p073_righttemp = -101.0f * hideFactor;
      } else {
        if ((p073_righttemp < 100.0f * hideFactor) && (p073_righttemp > -10.0f * hideFactor)) {
          p073_righttemp = roundf(p073_righttemp * 10.0f);
          secondDot = P073_data->hideDegree ? 6 : 5;
          secondDecimals = true;
        }
      }

      # ifdef P073_DEBUG

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        addLog(LOG_LEVEL_INFO, strformat(F("7DGT : 7ddt preprocessed 1st=%.2f 2nd=%.2f"), p073_lefttemp, p073_righttemp));
      }
      # endif

      P073_data->FillBufferWithDualTemp(p073_lefttemp, firstDecimals, p073_righttemp, secondDecimals);

      bool alignSave = P073_data->rightAlignTempMAX7219;
      P073_data->rightAlignTempMAX7219 = true;

      max7219_ShowTemp(event, P073_data->pin1, P073_data->pin2, P073_data->pin3, firstDot, secondDot);

      P073_data->rightAlignTempMAX7219 = alignSave;

      break;
    }
  }
  # ifdef P073_DEBUG
  P073_data->LogBufferContent(F("7ddt"));
  # endif
  return true;
}

# endif

bool p073_plugin_write_7dst(struct EventStruct *event) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P073_data) || (P073_data->output != P073_DISP_MANUAL)) {
    return false;
  }

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {
    addLog(LOG_LEVEL_INFO, strformat(F("7DGT : Show Time=%02d:%02d:%02d"), event->Par1, event->Par2, event->Par3));
  }
  # endif
  P073_data->timesep = true;
  P073_data->FillBufferWithTime(false, event->Par1, event->Par2, event->Par3, false,
                                # ifdef P073_SUPPRESS_ZERO
                                bitRead(PCONFIG_LONG(0), P073_OPTION_SUPPRESS0)
                                # else
                                false
                                # endif
                                );

  switch (P073_data->displayModel) {
    case P073_TM1637_4DGTCOLON:
    case P073_TM1637_4DGTDOTS:
    {
      tm1637_ShowTimeTemp4(event, P073_data->timesep, 0);
      break;
    }
    case P073_TM1637_6DGT:
    {
      tm1637_ShowTime6(event);
      break;
    }
    case P073_MAX7219_8DGT:
    {
      max7219_ShowTime(event, P073_data->pin1, P073_data->pin2, P073_data->pin3, P073_data->timesep);
      break;
    }
  }
  return true;
}

bool p073_plugin_write_7dsd(struct EventStruct *event) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P073_data) || (P073_data->output != P073_DISP_MANUAL)) {
    return false;
  }

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {
    addLog(LOG_LEVEL_INFO, strformat(F("7DGT : Show Date=%02d:%02d:%02d"), event->Par1, event->Par2, event->Par3));
  }
  P073_data->FillBufferWithDate(false, event->Par1, event->Par2, event->Par3,
                                # ifdef P073_SUPPRESS_ZERO
                                bitRead(PCONFIG_LONG(0), P073_OPTION_SUPPRESS0)
                                # else
                                false
                                # endif
                                );

  switch (P073_data->displayModel) {
    case P073_TM1637_4DGTCOLON:
    case P073_TM1637_4DGTDOTS:
    {
      tm1637_ShowTimeTemp4(event, P073_data->timesep, 0);
      break;
    }
    case P073_TM1637_6DGT:
    {
      tm1637_ShowDate6(event);
      break;
    }
    case P073_MAX7219_8DGT:
    {
      max7219_ShowDate(event, P073_data->pin1, P073_data->pin2, P073_data->pin3);
      break;
    }
  }
  return true;
}

bool p073_plugin_write_7dtext(struct EventStruct *event,
                              const String & text) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P073_data) || (P073_data->output != P073_DISP_MANUAL)) {
    return false;
  }

  # ifndef BUILD_NO_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {
    addLogMove(LOG_LEVEL_INFO, concat(F("7DGT : Show Text="), text));
  }
  # endif
  # ifdef P073_SCROLL_TEXT
  P073_data->setTextToScroll("");
  uint8_t bufLen = P073_data->getBufferLength(P073_data->displayModel);

  if (P073_data->isScrollEnabled() && (P073_data->getEffectiveTextLength(text) > bufLen)) {
    P073_data->setTextToScroll(text);
  } else
  # endif
  {
    P073_data->FillBufferWithString(text);

    switch (P073_data->displayModel) {
      case P073_TM1637_4DGTCOLON:
      case P073_TM1637_4DGTDOTS:
      {
        tm1637_ShowBuffer(event, 0, 4);
        break;
      }
      case P073_TM1637_6DGT:
      {
        tm1637_SwapDigitInBuffer(event, 0);
        tm1637_ShowBuffer(event, 0, 6);
        break;
      }
      case P073_MAX7219_8DGT:
      {
        P073_data->dotpos = -1;
        max7219_ShowBuffer(event, P073_data->pin1, P073_data->pin2, P073_data->pin3);
        break;
      }
    }
  }
  return true;
}

# ifdef P073_EXTRA_FONTS
bool p073_plugin_write_7dfont(struct EventStruct *event,
                              const String & text) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return false;
  }

  if (!text.isEmpty()) {
    String fontArg = parseString(text, 1);
    int32_t fontNr = -1;

    if ((equals(fontArg, F("default"))) || (equals(fontArg, F("7dgt")))) {
      fontNr = 0;
    } else if (equals(fontArg, F("siekoo"))) {
      fontNr = 1;
    } else if (equals(fontArg, F("siekoo_upper"))) {
      fontNr = 2;
    } else if (equals(fontArg, F("dseg7"))) {
      fontNr = 3;
    } else if (!validIntFromString(text, fontNr)) {
      fontNr = -1;
    }

    # ifdef P073_DEBUG

    if (loglevelActiveFor(LOG_LEVEL_INFO)) {
      addLog(LOG_LEVEL_INFO, strformat(F("P037 7dfont,%s -> %d"), fontArg.c_str(), fontNr));
    }
    # endif

    if ((fontNr >= 0) && (fontNr <= 3)) {
      P073_data->fontset = fontNr;
      PCONFIG(4) = fontNr;
      return true;
    }
  }
  return false;
}

# endif

# ifdef P073_7DBIN_COMMAND
bool p073_plugin_write_7dbin(struct EventStruct *event,
                             const String & text) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return false;
  }

  if (!text.isEmpty()) {
    String data;
    int32_t byteValue{};
    int arg = 1;
    String argValue = parseString(text, arg);

    while (!argValue.isEmpty()) {
      if (validIntFromString(argValue, byteValue) && (byteValue < 256) && (byteValue > -1)) {
        data += static_cast<char>(P073_data->displayModel == P073_MAX7219_8DGT ?
                                  byteValue :
                                  P073_data->mapMAX7219FontToTM1673Font(byteValue));
      }
      arg++;
      argValue = parseString(text, arg);
    }
    # ifdef P073_SCROLL_TEXT
    const uint8_t bufLen = P073_data->getBufferLength(P073_data->displayModel);
    # endif

    if (!data.isEmpty()) {
      # ifdef P073_SCROLL_TEXT
      P073_data->setTextToScroll(EMPTY_STRING);

      if (P073_data->isScrollEnabled() && (data.length() > bufLen)) {
        P073_data->setBinaryData(data);
      } else
      # endif
      {
        P073_data->FillBufferWithString(data, true);

        switch (P073_data->displayModel) {
          case P073_TM1637_4DGTCOLON:
          case P073_TM1637_4DGTDOTS:
          {
            tm1637_ShowBuffer(event, 0, 4);
            break;
          }
          case P073_TM1637_6DGT:
          {
            tm1637_SwapDigitInBuffer(event, 0);
            tm1637_ShowBuffer(event, 0, 6, true);
            break;
          }
          case P073_MAX7219_8DGT:
          {
            P073_data->dotpos = -1;
            max7219_ShowBuffer(event, P073_data->pin1, P073_data->pin2, P073_data->pin3);
            break;
          }
        }
      }
      return true;
    }
  }
  return false;
}

# endif





#define CLK_HIGH() digitalWrite(clk_pin, HIGH)
#define CLK_LOW() digitalWrite(clk_pin, LOW)
#define DIO_HIGH() pinMode(dio_pin, INPUT)
#define DIO_LOW() pinMode(dio_pin, OUTPUT)

void tm1637_i2cStart(uint8_t clk_pin,
                     uint8_t dio_pin) {
  # ifdef P073_DEBUG
  addLog(LOG_LEVEL_DEBUG, F("7DGT : Comm Start"));
  # endif
  DIO_HIGH();
  CLK_HIGH();
  delayMicroseconds(TM1637_CLOCKDELAY);
  DIO_LOW();
}

void tm1637_i2cStop(uint8_t clk_pin,
                    uint8_t dio_pin) {
  # ifdef P073_DEBUG
  addLog(LOG_LEVEL_DEBUG, F("7DGT : Comm Stop"));
  # endif
  CLK_LOW();
  delayMicroseconds(TM1637_CLOCKDELAY);
  DIO_LOW();
  delayMicroseconds(TM1637_CLOCKDELAY);
  CLK_HIGH();
  delayMicroseconds(TM1637_CLOCKDELAY);
  DIO_HIGH();
}

void tm1637_i2cAck(uint8_t clk_pin,
                   uint8_t dio_pin) {
  # ifdef P073_DEBUG
  bool dummyAck = false;
  # endif

  CLK_LOW();
  pinMode(dio_pin, INPUT_PULLUP);


  delayMicroseconds(TM1637_CLOCKDELAY);


  # ifdef P073_DEBUG
  dummyAck =
  # endif
  digitalRead(dio_pin);

  # ifdef P073_DEBUG

  if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
    String log = F("7DGT : Comm ACK=");

    if (dummyAck == 0) {
      log += F("TRUE");
    } else {
      log += F("FALSE");
    }
    addLogMove(LOG_LEVEL_DEBUG, log);
  }
  # endif
  CLK_HIGH();
  delayMicroseconds(TM1637_CLOCKDELAY);
  CLK_LOW();
  pinMode(dio_pin, OUTPUT);
}

void tm1637_i2cWrite_ack(uint8_t clk_pin,
                         uint8_t dio_pin,
                         uint8_t bytesToPrint[],
                         uint8_t length) {
  tm1637_i2cStart(clk_pin, dio_pin);

  for (uint8_t i = 0; i < length; ++i) {
    tm1637_i2cWrite_ack(clk_pin, dio_pin, bytesToPrint[i]);
  }
  tm1637_i2cStop(clk_pin, dio_pin);
}

void tm1637_i2cWrite_ack(uint8_t clk_pin,
                         uint8_t dio_pin,
                         uint8_t bytetoprint) {
  tm1637_i2cWrite(clk_pin, dio_pin, bytetoprint);
  tm1637_i2cAck(clk_pin, dio_pin);
}

void tm1637_i2cWrite(uint8_t clk_pin,
                     uint8_t dio_pin,
                     uint8_t bytetoprint) {
  # ifdef P073_DEBUG
  addLog(LOG_LEVEL_DEBUG, F("7DGT : WriteByte"));
  # endif
  uint8_t i;

  for (i = 0; i < 8; i++) {
    CLK_LOW();

    if (bytetoprint & B00000001) {
      DIO_HIGH();
    } else {
      DIO_LOW();
    }
    delayMicroseconds(TM1637_CLOCKDELAY);
    bytetoprint = bytetoprint >> 1;
    CLK_HIGH();
    delayMicroseconds(TM1637_CLOCKDELAY);
  }
}

void tm1637_ClearDisplay(uint8_t clk_pin,
                         uint8_t dio_pin) {
  uint8_t bytesToPrint[7] = { 0 };

  bytesToPrint[0] = 0xC0;
  tm1637_i2cWrite_ack(clk_pin, dio_pin, bytesToPrint, 7);
}

void tm1637_SetPowerBrightness(uint8_t clk_pin,
                               uint8_t dio_pin,
                               uint8_t brightlvl,
                               bool poweron) {
  # ifdef P073_DEBUG
  addLog(LOG_LEVEL_INFO, F("7DGT : Set BRIGHT"));
  # endif
  uint8_t brightvalue = (brightlvl & 0b111);

  if (poweron) {
    brightvalue = TM1637_POWER_ON | brightvalue;
  } else {
    brightvalue = TM1637_POWER_OFF | brightvalue;
  }

  uint8_t bytesToPrint[1] = { 0 };
  bytesToPrint[0] = brightvalue;
  tm1637_i2cWrite_ack(clk_pin, dio_pin, bytesToPrint, 1);
}

void tm1637_InitDisplay(uint8_t clk_pin,
                        uint8_t dio_pin) {
  pinMode(clk_pin, OUTPUT);
  pinMode(dio_pin, OUTPUT);
  CLK_HIGH();
  DIO_HIGH();



  uint8_t bytesToPrint[1] = { 0 };

  bytesToPrint[0] = 0x40;
  tm1637_i2cWrite_ack(clk_pin, dio_pin, bytesToPrint, 1);
  tm1637_ClearDisplay(clk_pin, dio_pin);
}

uint8_t tm1637_separator(uint8_t value,
                         bool sep) {
  if (sep) {
    value |= 0b10000000;
  }
  return value;
}

void tm1637_ShowTime6(struct EventStruct *event) {
  tm1637_ShowDate6(event, true);
}

void tm1637_ShowDate6(struct EventStruct *event, bool showTime) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return;
  }
  uint8_t bytesToPrint[7] = { 0 };

  bytesToPrint[0] = 0xC0;
  bytesToPrint[1] = P073_data->tm1637_getFontChar(P073_data->showbuffer[2], P073_data->fontset);
  bytesToPrint[2] = tm1637_separator(P073_data->tm1637_getFontChar(P073_data->showbuffer[1], P073_data->fontset), P073_data->timesep);
  bytesToPrint[3] = P073_data->tm1637_getFontChar(P073_data->showbuffer[0], P073_data->fontset);

  if (showTime) {
    bytesToPrint[4] = P073_data->tm1637_getFontChar(P073_data->showbuffer[5], P073_data->fontset);
    bytesToPrint[5] = P073_data->tm1637_getFontChar(P073_data->showbuffer[4], P073_data->fontset);
  } else {
    bytesToPrint[4] = P073_data->tm1637_getFontChar(P073_data->showbuffer[7], P073_data->fontset);
    bytesToPrint[5] = P073_data->tm1637_getFontChar(P073_data->showbuffer[6], P073_data->fontset);
  }
  bytesToPrint[6] = tm1637_separator(P073_data->tm1637_getFontChar(P073_data->showbuffer[3], P073_data->fontset), P073_data->timesep);

  tm1637_i2cWrite_ack(P073_data->pin1, P073_data->pin2, bytesToPrint, 7);
}

void tm1637_ShowTemp6(struct EventStruct *event,
                      bool sep) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return;
  }
  uint8_t bytesToPrint[7] = { 0 };

  bytesToPrint[0] = 0xC0;
  bytesToPrint[1] = tm1637_separator(P073_data->tm1637_getFontChar(P073_data->showbuffer[5], P073_data->fontset), sep);
  bytesToPrint[2] = P073_data->tm1637_getFontChar(P073_data->showbuffer[4], P073_data->fontset);
  bytesToPrint[3] = P073_data->tm1637_getFontChar(10, P073_data->fontset);
  bytesToPrint[4] = P073_data->tm1637_getFontChar(10, P073_data->fontset);
  bytesToPrint[5] = P073_data->tm1637_getFontChar(P073_data->showbuffer[7], P073_data->fontset);
  bytesToPrint[6] = P073_data->tm1637_getFontChar(P073_data->showbuffer[6], P073_data->fontset);

  tm1637_i2cWrite_ack(P073_data->pin1, P073_data->pin2, bytesToPrint, 7);
}

void tm1637_ShowTimeTemp4(struct EventStruct *event,
                          bool sep,
                          uint8_t bufoffset) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return;
  }
  uint8_t bytesToPrint[7] = { 0 };

  bytesToPrint[0] = 0xC0;
  bytesToPrint[1] = P073_data->tm1637_getFontChar(P073_data->showbuffer[0 + bufoffset], P073_data->fontset);
  bytesToPrint[2] = tm1637_separator(P073_data->tm1637_getFontChar(P073_data->showbuffer[1 + bufoffset], P073_data->fontset), sep);
  bytesToPrint[3] = P073_data->tm1637_getFontChar(P073_data->showbuffer[2 + bufoffset], P073_data->fontset);
  bytesToPrint[4] = P073_data->tm1637_getFontChar(P073_data->showbuffer[3 + bufoffset], P073_data->fontset);

  tm1637_i2cWrite_ack(P073_data->pin1, P073_data->pin2, bytesToPrint, 5);
}

void tm1637_SwapDigitInBuffer(struct EventStruct *event,
                              uint8_t startPos) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return;
  }
  uint8_t p073_tmp;

  p073_tmp = P073_data->showbuffer[2 + startPos];
  P073_data->showbuffer[2 + startPos] = P073_data->showbuffer[0 + startPos];
  P073_data->showbuffer[0 + startPos] = p073_tmp;
  p073_tmp = P073_data->showbuffer[3 + startPos];
  P073_data->showbuffer[3 + startPos] = P073_data->showbuffer[5 + startPos];
  P073_data->showbuffer[5 + startPos] = p073_tmp;

  bool p073_per;

  p073_per = P073_data->showperiods[2 + startPos];
  P073_data->showperiods[2 + startPos] = P073_data->showperiods[0 + startPos];
  P073_data->showperiods[0 + startPos] = p073_per;
  p073_per = P073_data->showperiods[3 + startPos];
  P073_data->showperiods[3 + startPos] = P073_data->showperiods[5 + startPos];
  P073_data->showperiods[5 + startPos] = p073_per;

  switch (P073_data->dotpos) {
    case 2: {
      P073_data->dotpos = 4;
      break;
    }
    case 4: {
      P073_data->dotpos = 2;
      break;
    }
    case 5: {
      P073_data->dotpos = 7;
      break;
    }
    case 7: {
      P073_data->dotpos = 5;
      break;
    }
  }
}

void tm1637_ShowBuffer(struct EventStruct *event,
                       uint8_t firstPos,
                       uint8_t lastPos,
                       bool useBinaryData) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return;
  }
  uint8_t bytesToPrint[8] = { 0 };

  bytesToPrint[0] = 0xC0;
  uint8_t length = 1;

  if (P073_data->dotpos > -1) {
    P073_data->showperiods[P073_data->dotpos] = true;
  }

  uint8_t p073_datashowpos1;

  for (int i = firstPos; i < lastPos; i++) {
    if (useBinaryData) {
      bytesToPrint[length] = P073_data->showbuffer[i];
    } else {
      p073_datashowpos1 = tm1637_separator(
        P073_data->tm1637_getFontChar(P073_data->showbuffer[i], P073_data->fontset),
        P073_data->showperiods[i]);
      bytesToPrint[length] = p073_datashowpos1;
    }
    ++length;
  }
  tm1637_i2cWrite_ack(P073_data->pin1, P073_data->pin2, bytesToPrint, length);
}





#define OP_DECODEMODE 9
#define OP_INTENSITY 10
#define OP_SCANLIMIT 11
#define OP_SHUTDOWN 12
#define OP_DISPLAYTEST 15

void max7219_spiTransfer(struct EventStruct *event,
                         uint8_t din_pin,
                         uint8_t clk_pin,
                         uint8_t cs_pin,
                         ESPEASY_VOLATILE(uint8_t) opcode,
                         ESPEASY_VOLATILE(uint8_t) data) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return;
  }

  P073_data->spidata[1] = opcode;
  P073_data->spidata[0] = data;
  digitalWrite(cs_pin, LOW);
  shiftOut(din_pin, clk_pin, MSBFIRST, P073_data->spidata[1]);
  shiftOut(din_pin, clk_pin, MSBFIRST, P073_data->spidata[0]);
  digitalWrite(cs_pin, HIGH);
}

void max7219_ClearDisplay(struct EventStruct *event,
                          uint8_t din_pin,
                          uint8_t clk_pin,
                          uint8_t cs_pin) {
  for (int i = 0; i < 8; i++) {
    max7219_spiTransfer(event, din_pin, clk_pin, cs_pin, i + 1, 0);
  }
}

void max7219_SetPowerBrightness(struct EventStruct *event,
                                uint8_t din_pin,
                                uint8_t clk_pin,
                                uint8_t cs_pin,
                                uint8_t brightlvl,
                                bool poweron) {
  max7219_spiTransfer(event, din_pin, clk_pin, cs_pin, OP_INTENSITY, brightlvl);
  max7219_spiTransfer(event, din_pin, clk_pin, cs_pin, OP_SHUTDOWN, poweron ? 1 : 0);
}

void max7219_SetDigit(struct EventStruct *event,
                      uint8_t din_pin,
                      uint8_t clk_pin,
                      uint8_t cs_pin,
                      int dgtpos,
                      uint8_t dgtvalue,
                      bool showdot,
                      bool binaryData = false) {
  uint8_t p073_tempvalue;

  # ifdef P073_EXTRA_FONTS

  switch (PCONFIG(4)) {
    case 1:
    case 2:
      p073_tempvalue = pgm_read_byte(&(SiekooCharTable[dgtvalue]));
      break;
    case 3:
      p073_tempvalue = pgm_read_byte(&(Dseg7CharTable[dgtvalue]));
      break;
    default:
  # endif
  p073_tempvalue = pgm_read_byte(&(DefaultCharTable[dgtvalue]));
  # ifdef P073_EXTRA_FONTS
}

  # endif

  if (showdot) {
    p073_tempvalue |= 0b10000000;
  }

  if (binaryData) {
    p073_tempvalue = dgtvalue;
  }
  max7219_spiTransfer(event, din_pin, clk_pin, cs_pin, dgtpos + 1, p073_tempvalue);
}

void max7219_InitDisplay(struct EventStruct *event,
                         uint8_t din_pin,
                         uint8_t clk_pin,
                         uint8_t cs_pin) {
  pinMode(din_pin, OUTPUT);
  pinMode(clk_pin, OUTPUT);
  pinMode(cs_pin, OUTPUT);
  digitalWrite(cs_pin, HIGH);
  max7219_spiTransfer(event, din_pin, clk_pin, cs_pin, OP_DISPLAYTEST, 0);
  max7219_spiTransfer(event, din_pin, clk_pin, cs_pin, OP_SCANLIMIT, 7);
  max7219_spiTransfer(event, din_pin, clk_pin, cs_pin, OP_DECODEMODE, 0);
  max7219_ClearDisplay(event, din_pin, clk_pin, cs_pin);
  max7219_SetPowerBrightness(event, din_pin, clk_pin, cs_pin, 0, false);
}

void max7219_ShowTime(struct EventStruct *event,
                      uint8_t din_pin,
                      uint8_t clk_pin,
                      uint8_t cs_pin,
                      bool sep) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return;
  }

  const uint8_t idx_list[] = { 7, 6, 4, 3, 1, 0 };

  for (int8_t i = 5; i >= 0; i--) {
    max7219_SetDigit(event, din_pin, clk_pin, cs_pin, idx_list[i], P073_data->showbuffer[i], false);
  }

  const uint8_t sepChar = P073_data->mapCharToFontPosition(sep ? '-' : ' ', P073_data->fontset);

  max7219_SetDigit(event, din_pin, clk_pin, cs_pin, 2, sepChar, false);
  max7219_SetDigit(event, din_pin, clk_pin, cs_pin, 5, sepChar, false);
}

void max7219_ShowTemp(struct EventStruct *event,
                      uint8_t din_pin,
                      uint8_t clk_pin,
                      uint8_t cs_pin,
                      int8_t firstDot,
                      int8_t secondDot) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return;
  }

  max7219_SetDigit(event, din_pin, clk_pin, cs_pin, 0, 10, false);

  if (firstDot > -1) { P073_data->showperiods[firstDot] = true; }

  if (secondDot > -1) { P073_data->showperiods[secondDot] = true; }

  const int alignRight = P073_data->rightAlignTempMAX7219 ? 0 : 1;

  for (int i = alignRight; i < 8; i++) {
    const int bufIndex = (7 + alignRight) - i;

    if (bufIndex < 8) {
      max7219_SetDigit(event, din_pin, clk_pin, cs_pin, i,
                       P073_data->showbuffer[bufIndex],
                       P073_data->showperiods[bufIndex]);
    }
  }
}

void max7219_ShowDate(struct EventStruct *event,
                      uint8_t din_pin,
                      uint8_t clk_pin,
                      uint8_t cs_pin) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return;
  }

  const uint8_t dotflags[8] = { false, true, false, true, false, false, false, false };

  for (int i = 0; i < 8; i++) {
    max7219_SetDigit(event, din_pin, clk_pin, cs_pin, i,
                     P073_data->showbuffer[7 - i],
                     dotflags[7 - i]);
  }
}

void max7219_ShowBuffer(struct EventStruct *event,
                        uint8_t din_pin,
                        uint8_t clk_pin,
                        uint8_t cs_pin) {
  P073_data_struct *P073_data =
    static_cast<P073_data_struct *>(getPluginTaskData(event->TaskIndex));

  if (nullptr == P073_data) {
    return;
  }

  if (P073_data->dotpos > -1) {
    P073_data->showperiods[P073_data->dotpos] = true;
  }

  for (int i = 0; i < 8; i++) {
    max7219_SetDigit(event, din_pin, clk_pin, cs_pin, i,
                     P073_data->showbuffer[7 - i],
                     P073_data->showperiods[7 - i]
                     # ifdef P073_7DBIN_COMMAND
                     , P073_data->binaryData
                     # endif
                     );
  }
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P074_TSL2591.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P074

# include "src/PluginStructs/P074_data_struct.h"
# 21 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P074_TSL2591.ino"
#define PLUGIN_074 
#define PLUGIN_ID_074 74
#define PLUGIN_NAME_074 "Light/Lux - TSL2591"
#define PLUGIN_VALUENAME1_074 "Lux"
#define PLUGIN_VALUENAME2_074 "Full"
#define PLUGIN_VALUENAME3_074 "Visible"
#define PLUGIN_VALUENAME4_074 "IR"

boolean Plugin_074(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_074;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = false;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_074);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_074));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_074));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_074));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_074));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { TSL2591_ADDR };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 1, i2cAddressValues,
                           TSL2591_ADDR);
      } else {
        success = (event->Par1 == TSL2591_ADDR);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = TSL2591_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD: {
# 100 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P074_TSL2591.ino"
      {
        const __FlashStringHelper *optionsMode[6] = { F("100"), F("200"), F("300"),
                                                      F("400"), F("500"), F("600") };
        addFormSelector(F("Integration Time"), F("itime"), 6, optionsMode,
                        nullptr, PCONFIG(1));
        addUnit(F("ms"));
      }





      {
        const __FlashStringHelper *optionsGain[4] = { F("low gain (1x)"), F("medium gain (25x)"),
                                                      F("medium gain (428x)"), F("max gain (9876x)") };
        addFormSelector(F("Value Mapping"), F("gain"), 4, optionsGain, nullptr,
                        PCONFIG(2));
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {

      PCONFIG(1) = getFormItemInt(F("itime"));
      PCONFIG(2) = getFormItemInt(F("gain"));

      success = true;
      break;
    }

    case PLUGIN_INIT: {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P074_data_struct());
      P074_data_struct *P074_data =
        static_cast<P074_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P074_data) {
        return success;
      }

      if (P074_data->tsl.begin()) {
        P074_data->setIntegrationTime(PCONFIG(1));
        P074_data->setGain(PCONFIG(2));

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("TSL2591: Address: 0x");
          log += String(TSL2591_ADDR, HEX);
          log += F(": Integration Time: ");
          log += String((P074_data->tsl.getTiming() + 1) * 100, DEC);
          log += F(" ms");


          log += (F(" Gain: "));

          switch (P074_data->tsl.getGain()) {
            default:
            case TSL2591_GAIN_LOW: log += F("1x (Low)"); break;
            case TSL2591_GAIN_MED: log += F("25x (Medium)"); break;
            case TSL2591_GAIN_HIGH: log += F("428x (High)"); break;
            case TSL2591_GAIN_MAX: log += F("9876x (Max)"); break;
          }
          addLogMove(LOG_LEVEL_INFO, log);
        }
      } else {
        clearPluginTaskData(event->TaskIndex);
        addLog(LOG_LEVEL_ERROR,
               F("TSL2591: No sensor found ... check your wiring?"));
      }

      success = true;
      break;
    }

    case PLUGIN_TEN_PER_SECOND: {
      P074_data_struct *P074_data =
        static_cast<P074_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P074_data) {
        uint32_t fullLuminosity;

        if (P074_data->getFullLuminosity(fullLuminosity)) {

          const uint16_t full = (fullLuminosity & 0xFFFF);


          const uint16_t ir = (fullLuminosity >> 16);


          const uint16_t visible = ((fullLuminosity & 0xFFFF) - (fullLuminosity >> 16));

          const float lux = P074_data->tsl.calculateLuxf(full, ir);

          UserVar.setFloat(event->TaskIndex, 0, lux);
          UserVar.setFloat(event->TaskIndex, 1, full);
          UserVar.setFloat(event->TaskIndex, 2, visible);
          UserVar.setFloat(event->TaskIndex, 3, ir);

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log;
            log += concat(F("TSL2591: Lux: "), toString(lux));
            log += concat(F(" Full: "), static_cast<int>(full));
            log += concat(F(" Visible: "), static_cast<int>(visible));
            log += concat(F(" IR: "), static_cast<int>(ir));
            log += concat(F(" duration: "), static_cast<int>(P074_data->duration));
            addLogMove(LOG_LEVEL_INFO, log);
          }


          Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 10);
        }
      }
      break;
    }

    case PLUGIN_READ: {
      P074_data_struct *P074_data =
        static_cast<P074_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P074_data) {


        if (P074_data->newValuePresent) {

          P074_data->newValuePresent = false;
          success = true;
        } else {
          if (!P074_data->integrationActive) {

            P074_data->startIntegrationNeeded = true;
          }
        }
      } else {
        addLog(LOG_LEVEL_ERROR, F("TSL2591: Sensor not initialized!?"));
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P075_Nextion.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P075

# include "src/PluginStructs/P075_data_struct.h"

#include "src/ESPEasyCore/ESPEasyWifi.h"
# 34 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P075_Nextion.ino"
#define PLUGIN_075 
#define PLUGIN_ID_075 75
#define PLUGIN_NAME_075 "Display - Nextion"
#define PLUGIN_DEFAULT_NAME "NEXTION"
#define PLUGIN_VALUENAME1_075 "idx"
#define PLUGIN_VALUENAME2_075 "value"






boolean Plugin_075(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_075;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;


      Device[deviceCount].ExitTaskBeforeSave = false;

      break;
    }


    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_075);
      break;
    }


    case PLUGIN_GET_DEVICEVALUENAMES: {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_075));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_075));
      break;
    }


    case PLUGIN_GET_DEVICEGPIONAMES: {
      serialHelper_getGpioNames(event);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_SERIAL_PARAMS:
    {
      const __FlashStringHelper *options[4] = {
        F("9600"),
        F("38400"),
        F("57600"),
        F("115200")
      };

      addFormSelector(F("Baud Rate"), F("baud"), 4, options, nullptr, P075_BaudRate);
      addUnit(F("baud"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD: {






      addFormSubHeader(F(""));
      addFormHeader(F("Nextion Command Statements (Optional)"));
      P075_data_struct *P075_data = static_cast<P075_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P075_data) {
        P075_data->loadDisplayLines(event->TaskIndex);

        for (int varNr = 0; varNr < P75_Nlines; varNr++) {
          addFormTextBox(concat(F("Line "), varNr + 1), getPluginCustomArgName(varNr), P075_data->displayLines[varNr], P75_Nchars - 1);
        }
      }

      if (Settings.TaskDeviceTimer[event->TaskIndex] == 0) {
        addFormNote(concat(F("Interval Timer OFF, Nextion Lines (above)"), P075_IncludeValues
          ? F(" and Values (below) <b>NOT</b> scheduled for updates")
          : F(" <b>NOT</b> scheduled for updates")));
      }

      addFormSeparator(2);
      addFormSubHeader(F("Interval Options"));
      addFormCheckBox(F("Resend <b>Values</b> (below) at Interval"), F("IncludeValues"), P075_IncludeValues);

      success = true;
      break;
    }


    case PLUGIN_WEBFORM_SAVE: {
      {

        char deviceTemplate[P75_Nlines][P75_Nchars] = {};
        String error;

        for (uint8_t varNr = 0; varNr < P75_Nlines; varNr++)
        {
          if (!safe_strncpy(deviceTemplate[varNr], webArg(getPluginCustomArgName(varNr)), P75_Nchars)) {
            error += getCustomTaskSettingsError(varNr);
          }
        }

        if (error.length() > 0) {
          addHtmlError(error);
        }
        SaveCustomTaskSettings(event->TaskIndex, (uint8_t *)&deviceTemplate, sizeof(deviceTemplate));
      }

      if (getTaskDeviceName(event->TaskIndex).isEmpty()) {
        strcpy(ExtraTaskSettings.TaskDeviceName, PLUGIN_DEFAULT_NAME);
      }


      P075_BaudRate = getFormItemInt(F("baud"));
      P075_IncludeValues = isFormItemChecked(F("IncludeValues"));
# 179 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P075_Nextion.ino"
      success = true;
      break;
    }


    case PLUGIN_INIT: {
      uint8_t BaudCode = P075_BaudRate;

      if (BaudCode > P075_B115200) { BaudCode = P075_B9600; }
      const uint32_t BaudArray[4] = { 9600UL, 38400UL, 57600UL, 115200UL };
      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P075_data_struct(port, CONFIG_PIN1, CONFIG_PIN2, BaudArray[BaudCode]));
      P075_data_struct *P075_data = static_cast<P075_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P075_data) {
        P075_data->loadDisplayLines(event->TaskIndex);
        addLog(LOG_LEVEL_INFO, P075_data->getLogString());
        success = true;
      }
      break;
    }


    case PLUGIN_READ: {
      P075_data_struct *P075_data = static_cast<P075_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P075_data) {
        String newString;


        for (uint8_t x = 0; x < P75_Nlines; x++) {
          if (P075_data->displayLines[x].length()) {
            int RssiIndex;
            {
              String UcTmpString(P075_data->displayLines[x]);
              UcTmpString.toUpperCase();
              RssiIndex = UcTmpString.indexOf(F("RSSIBAR"));
            }
            if (RssiIndex >= 0) {
              newString = concat(
                P075_data->displayLines[x].substring(0, RssiIndex),
                GetRSSI_quality() * 10);
            }
            else {
              String tmpString(P075_data->displayLines[x]);
              newString = parseTemplate(tmpString);
            }

            P075_sendCommand(event->TaskIndex, newString.c_str());
            # ifdef P075_DEBUG_LOG
            String log;
            log.reserve(P75_Nchars + 50);
            log += concat(F("NEXTION075 : Cmd Statement Line-"), x + 1);
            log += concat(F(" Sent: "), newString);
            addLogMove(LOG_LEVEL_INFO, log);
            # endif
          }
        }


        if (P075_IncludeValues) {
          # ifdef P075_DEBUG_LOG
          String log;
          log.reserve(120);
          log += concat(F("NEXTION075: Interval values data enabled, resending idx="), formatUserVarNoCheck(event->TaskIndex, 0));
          log += concat(F(", value="), formatUserVarNoCheck(event->TaskIndex, 1));
          addLogMove(LOG_LEVEL_INFO, log);
          # endif

          success = true;
        }
        else {
          # ifdef P075_DEBUG_LOG
          addLog(LOG_LEVEL_INFO, F("NEXTION075: Interval values data disabled, idx & value not resent"));
          # endif

          success = false;
        }
      }
      break;
    }



    case PLUGIN_WRITE: {
      const String command = parseString(string, 1);


      if (command.equalsIgnoreCase(getTaskDeviceName(event->TaskIndex))) {
        success = true;
        const String nextionArguments = parseStringToEndKeepCase(string, 2);
        P075_sendCommand(event->TaskIndex, nextionArguments.c_str());
        {
          String log = concat(F("NEXTION075 : WRITE = "), nextionArguments);
          # ifndef BUILD_NO_DEBUG
          addLog(LOG_LEVEL_DEBUG, log);
          # endif
          SendStatus(event, log);
        }
# 294 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P075_Nextion.ino"
      }
      break;
    }

    case PLUGIN_ONCE_A_SECOND: {
      success = true;
      break;
    }


    case PLUGIN_TEN_PER_SECOND: {
      P075_data_struct *P075_data = static_cast<P075_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P075_data) {
        break;
      }

      if (P075_data->rxPin < 0) {
        addLog(LOG_LEVEL_INFO, F("NEXTION075 : Missing RxD Pin, aborted serial receive"));
        break;
      }

      if (P075_data->easySerial == nullptr) {
        break;
      }
      {
        uint16_t i;
        uint8_t c;
        String Vidx;
        String Nvalue;
        String Svalue;
        String Nswitch;
        char __buffer[RXBUFFSZ + 1];
        uint8_t charCount = P075_data->easySerial->available();

        if (charCount >= RXBUFFWARN) {
          String log;
          log.reserve(70);
          log += concat(F("NEXTION075 : RxD P075_data->easySerial Buffer capacity warning, "), charCount);
          log += F(" bytes");
          addLogMove(LOG_LEVEL_INFO, log);
        }
        uint32_t baudrate_delay_unit = P075_data->baudrate / 9600;

        if (baudrate_delay_unit == 0) {
          baudrate_delay_unit = 1;
        }

        while (charCount) {
          c = P075_data->easySerial->read();

          if (c == 0x65) {
            if (charCount < 6) { delay((5 / (baudrate_delay_unit)) + 1);
            }
            charCount = P075_data->easySerial->available();

            if (charCount >= 6) {
              __buffer[0] = c;

              for (i = 1; i < 7; i++) {
                __buffer[i] = P075_data->easySerial->read();
              }

              __buffer[i] = 0x00;


              if ((0xFF == __buffer[4]) && (0xFF == __buffer[5]) && (0xFF == __buffer[6])) {
                UserVar.setFloat(event->TaskIndex, 0, (__buffer[1] * 256) + __buffer[2] + TOUCH_BASE);
                UserVar.setFloat(event->TaskIndex, 1, __buffer[3]);
                sendData(event);

                # ifdef P075_DEBUG_LOG
                String log;
                log.reserve(70);
                log += F("NEXTION075 : code: ");
                log += __buffer[1];
                log += ',';
                log += __buffer[2];
                log += ',';
                log += __buffer[3];
                addLogMove(LOG_LEVEL_INFO, log);
                # endif
              }
            }
          }
          else {
            if (c == '|') {
              __buffer[0] = c;

              if (charCount < 8) { delay((9 / (baudrate_delay_unit)) + 1);
              }
              else { delay((3 / (baudrate_delay_unit)) + 1);
              }
              charCount = P075_data->easySerial->available();

              i = 1;

              while (P075_data->easySerial->available() > 0 && i < RXBUFFSZ) {
                __buffer[i] = P075_data->easySerial->read();

                if ((__buffer[i] == 0x0a) || (__buffer[i] == 0x0d)) { break; }
                i++;
              }

              __buffer[i] = 0x00;

              String tmpString = __buffer;

              # ifdef P075_DEBUG_LOG
              String log;
              log.reserve(50);
              log += concat(F("NEXTION075 : Code = "), tmpString);
              addLogMove(LOG_LEVEL_INFO, log);
              # endif

              int argIndex = tmpString.indexOf(F(",i"));
              int argEnd = tmpString.indexOf(',', argIndex + 1);

              if (argIndex) { Vidx = tmpString.substring(argIndex + 2, argEnd); }

              boolean GotPipeCmd = false;

              switch (__buffer[1]) {
                case 'u':
                  GotPipeCmd = true;
                  argIndex = argEnd;
                  argEnd = tmpString.indexOf(',', argIndex + 1);

                  if (argIndex) { Nvalue = tmpString.substring(argIndex + 2, argEnd); }
                  argIndex = argEnd;
                  argEnd = tmpString.indexOf(0x0a);

                  if (argIndex) { Svalue = tmpString.substring(argIndex + 2, argEnd); }
                  break;
                case 's':
                  GotPipeCmd = true;
                  argIndex = argEnd;
                  argEnd = tmpString.indexOf(0x0a);

                  if (argIndex) { Nvalue = tmpString.substring(argIndex + 2, argEnd); }

                  if (equals(Nvalue, F("On"))) { Svalue = '1'; }

                  if (equals(Nvalue, F("Off"))) { Svalue = '0'; }
                  break;
              }

              if (GotPipeCmd) {
                float Vidx_f{};
                float Svalue_f{};

                validFloatFromString(Vidx, Vidx_f);
                validFloatFromString(Svalue, Svalue_f);
                UserVar.setFloat(event->TaskIndex, 0, Vidx_f);
                UserVar.setFloat(event->TaskIndex, 1, Svalue_f);
                sendData(event);

                # ifdef P075_DEBUG_LOG
                String log;
                log.reserve(80);
                log += F("NEXTION075 : Pipe Command Sent: ");
                log += __buffer;
                log += formatUserVarNoCheck(event->TaskIndex, 0);
                addLogMove(LOG_LEVEL_INFO, log);
                # endif
              }
              else {
                # ifdef P075_DEBUG_LOG
                addLog(LOG_LEVEL_INFO, F("NEXTION075 : Unknown Pipe Command, skipped"));
                # endif
              }
            }
          }
          charCount = P075_data->easySerial->available();
        }
      }

      success = true;
      break;
    }
  }
  return success;
}

void P075_sendCommand(taskIndex_t taskIndex, const char *cmd)
{
  P075_data_struct *P075_data = static_cast<P075_data_struct *>(getPluginTaskData(taskIndex));

  if (!P075_data) { return; }

  if (P075_data->txPin < 0) {
    addLog(LOG_LEVEL_INFO, F("NEXTION075 : Missing TxD Pin Number, aborted sendCommand"));
  }
  else
  {
    if (P075_data->easySerial != nullptr) {
      P075_data->easySerial->print(cmd);
      P075_data->easySerial->write(0xff);
      P075_data->easySerial->write(0xff);
      P075_data->easySerial->write(0xff);
    }
    else {
      addLog(LOG_LEVEL_INFO, F("NEXTION075 : P075_data->easySerial error, aborted sendCommand"));
    }
  }
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P076_HLW8012.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P076
# 26 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P076_HLW8012.ino"
# include <HLW8012.h>

HLW8012 *Plugin_076_hlw = nullptr;

#define PLUGIN_076 
#define PLUGIN_ID_076 76
#define PLUGIN_076_DEBUG false
#define PLUGIN_NAME_076 "Energy (AC) - HLW8012/BL0937"
#define PLUGIN_VALUENAME1_076 "Voltage"
#define PLUGIN_VALUENAME2_076 "Current"
#define PLUGIN_VALUENAME3_076 "Power"
#define PLUGIN_VALUENAME4_076 "PowerFactor"

#define HLW_DELAYREADING 500


#define HLW_CURRENT_RESISTOR 0.001
#define HLW_VOLTAGE_RESISTOR_UP (5 * 470000)
#define HLW_VOLTAGE_RESISTOR_DOWN (1000)

int StoredTaskIndex = -1;
uint8_t p076_read_stage{};
unsigned long p076_timer{};

float p076_hcurrent{};
float p076_hvoltage{};
float p076_hpower{};
float p076_hpowfact{};

#define P076_Custom 0


#define P076_Sonoff 1
#define P076_Huafan 2
#define P076_KMC 3
#define P076_Aplic 4
#define P076_SK03 5


#define P076_BlitzWolf 6
#define P076_Teckin 7
#define P076_TeckinUS 8
#define P076_Gosund 9
#define P076_Shelly_PLUG_S 10

#if ESP_IDF_VERSION_MAJOR >= 5

void p076_hlw8012_cf1_interrupt();
void p076_hlw8012_cf_interrupt();
#else
void IRAM_ATTR p076_hlw8012_cf1_interrupt();
void IRAM_ATTR p076_hlw8012_cf_interrupt();
#endif


bool p076_getDeviceParameters(int device,
                              uint8_t& SEL_Pin,
                              uint8_t& CF_Pin,
                              uint8_t& CF1_Pin,
                              uint8_t& Cur_read,
                              uint8_t& CF_Trigger,
                              uint8_t& CF1_Trigger) {
  switch (device) {
    case P076_Custom: SEL_Pin = 0; CF_Pin = 0; CF1_Pin = 0; Cur_read = LOW; CF_Trigger = LOW; CF1_Trigger = LOW; break;
    case P076_Sonoff: SEL_Pin = 5; CF_Pin = 14; CF1_Pin = 13; Cur_read = HIGH; CF_Trigger = CHANGE; CF1_Trigger = CHANGE; break;
    case P076_Huafan: SEL_Pin = 13; CF_Pin = 14; CF1_Pin = 12; Cur_read = HIGH; CF_Trigger = CHANGE; CF1_Trigger = CHANGE; break;
    case P076_KMC: SEL_Pin = 12; CF_Pin = 4; CF1_Pin = 5; Cur_read = HIGH; CF_Trigger = CHANGE; CF1_Trigger = CHANGE; break;
    case P076_Aplic:
    case P076_SK03: SEL_Pin = 12; CF_Pin = 4; CF1_Pin = 5; Cur_read = LOW; CF_Trigger = CHANGE; CF1_Trigger = CHANGE; break;
    case P076_BlitzWolf:
    case P076_TeckinUS:
    case P076_Shelly_PLUG_S: SEL_Pin = 12; CF_Pin = 5; CF1_Pin = 14; Cur_read = LOW; CF_Trigger = FALLING; CF1_Trigger = CHANGE; break;
    case P076_Teckin:
    case P076_Gosund: SEL_Pin = 12; CF_Pin = 4; CF1_Pin = 5; Cur_read = LOW; CF_Trigger = FALLING; CF1_Trigger = CHANGE; break;
    default:
      return false;
  }
  return true;
}

boolean Plugin_076(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_076;
      Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = false;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_076);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0],
               PSTR(PLUGIN_VALUENAME1_076));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1],
               PSTR(PLUGIN_VALUENAME2_076));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2],
               PSTR(PLUGIN_VALUENAME3_076));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3],
               PSTR(PLUGIN_VALUENAME4_076));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES: {
      event->String1 = formatGpioName_output(F("SEL"));
      event->String2 = formatGpioName_input(F("CF1"));
      event->String3 = formatGpioName_input(F("CF"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
      uint8_t devicePinSettings = PCONFIG(7);

      addFormSubHeader(F("Predefined Pin settings"));
      {

        const __FlashStringHelper * predefinedNames[] = {
          F("Custom"),
          F("Sonoff Pow (r1)"),
          F("Huafan SS"),
          F("KMC 70011"),
          F("Aplic WDP303075"),
          F("SK03 Outdoor"),
          F("BlitzWolf SHP"),
          F("Teckin"),
          F("Teckin US"),
          F("Gosund SP1 v23"),
          F("Shelly PLUG-S")
        };
        const int predefinedId[] = {
          P076_Custom,
          P076_Sonoff,
          P076_Huafan,
          P076_KMC,
          P076_Aplic,
          P076_SK03,
          P076_BlitzWolf,
          P076_Teckin,
          P076_TeckinUS,
          P076_Gosund,
          P076_Shelly_PLUG_S
        };
        constexpr int nrElements = NR_ELEMENTS(predefinedId);
        addFormSelector(F("Device"),
                        F("preDefDevSel"), nrElements,
                        predefinedNames, predefinedId, devicePinSettings);
        addFormNote(F("Enable device and select device type first"));
      }

      {

        const __FlashStringHelper *modeRaise[] = {
          F("LOW"),
          F("CHANGE"),
          F("RISING"),
          F("FALLING"),
        };

        const int modeValues[] = {
          LOW,
          CHANGE,
          RISING,
          FALLING,
        };

        const __FlashStringHelper *modeCurr[] = {
          F("LOW"),
          F("HIGH"),
        };

        const int modeCurrValues[] = {
          LOW,
          HIGH,
        };

        uint8_t currentRead = PCONFIG(4);

        if ((currentRead != LOW) && (currentRead != HIGH)) {
          currentRead = LOW;
        }
        addFormSubHeader(F("Custom Pin settings (choose Custom above)"));
        addFormSelector(F("SEL Current (A) Reading"), F("curr_read"), 2,
                        modeCurr, modeCurrValues, currentRead);
        addFormSelector(F("CF1  Interrupt Edge"), F("cf1_edge"), 4,
                        modeRaise, modeValues, PCONFIG(6));
        addFormSelector(F("CF Interrupt Edge"), F("cf_edge"), 4,
                        modeRaise, modeValues, PCONFIG(5));
      }


      ESPEASY_RULES_FLOAT_TYPE current, voltage, power;

      if (Plugin076_LoadMultipliers(event->TaskIndex, current, voltage, power)) {
        addFormSubHeader(F("Calibration Values"));
        addFormTextBox(F("Current Multiplier"), F("currmult"),
        #if FEATURE_USE_DOUBLE_AS_ESPEASY_RULES_FLOAT_TYPE
                       doubleToString(current, 2)
        #else
                       floatToString(current, 2)
        #endif
                       , 25);
        addFormTextBox(F("Voltage Multiplier"), F("voltmult"),
        #if FEATURE_USE_DOUBLE_AS_ESPEASY_RULES_FLOAT_TYPE
                       doubleToString(voltage, 2)
        #else
                       floatToString(voltage, 2)
        #endif
                       , 25);
        addFormTextBox(F("Power Multiplier"), F("powmult"),
        #if FEATURE_USE_DOUBLE_AS_ESPEASY_RULES_FLOAT_TYPE
                       doubleToString(power, 2)
        #else
                       floatToString(power, 2)
        #endif
                       , 25);
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {

      uint8_t selectedDevice = getFormItemInt(F("preDefDevSel"));

      PCONFIG(7) = selectedDevice;
      {
        uint8_t SEL_Pin, CF_Pin, CF1_Pin, Cur_read, CF_Trigger, CF1_Trigger;

        if ((selectedDevice != 0) && p076_getDeviceParameters(selectedDevice, SEL_Pin, CF_Pin, CF1_Pin, Cur_read, CF_Trigger, CF1_Trigger)) {
          PCONFIG(4) = Cur_read;
          PCONFIG(5) = CF_Trigger;
          PCONFIG(6) = CF1_Trigger;

          CONFIG_PIN1 = SEL_Pin;
          CONFIG_PIN2 = CF1_Pin;
          CONFIG_PIN3 = CF_Pin;
        } else {
          PCONFIG(4) = getFormItemInt(F("curr_read"));
          PCONFIG(5) = getFormItemInt(F("cf_edge"));
          PCONFIG(6) = getFormItemInt(F("cf1_edge"));
        }
      }


      ESPEASY_RULES_FLOAT_TYPE hlwMultipliers[3];
      hlwMultipliers[0] = getFormItemFloat(F("currmult"));
      hlwMultipliers[1] = getFormItemFloat(F("voltmult"));
      hlwMultipliers[2] = getFormItemFloat(F("powmult"));

      if ((hlwMultipliers[0] > 1.0) && (hlwMultipliers[1] > 1.0) && (hlwMultipliers[2] > 1.0)) {
        SaveCustomTaskSettings(event->TaskIndex, reinterpret_cast<const uint8_t *>(&hlwMultipliers),
                               sizeof(hlwMultipliers));
        #if PLUGIN_076_DEBUG
          addLog(LOG_LEVEL_INFO, F("P076: Saved Calibration from Config Page"));
        # endif

        if (Plugin_076_hlw) {
          Plugin_076_hlw->setCurrentMultiplier(hlwMultipliers[0]);
          Plugin_076_hlw->setVoltageMultiplier(hlwMultipliers[1]);
          Plugin_076_hlw->setPowerMultiplier(hlwMultipliers[2]);
        }

        #if PLUGIN_076_DEBUG
          addLog(LOG_LEVEL_INFO, F("P076: Multipliers Reassigned"));
        #endif
      }

      #if PLUGIN_076_DEBUG
        String log = F("P076: PIN Settings ");

        log += F(" curr_read: ");
        log += PCONFIG(4);
        log += F(" cf_edge: ");
        log += PCONFIG(5);
        log += F(" cf1_edge: ");
        log += PCONFIG(6);
        addLogMove(LOG_LEVEL_INFO, log);
      #endif

      success = true;
      break;
    }

    case PLUGIN_TEN_PER_SECOND:

      if (Plugin_076_hlw) {
        bool valid = false;
        switch (p076_read_stage) {
          case 0:

            break;
          case 1:
            Plugin_076_hlw->setMode(MODE_CURRENT);
            p076_timer = millis() + HLW_DELAYREADING;
            ++p076_read_stage;
            break;
          case 2:

            if (timeOutReached(p076_timer)) {
              p076_hcurrent = Plugin_076_hlw->getCurrent(valid);
              Plugin_076_hlw->setMode(MODE_VOLTAGE);
              p076_timer = millis() + HLW_DELAYREADING;
              ++p076_read_stage;
            }
            break;
          case 3:

            if (timeOutReached(p076_timer)) {
              p076_hvoltage = Plugin_076_hlw->getVoltage(valid);
              p076_hpower = Plugin_076_hlw->getActivePower(valid);
              p076_hpowfact = static_cast<int>(100 * Plugin_076_hlw->getPowerFactor(valid));
              ++p076_read_stage;


              Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 10);
            }
            break;
          default:

            break;
        }
      }
      success = true;
      break;

    case PLUGIN_READ:

      if (Plugin_076_hlw) {
        if (p076_read_stage == 0) {



          bool valid = false;
          p076_hpower = Plugin_076_hlw->getActivePower(valid);
          if (valid) {
            success = true;
          }

          p076_hvoltage = Plugin_076_hlw->getVoltage(valid);
          if (valid) {
            success = true;
          }
          p076_hcurrent = Plugin_076_hlw->getCurrent(valid);
          if (valid) {
            success = true;
          }
          p076_hpowfact = static_cast<int>(100 * Plugin_076_hlw->getPowerFactor(valid));
          if (valid) {
            success = true;
          }

          UserVar.setFloat(event->TaskIndex, 0, p076_hvoltage);
          UserVar.setFloat(event->TaskIndex, 1, p076_hcurrent);
          UserVar.setFloat(event->TaskIndex, 2, p076_hpower);
          UserVar.setFloat(event->TaskIndex, 3, p076_hpowfact);


          p076_read_stage = 0;

          #if PLUGIN_076_DEBUG
            String log = F("P076: Read values");
            log += F(" - V=");
            log += p076_hvoltage;
            log += F(" - A=");
            log += p076_hcurrent;
            log += F(" - W=");
            log += p076_hpower;
            log += F(" - Pf%=");
            log += p076_hpowfact;
            addLogMove(LOG_LEVEL_INFO, log);
          #endif



        }
      }
      break;

    case PLUGIN_EXIT: {
      Plugin076_Reset(event->TaskIndex);
      success = true;
      break;
    }

    case PLUGIN_INIT: {
      Plugin076_Reset(event->TaskIndex);


      const uint8_t CF_PIN = CONFIG_PIN3;
      const uint8_t CF1_PIN = CONFIG_PIN2;
      const uint8_t SEL_PIN = CONFIG_PIN1;

      if (validGpio(CF_PIN) && validGpio(CF1_PIN) && validGpio(SEL_PIN)) {
        Plugin_076_hlw = new (std::nothrow) HLW8012;

        if (Plugin_076_hlw) {
          uint8_t currentRead = PCONFIG(4);
          uint8_t cf_trigger = PCONFIG(5);
          uint8_t cf1_trigger = PCONFIG(6);

          Plugin_076_hlw->begin(CF_PIN, CF1_PIN, SEL_PIN, currentRead,
                                true);

          #if PLUGIN_076_DEBUG
            addLog(LOG_LEVEL_INFO, F("P076: Init object done"));
          #endif
          Plugin_076_hlw->setResistors(HLW_CURRENT_RESISTOR,
                                       HLW_VOLTAGE_RESISTOR_UP,
                                       HLW_VOLTAGE_RESISTOR_DOWN);
          #if PLUGIN_076_DEBUG
            addLog(LOG_LEVEL_INFO, F("P076: Init Basic Resistor Values done"));
          #endif

          ESPEASY_RULES_FLOAT_TYPE current, voltage, power;

          if (Plugin076_LoadMultipliers(event->TaskIndex, current, voltage, power)) {
            #if PLUGIN_076_DEBUG
              addLog(LOG_LEVEL_INFO, F("P076: Saved Calibration after INIT"));
            #endif

            Plugin_076_hlw->setCurrentMultiplier(current);
            Plugin_076_hlw->setVoltageMultiplier(voltage);
            Plugin_076_hlw->setPowerMultiplier(power);
          } else {
            Plugin076_ResetMultipliers();
          }

          #if PLUGIN_076_DEBUG
            addLog(LOG_LEVEL_INFO, F("P076: Applied Calibration after INIT"));
          #endif

          StoredTaskIndex = event->TaskIndex;



          attachInterrupt(CF1_PIN, p076_hlw8012_cf1_interrupt, cf1_trigger);
          attachInterrupt(CF_PIN, p076_hlw8012_cf_interrupt, cf_trigger);


          Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 5000);
          success = true;
        }
      }
      break;
    }

    case PLUGIN_WRITE:

      if (Plugin_076_hlw) {
        const String command = parseString(string, 1);

        if (equals(command, F("hlwreset"))) {
          Plugin076_ResetMultipliers();
          success = true;
        }

        if (equals(command, F("hlwcalibrate"))) {
          float CalibVolt = 0.0f;
          float CalibCurr = 0.0f;
          float CalibAcPwr = 0.0f;

          if (validFloatFromString(parseString(string, 2), CalibVolt)) {
            if (validFloatFromString(parseString(string, 3), CalibCurr)) {
              validFloatFromString(parseString(string, 4), CalibAcPwr);
            }
          }
          #if PLUGIN_076_DEBUG
            String log = F("P076: Calibration to values");
            log += F(" - Expected-V=");
            log += CalibVolt;
            log += F(" - Expected-A=");
            log += CalibCurr;
            log += F(" - Expected-W=");
            log += CalibAcPwr;
            addLogMove(LOG_LEVEL_INFO, log);
          #endif
          bool changed = false;

          if (CalibVolt != 0) {
            Plugin_076_hlw->expectedVoltage(CalibVolt);
            changed = true;
          }

          if (definitelyGreaterThan(CalibCurr, 0.0f)) {
            Plugin_076_hlw->expectedCurrent(CalibCurr);
            changed = true;
          }

          if (!essentiallyEqual(CalibAcPwr, 0.0f)) {
            Plugin_076_hlw->expectedActivePower(CalibAcPwr);
            changed = true;
          }



          if (changed) {
            Plugin076_SaveMultipliers();
          }
          success = true;
        }
      }
      break;
  }
  return success;
}

void Plugin076_ResetMultipliers() {
  if (Plugin_076_hlw) {
    Plugin_076_hlw->resetMultipliers();
    Plugin076_SaveMultipliers();
    #if PLUGIN_076_DEBUG
      addLog(LOG_LEVEL_INFO, F("P076: Reset Multipliers to DEFAULT"));
    #endif
  }
}

void Plugin076_SaveMultipliers() {
  if (StoredTaskIndex < 0) {
    return;
  }
  ESPEASY_RULES_FLOAT_TYPE hlwMultipliers[3]{};

  if (Plugin076_ReadMultipliers(hlwMultipliers[0], hlwMultipliers[1], hlwMultipliers[2])) {
#if FEATURE_USE_DOUBLE_AS_ESPEASY_RULES_FLOAT_TYPE
    SaveCustomTaskSettings(StoredTaskIndex, reinterpret_cast<const uint8_t *>(&hlwMultipliers),
                           sizeof(hlwMultipliers));
#else
    double hlwMultipliers_d[3]{};
    hlwMultipliers_d[0] = hlwMultipliers[0];
    hlwMultipliers_d[1] = hlwMultipliers[1];
    hlwMultipliers_d[2] = hlwMultipliers[2];

    SaveCustomTaskSettings(StoredTaskIndex, reinterpret_cast<const uint8_t *>(&hlwMultipliers_d),
                           sizeof(hlwMultipliers_d));
#endif
  }
}

bool Plugin076_ReadMultipliers(ESPEASY_RULES_FLOAT_TYPE& current, ESPEASY_RULES_FLOAT_TYPE& voltage, ESPEASY_RULES_FLOAT_TYPE& power) {
  current = 0.0f;
  voltage = 0.0f;
  power = 0.0f;

  if (Plugin_076_hlw) {
    current = Plugin_076_hlw->getCurrentMultiplier();
    voltage = Plugin_076_hlw->getVoltageMultiplier();
    power = Plugin_076_hlw->getPowerMultiplier();
    return true;
  }
  return false;
}

bool Plugin076_LoadMultipliers(taskIndex_t TaskIndex, ESPEASY_RULES_FLOAT_TYPE& current, ESPEASY_RULES_FLOAT_TYPE& voltage, ESPEASY_RULES_FLOAT_TYPE& power) {


  if (!Plugin076_ReadMultipliers(current, voltage, power)) {
    return false;
  }
  double hlwMultipliers[3];

  LoadCustomTaskSettings(TaskIndex, reinterpret_cast<uint8_t *>(&hlwMultipliers),
                         sizeof(hlwMultipliers));

  if (hlwMultipliers[0] > 1.0) {
    current = hlwMultipliers[0];
  }

  if (hlwMultipliers[1] > 1.0) {
    voltage = hlwMultipliers[1];
  }

  if (hlwMultipliers[2] > 1.0) {
    power = hlwMultipliers[2];
  }
  return (current > 1.0) && (voltage > 1.0) && (power > 1.0);
}

void Plugin076_Reset(taskIndex_t TaskIndex) {
  if (Plugin_076_hlw) {
    const uint8_t CF_PIN = Settings.TaskDevicePin3[TaskIndex];
    const uint8_t CF1_PIN = Settings.TaskDevicePin2[TaskIndex];
    detachInterrupt(CF_PIN);
    detachInterrupt(CF1_PIN);
    delete Plugin_076_hlw;
    Plugin_076_hlw = nullptr;
  }
  StoredTaskIndex = -1;
  p076_read_stage = 0;
  p076_timer = 0;

  p076_hcurrent = 0.0f;
  p076_hvoltage = 0.0f;
  p076_hpower = 0.0f;
  p076_hpowfact = 0.0f;
}



void IRAM_ATTR p076_hlw8012_cf1_interrupt() {
  if (Plugin_076_hlw) {
    Plugin_076_hlw->cf1_interrupt();
  }
}

void IRAM_ATTR p076_hlw8012_cf_interrupt() {
  if (Plugin_076_hlw) {
    Plugin_076_hlw->cf_interrupt();
  }
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P077_CSE7766.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P077
# 21 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P077_CSE7766.ino"
# include "src/PluginStructs/P077_data_struct.h"

#define PLUGIN_077 
#define PLUGIN_ID_077 77
# ifdef PLUGIN_SET_SONOFF_POW
  # define PLUGIN_NAME_077 "Energy (AC) - CSE7766 (POW r2)"
# else
  # define PLUGIN_NAME_077 "Energy (AC) - CSE7766"
# endif


#define P077_QUERY1_DFLT P077_query::P077_QUERY_VOLTAGE
#define P077_QUERY2_DFLT P077_query::P077_QUERY_ACTIVE_POWER
#define P077_QUERY3_DFLT P077_query::P077_QUERY_CURRENT
#define P077_QUERY4_DFLT P077_query::P077_QUERY_PULSES


boolean Plugin_077(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_077;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].TaskLogsOwnPeaks = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_077);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < static_cast<uint8_t>(P077_query::P077_QUERY_NR_OUTPUT_OPTIONS)) {
          const uint8_t pconfigIndex = i + P077_QUERY1_CONFIG_POS;
          P077_query choice = static_cast<P077_query>(PCONFIG(pconfigIndex));
          ExtraTaskSettings.setTaskDeviceValueName(i, Plugin_077_valuename(choice, false));

          if (choice == P077_query::P077_QUERY_PULSES) {
            ExtraTaskSettings.TaskDeviceValueDecimals[i] = 0;
          }
          else if (choice == P077_query::P077_QUERY_KWH) {
            ExtraTaskSettings.TaskDeviceValueDecimals[i] = 3;
          }
          else {
            ExtraTaskSettings.TaskDeviceValueDecimals[i] = 2;
          }
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      CONFIG_PIN1 = 3;
      CONFIG_PIN2 = 1;
      CONFIG_PORT = static_cast<int>(ESPEasySerialPort::serial0);

      P077_QUERY1 = static_cast<uint8_t>(P077_QUERY1_DFLT);
      P077_QUERY2 = static_cast<uint8_t>(P077_QUERY2_DFLT);
      P077_QUERY3 = static_cast<uint8_t>(P077_QUERY3_DFLT);
      P077_QUERY4 = static_cast<uint8_t>(P077_QUERY4_DFLT);

      success = true;
      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      P077_data_struct *P077_data =
        static_cast<P077_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P077_data) && P077_data->isInitialized()) {
        const P077_query query = Plugin_077_from_valuename(string);

        if (query != P077_query::P077_QUERY_NR_OUTPUT_OPTIONS) {
          const float value = P077_data->getValue(query);
          int nrDecimals = 2;

          if ((query == P077_query::P077_QUERY_PULSES)) {
            nrDecimals = 0;
          } else if ((query == P077_query::P077_QUERY_KWH)) {
            nrDecimals = 3;
          }

          string = toString(value, nrDecimals);
          success = true;
        }
      }
      break;
    }


    case PLUGIN_GET_DEVICEGPIONAMES: {
      serialHelper_getGpioNames(event);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      if ((CONFIG_PIN1 == -1) && (CONFIG_PIN2 == -1) && (CONFIG_PORT == 0)) {
        CONFIG_PIN1 = 3;
        CONFIG_PIN2 = 1;
        CONFIG_PORT = static_cast<int>(ESPEasySerialPort::serial0);
      }
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      const __FlashStringHelper *options[static_cast<uint8_t>(P077_query::P077_QUERY_NR_OUTPUT_OPTIONS)];

      for (uint8_t i = 0; i < static_cast<uint8_t>(P077_query::P077_QUERY_NR_OUTPUT_OPTIONS); ++i) {
        options[i] = Plugin_077_valuename(static_cast<P077_query>(i), true);
      }

      for (uint8_t i = 0; i < P077_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P077_QUERY1_CONFIG_POS;
        sensorTypeHelper_loadOutputSelector(event, pconfigIndex, i, static_cast<int>(P077_query::P077_QUERY_NR_OUTPUT_OPTIONS), options);
      }
      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
      addFormNumericBox(F("U Ref"), P077_UREF_LABEL, P077_UREF);
      addUnit(F("uSec"));

      addFormNumericBox(F("I Ref"), P077_IREF_LABEL, P077_IREF);
      addUnit(F("uSec"));

      addFormNumericBox(F("P Ref"), P077_PREF_LABEL, P077_PREF);
      addUnit(F("uSec"));
      addFormNote(F("Use 0 to read values stored on chip / default values"));

      P077_data_struct *P077_data = static_cast<P077_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P077_data) {
        addRowLabel(F("Pulses per kWh"));
        const int pulsesPerKwh = P077_data->cf_frequency * 3600;
        addHtmlInt(pulsesPerKwh);
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      P077_UREF = getFormItemInt(P077_UREF_LABEL);
      P077_IREF = getFormItemInt(P077_IREF_LABEL);
      P077_PREF = getFormItemInt(P077_PREF_LABEL);


      for (int i = 0; i < P077_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P077_QUERY1_CONFIG_POS;
        const P077_query choice = static_cast<P077_query>(PCONFIG(pconfigIndex));
        sensorTypeHelper_saveOutputSelector(event, pconfigIndex, i, Plugin_077_valuename(choice, false));
      }

      success = true;
      break;
    }

    case PLUGIN_INIT: {
      if ((CONFIG_PIN1 == -1) && (CONFIG_PIN2 == -1) && (CONFIG_PORT == 0)) {
        CONFIG_PIN1 = 3;
        CONFIG_PIN2 = 1;
        CONFIG_PORT = static_cast<int>(ESPEasySerialPort::serial0);
      }
      const int16_t serial_rx = CONFIG_PIN1;
      const int16_t serial_tx = CONFIG_PIN2;
      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);

      if ((P077_QUERY1 == 0) &&
          (P077_QUERY2 == 0) &&
          (P077_QUERY3 == 0) &&
          (P077_QUERY4 == 0))
      {

        P077_QUERY1 = static_cast<uint8_t>(P077_QUERY1_DFLT);
        P077_QUERY2 = static_cast<uint8_t>(P077_QUERY2_DFLT);
        P077_QUERY3 = static_cast<uint8_t>(P077_QUERY3_DFLT);
        P077_QUERY4 = static_cast<uint8_t>(P077_QUERY4_DFLT);
      }

      initPluginTaskData(event->TaskIndex, new (std::nothrow) P077_data_struct());
      P077_data_struct *P077_data = static_cast<P077_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P077_data) {
        return success;
      }

      if (P077_UREF == 0) { P077_UREF = CSE_UREF_PULSE; }

      if (P077_IREF == 0) { P077_IREF = CSE_IREF_PULSE; }

      if (P077_PREF == 0) { P077_PREF = CSE_PREF_PULSE; }

      if (P077_data->init(port, serial_rx, serial_tx, 4800, static_cast<uint8_t>(SERIAL_8E1))) {
        success = true;
        serialHelper_log_GpioDescription(port, serial_rx, serial_tx);
      }

      break;
    }

    case PLUGIN_WEBFORM_SHOW_VALUES:
    {
      P077_data_struct *P077_data = static_cast<P077_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P077_data) {
        uint8_t varNr = VARS_PER_TASK;
        const float pulsesPerKwh = P077_data->cf_frequency * 3600;
        const float kWh = P077_data->cf_pulses / pulsesPerKwh;
        pluginWebformShowValue(event->TaskIndex, varNr++, F("kWh"), toString(kWh, 3), true);
      }
      break;
    }

    case PLUGIN_READ: {
      # ifndef BUILD_NO_DEBUG
      addLog(LOG_LEVEL_DEBUG_DEV, F("CSE: plugin read"));
      # endif

      P077_data_struct *P077_data = static_cast<P077_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P077_data) {


        success = P077_data->plugin_read(event);
      }
      break;
    }

    case PLUGIN_SERIAL_IN:

      if (ESPEasySerialPort::serial0 != static_cast<ESPEasySerialPort>(CONFIG_PORT)) {
        return success;
      }


    case PLUGIN_TEN_PER_SECOND:
    {
      P077_data_struct *P077_data = static_cast<P077_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P077_data) {
        success = true;


        if (P077_data->processSerialData()) {
          # ifndef BUILD_NO_DEBUG
          addLog(LOG_LEVEL_DEBUG, F("CSE: packet found"));
          # endif

          if (P077_data->processCseReceived(event)) {
            # ifndef BUILD_NO_DEBUG

            if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
              String log = F("CSE voltage: ");
              log += P077_data->getValue(P077_query::P077_QUERY_VOLTAGE);
              addLogMove(LOG_LEVEL_DEBUG, log);
              log = F("CSE power: ");
              log += P077_data->getValue(P077_query::P077_QUERY_ACTIVE_POWER);
              addLogMove(LOG_LEVEL_DEBUG, log);
              log = F("CSE current: ");
              log += P077_data->getValue(P077_query::P077_QUERY_CURRENT);
              addLogMove(LOG_LEVEL_DEBUG, log);
              log = F("CSE pulses: ");
              log += P077_data->cf_pulses;
              addLogMove(LOG_LEVEL_DEBUG, log);
            }
            # endif
          }

          # ifndef BUILD_NO_DEBUG

          if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
            String log = F("CSE: time ");
            log += P077_data->t_max;
            log += '/';
            log += P077_data->t_pkt;
            log += '/';
            log += P077_data->t_all;
            addLogMove(LOG_LEVEL_DEBUG, log);
            log = F("CSE: bytes ");
            log += P077_data->count_bytes;
            log += '/';
            log += P077_data->count_max;
            log += '/';
            log += P077_data->serial_Available();
            addLogMove(LOG_LEVEL_DEBUG, log);
            log = F("CSE: nr ");
            log += P077_data->count_pkt;
            addLogMove(LOG_LEVEL_DEBUG, log);
          }
          # endif
          P077_data->t_all = 0;
          P077_data->count_bytes = 0;
        }
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P077_data_struct *P077_data = static_cast<P077_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P077_data) {
        success = P077_data->plugin_write(event, string);
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P078_Eastron.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P078
# 15 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P078_Eastron.ino"
#define PLUGIN_078 
#define PLUGIN_ID_078 78
#define PLUGIN_NAME_078 "Energy (AC) - Eastron SDMxxx Modbus"

#define P078_NR_OUTPUT_VALUES 4
#define P078_NR_OUTPUT_OPTIONS_SDM220_SDM120CT_SDM120 14
#define P078_NR_OUTPUT_OPTIONS_SDM230 24
#define P078_NR_OUTPUT_OPTIONS_SDM630 86
#define P078_NR_OUTPUT_OPTIONS_SDM72D 9
#define P078_NR_OUTPUT_OPTIONS_DDM18SD 7


# include "src/PluginStructs/P078_data_struct.h"



ESPeasySerial *Plugin_078_ESPEasySerial = nullptr;
SDM *Plugin_078_SDM = nullptr;
boolean Plugin_078_init = false;

boolean Plugin_078(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_078;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL_PLUS1;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = P078_NR_OUTPUT_VALUES;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].TaskLogsOwnPeaks = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_078);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < P078_NR_OUTPUT_VALUES) {
          const SDM_MODEL model = static_cast<SDM_MODEL>(P078_MODEL);
          const uint8_t choice = PCONFIG(i + P078_QUERY1_CONFIG_POS);
          ExtraTaskSettings.setTaskDeviceValueName(i, SDM_getValueNameForModel(model, choice));
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      serialHelper_modbus_getGpioNames(event);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P078_DEV_ID = P078_DEV_ID_DFLT;
      P078_MODEL = P078_MODEL_DFLT;
      P078_BAUDRATE = P078_BAUDRATE_DFLT;
      P078_QUERY1 = P078_QUERY1_DFLT;
      P078_QUERY2 = P078_QUERY2_DFLT;
      P078_QUERY3 = P078_QUERY3_DFLT;
      P078_QUERY4 = P078_QUERY4_DFLT;

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_SERIAL_PARAMS:
    {
      if ((P078_DEV_ID == 0) || (P078_DEV_ID > 247) || (P078_BAUDRATE >= 6)) {

        P078_DEV_ID = P078_DEV_ID_DFLT;
        P078_MODEL = P078_MODEL_DFLT;
        P078_BAUDRATE = P078_BAUDRATE_DFLT;
        P078_QUERY1 = P078_QUERY1_DFLT;
        P078_QUERY2 = P078_QUERY2_DFLT;
        P078_QUERY3 = P078_QUERY3_DFLT;
        P078_QUERY4 = P078_QUERY4_DFLT;
      }
      {
        String options_baudrate[6];

        for (int i = 0; i < 6; ++i) {
          options_baudrate[i] = String(p078_storageValueToBaudrate(i));
        }
        addFormSelector(F("Baud Rate"), P078_BAUDRATE_LABEL, 6, options_baudrate, nullptr, P078_BAUDRATE);
        addUnit(F("baud"));
      }

      if ((P078_MODEL == 0) && (P078_BAUDRATE > 3)) {
        addFormNote(F("<span style=\"color:red\"> SDM120 only allows up to 9600 baud with default 2400!</span>"));
      }

      if ((P078_MODEL == 3) && (P078_BAUDRATE == 0)) {
        addFormNote(F("<span style=\"color:red\"> SDM630 only allows 2400 to 38400 baud with default 9600!</span>"));
      }

      addFormNumericBox(F("Modbus Address"), P078_DEV_ID_LABEL, P078_DEV_ID, 1, 247);

      #ifdef ESP32
      addFormCheckBox(F("Enable Collision Detection"), F(P078_FLAG_COLL_DETECT_LABEL), P078_GET_FLAG_COLL_DETECT);
      addFormNote(F("/RE connected to GND, only supported on hardware serial"));
      #endif



      if (Plugin_078_SDM != nullptr) {
        addRowLabel(F("Checksum (pass/fail)"));
        String chksumStats;
        chksumStats = Plugin_078_SDM->getSuccCount();
        chksumStats += '/';
        chksumStats += Plugin_078_SDM->getErrCount();
        addHtml(chksumStats);
      }

      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {

      for (uint8_t i = 0; i < P078_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P078_QUERY1_CONFIG_POS;
        SDM_loadOutputSelector(event, pconfigIndex, i);
      }

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *options_model[] = {
          F("SDM220 & SDM120CT & SDM120"),
          F("SDM230"),
          F("SDM72D"),
          F("DDM18SD"),
          F("SDM630"),
          F("SDM72_V2"),
          F("SDM320C")
        };
        constexpr size_t nrOptions = NR_ELEMENTS(options_model);
        addFormSelector(F("Model Type"), P078_MODEL_LABEL, nrOptions, options_model, nullptr, P078_MODEL);
        addFormNote(F("Submit after changing the modell to update Output Configuration."));
      }
      success = true;
      break;
    }


    case PLUGIN_WEBFORM_SAVE:
    {

      const SDM_MODEL model = static_cast<SDM_MODEL>(P078_MODEL);

      for (uint8_t i = 0; i < P078_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P078_QUERY1_CONFIG_POS;
        const uint8_t choice = PCONFIG(pconfigIndex);
        sensorTypeHelper_saveOutputSelector(
          event,
          pconfigIndex,
          i,
          SDM_getValueNameForModel(model, choice));
      }

      P078_DEV_ID = getFormItemInt(P078_DEV_ID_LABEL);
      P078_MODEL = getFormItemInt(P078_MODEL_LABEL);
      P078_BAUDRATE = getFormItemInt(P078_BAUDRATE_LABEL);
      #ifdef ESP32
      P078_SET_FLAG_COLL_DETECT(isFormItemChecked(F(P078_FLAG_COLL_DETECT_LABEL)));
      #endif

      Plugin_078_init = false;
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      Plugin_078_init = true;

      if (Plugin_078_ESPEasySerial != nullptr) {
        delete Plugin_078_ESPEasySerial;
        Plugin_078_ESPEasySerial = nullptr;
      }
      Plugin_078_ESPEasySerial = new (std::nothrow) ESPeasySerial(static_cast<ESPEasySerialPort>(CONFIG_PORT), CONFIG_PIN1, CONFIG_PIN2);

      if (Plugin_078_ESPEasySerial == nullptr) {
        break;
      }
      unsigned int baudrate = p078_storageValueToBaudrate(P078_BAUDRATE);
      Plugin_078_ESPEasySerial->begin(baudrate);

      if (Plugin_078_SDM != nullptr) {
        delete Plugin_078_SDM;
        Plugin_078_SDM = nullptr;
      }

      if (Plugin_078_ESPEasySerial->setRS485Mode(P078_DEPIN, P078_GET_FLAG_COLL_DETECT)) {
        Plugin_078_SDM = new (std::nothrow) SDM(*Plugin_078_ESPEasySerial, baudrate);
      } else {
        Plugin_078_SDM = new (std::nothrow) SDM(*Plugin_078_ESPEasySerial, baudrate, P078_DEPIN);
      }

      if (Plugin_078_SDM != nullptr) {
        success = true;
        Plugin_078_SDM->begin();


        Plugin_078_SDM->setMsTimeout((10000 / baudrate) + 1);

        SDM_MODEL model = static_cast<SDM_MODEL>(P078_MODEL);
        uint8_t dev_id = P078_DEV_ID;
# 276 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P078_Eastron.ino"
        for (taskVarIndex_t i = 0; i < VARS_PER_TASK; ++i) {
          const uint16_t reg = SDM_getRegisterForModel(model, PCONFIG((P078_QUERY1_CONFIG_POS) + i));
          SDM_addRegisterReadQueueElement(event->TaskIndex, i, reg, dev_id);
        }


        Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 2000);

      }
      break;
    }

    case PLUGIN_EXIT:
    {
      for (taskVarIndex_t i = 0; i < VARS_PER_TASK; ++i) {
        SDM_removeRegisterReadQueueElement(event->TaskIndex, i);
      }

      Plugin_078_init = false;

      if (Plugin_078_ESPEasySerial != nullptr) {
        delete Plugin_078_ESPEasySerial;
        Plugin_078_ESPEasySerial = nullptr;
      }

      if (Plugin_078_SDM != nullptr) {
        delete Plugin_078_SDM;
        Plugin_078_SDM = nullptr;
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      if (Plugin_078_init)
      {
        SDM_loopRegisterReadQueue(Plugin_078_SDM);
      }
      break;
    }

    case PLUGIN_READ:
    {
      if (Plugin_078_init)
      {
        success = true;
        break;
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      if (Plugin_078_init && (Plugin_078_SDM != nullptr)) {
        const String cmd = parseString(string, 1);

        if (equals(cmd, F("eastron"))) {
          const String subcmd = parseString(string, 2);

          if (equals(subcmd, F("pause"))) {
            SDM_pause_loopRegisterReadQueue();
            success = true;
          } else if (equals(subcmd, F("resume"))) {
            SDM_resume_loopRegisterReadQueue();
            success = true;
          } else {
            uint8_t node_id = event->Par3;

            if ((node_id < 1) || (node_id > 247)) { node_id = 1; }

            if (equals(subcmd, F("setid"))) {


              const uint8_t new_id = event->Par2;

              if ((new_id >= 1) && (new_id <= 247) && (new_id != node_id)) {
                success = Plugin_078_SDM->writeHoldingRegister(new_id, SDM_HOLDING_METER_ID, node_id);
              }
            } else if (equals(subcmd, F("setbaud"))) {
# 377 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P078_Eastron.ino"
              int new_baud = event->Par2;

              if (new_baud > 5) {
                const int baudrates[] = { 2400, 4800, 9600, 19200, 38400, 1200 };
                constexpr int nrBaudRates = NR_ELEMENTS(baudrates);

                for (int i = 0; i < nrBaudRates && new_baud > 5; ++i) {
                  if (new_baud == baudrates[i]) {
                    new_baud = i;
                  }
                }
              }

              if ((new_baud >= 0) && (new_baud <= 5)) {
                success = Plugin_078_SDM->writeHoldingRegister(new_baud, SDM_HOLDING_BAUD_RATE, node_id);
              }
            }
          }
        }
      }
      break;
    }
  }
  return success;
}

int p078_storageValueToBaudrate(uint8_t baudrate_setting) {
  int baudrate = 9600;

  if (baudrate_setting < 6) {
    baudrate = 1200 << baudrate_setting;
  }
  return baudrate;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P079_Wemos_Motorshield.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P079

# include "src/PluginStructs/P079_data_struct.h"
# 55 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P079_Wemos_Motorshield.ino"
#define PLUGIN_079 
#define PLUGIN_ID_079 79
#define PLUGIN_NAME_079 "Motor - Wemos/Lolin Motorshield"
#define PLUGIN_VALUENAME1_079 "Motorshield"
#define PLUGIN_DEF_NAME1_079 "Wemos_DC_Motor"
#define PLUGIN_DEF_NAME2_079 "Lolin_DC_Motor"

#define I2C_ADDR_PCFG_P079 PCONFIG(0)
#define SHIELD_VER_PCFG_P079 PCONFIG(1)
#define Plugin_079_MotorShield_type static_cast<P079_BoardType>(SHIELD_VER_PCFG_P079)



#define CMD_NAME_LOLIN "LolinMotorShieldCMD"
#define CMD_NAME_WEMOS "WemosMotorShieldCMD"







boolean Plugin_079(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;
  MOTOR_STATES motor_dir = MOTOR_STATES::MOTOR_FWD;
  uint8_t motor_number = P079_MOTOR_A;
  int16_t motor_speed = 100;


  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_079;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_079);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_079));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      I2C_ADDR_PCFG_P079 = DEF_I2C_ADDRESS_079;
      SHIELD_VER_PCFG_P079 = static_cast<int>(P079_BoardType::WemosMotorshield);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      if ((I2C_ADDR_PCFG_P079 < 0x01) || (I2C_ADDR_PCFG_P079 > 0x7f)) {
        I2C_ADDR_PCFG_P079 = DEF_I2C_ADDRESS_079;
      }
      addFormTextBox(F("I2C Address (Hex)"), F("i2c_addr"), formatToHex(I2C_ADDR_PCFG_P079), 4);

      {
        const __FlashStringHelper *options[] = {
          F("WEMOS V1.0"),
          F("LOLIN V2.0")
        };
        const int indices[] = {
          static_cast<int>(P079_BoardType::WemosMotorshield),
          static_cast<int>(P079_BoardType::LolinMotorshield)
        };
        addFormSelector(F("Motor Shield Type"), F("shield_type"), 2, options, indices, SHIELD_VER_PCFG_P079);
      }

      if (Plugin_079_MotorShield_type == P079_BoardType::WemosMotorshield) {
        addFormNote(F("WEMOS V1.0 Motor Shield requires updated firmware, "
                      "see <a href='https://www.letscontrolit.com/wiki/index.php?title=WemosMotorshield'>wiki</a>"));
      }

      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = I2C_ADDR_PCFG_P079;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD: {
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      String i2c_address = webArg(F("i2c_addr"));
      I2C_ADDR_PCFG_P079 = (int)strtol(i2c_address.c_str(), 0, 16);
      SHIELD_VER_PCFG_P079 = getFormItemInt(F("shield_type"));


      if (getTaskDeviceName(event->TaskIndex).isEmpty()) {
        switch (Plugin_079_MotorShield_type) {
          case P079_BoardType::WemosMotorshield:

            safe_strncpy(ExtraTaskSettings.TaskDeviceName, F(PLUGIN_DEF_NAME1_079), sizeof(ExtraTaskSettings.TaskDeviceName));
            break;
          case P079_BoardType::LolinMotorshield:

            safe_strncpy(ExtraTaskSettings.TaskDeviceName, F(PLUGIN_DEF_NAME2_079), sizeof(ExtraTaskSettings.TaskDeviceName));
            break;
        }
      }

      success = true;
      break;
    }

    case PLUGIN_INIT: {


      bool valid = false;

      switch (Plugin_079_MotorShield_type) {
        case P079_BoardType::WemosMotorshield:
        case P079_BoardType::LolinMotorshield:
          valid = true;
          break;


      }

      if (!valid) {
        SHIELD_VER_PCFG_P079 = static_cast<int>(P079_BoardType::WemosMotorshield);
      }

      success = true;
      break;
    }

    case PLUGIN_READ: {
      success = false;
      break;
    }

    case PLUGIN_WRITE: {
      # if FEATURE_I2C_DEVICE_CHECK

      if (!I2C_deviceCheck(I2C_ADDR_PCFG_P079, event->TaskIndex, 10, PLUGIN_I2C_GET_ADDRESS)) {
        break;
      }
      # endif
      uint8_t parse_error = false;
      String ModeStr;

      String cmd = parseString(string, 1);

      if (cmd.equalsIgnoreCase(F(CMD_NAME_WEMOS)) || cmd.equalsIgnoreCase(F(CMD_NAME_LOLIN))) {
        switch (Plugin_079_MotorShield_type) {
          case P079_BoardType::WemosMotorshield:
            ModeStr = F("WemosV1");
            break;
          case P079_BoardType::LolinMotorshield:
            ModeStr = F("LolinV2");
            break;
        }
        ModeStr += F(" MotorShield");

        String paramMotor = parseString(string, 2);
        String paramDirection = parseString(string, 3);
        String paramSpeed = parseString(string, 4);

        if ((paramMotor.isEmpty()) && (paramDirection.isEmpty()) && (paramSpeed.isEmpty())) {
          switch (Plugin_079_MotorShield_type) {
            case P079_BoardType::WemosMotorshield:
              # ifdef VERBOSE_P079
              ModeStr += F(": Unknown CMD");
              # else
              ModeStr += F(": ?");
              # endif
              break;
            case P079_BoardType::LolinMotorshield:
            {
              LOLIN_I2C_MOTOR lolin(I2C_ADDR_PCFG_P079);
              lolin.getInfo();

              if (lolin.PRODUCT_ID != PRODUCT_ID_I2C_LOLIN) {
                ModeStr += F(": Fail");
              }
              else {
                ModeStr += F(": Pass, ID=");
                ModeStr += lolin.PRODUCT_ID;
                ModeStr += F(", Ver=");
                ModeStr += lolin.VERSION_ID;
              }
              break;
            }
          }
          addLog(LOG_LEVEL_INFO, ModeStr);
          SendStatus(event, ModeStr + F(" <br>"));
          return true;
        }
        else {
          if ((equals(paramMotor, '0')) || (equals(paramMotor, '1'))) {
            motor_number = paramMotor.toInt();
          }
          else {
            if (paramMotor.isEmpty()) {
              paramMotor = '?';
            }
            motor_number = 0;
            parse_error = true;
          }

          if (paramDirection.equalsIgnoreCase(F("Stop"))) {
            motor_dir = MOTOR_STATES::MOTOR_STOP;
          }
          else if (paramDirection.equalsIgnoreCase(F("Forward"))) {
            motor_dir = MOTOR_STATES::MOTOR_FWD;
          }
          else if ((paramDirection.equalsIgnoreCase(F("Backward")))) {
            motor_dir = MOTOR_STATES::MOTOR_REV;
          }
          else if (paramDirection.equalsIgnoreCase(F("Standby"))) {
            motor_dir = MOTOR_STATES::MOTOR_STBY;
          }
          else if (paramDirection.equalsIgnoreCase(F("Brake"))) {
            motor_dir = MOTOR_STATES::MOTOR_BRAKE;
          }
          else {
            paramDirection = '?';
            motor_dir = MOTOR_STATES::MOTOR_STOP;
            parse_error = true;
          }

          if (paramSpeed.isEmpty()) {
            switch (motor_dir) {
              case MOTOR_STATES::MOTOR_STOP:
              case MOTOR_STATES::MOTOR_STBY:
              case MOTOR_STATES::MOTOR_BRAKE:
                paramSpeed = '0';
                motor_speed = 0;
                break;
              default:
                parse_error = true;
                paramSpeed = '?';
                break;
            }
          }
          else {
            motor_speed = paramSpeed.toInt();

            if ((motor_speed < 0) || (motor_speed > 100)) {
              motor_speed = 100;
              # ifdef VERBOSE_P079
              addLog(LOG_LEVEL_INFO, ModeStr + F(": Warning, invalid speed: Now using 100"));
              # endif
            }
          }
        }

        if (parse_error == true) {
          String ErrorStr = ModeStr;
          ErrorStr += F(": CMD Syntax Error");
          SendStatus(event, ErrorStr + F(" <br>"));
          addLogMove(LOG_LEVEL_INFO, ErrorStr);
        }
        else {
          switch (motor_dir) {
            case MOTOR_STATES::MOTOR_STOP:
            case MOTOR_STATES::MOTOR_STBY:
            case MOTOR_STATES::MOTOR_BRAKE:
              paramSpeed = '0';
              break;
            default:
              break;
          }

          switch (Plugin_079_MotorShield_type) {
            case P079_BoardType::WemosMotorshield: {
              WemosMotor Wemos(I2C_ADDR_PCFG_P079, motor_number, MOTOR_FREQ_P079);
              Wemos.init();

              switch (motor_dir) {
                case MOTOR_STATES::MOTOR_FWD:
                  Wemos.setmotor(P079_CW, motor_speed);
                  break;
                case MOTOR_STATES::MOTOR_REV:
                  Wemos.setmotor(P079_CCW, motor_speed);
                  break;
                case MOTOR_STATES::MOTOR_STOP:
                  Wemos.setmotor(P079_STOP);
                  break;
                case MOTOR_STATES::MOTOR_STBY:
                  Wemos.setmotor(P079_STANDBY);
                  break;
                case MOTOR_STATES::MOTOR_BRAKE:
                  Wemos.setmotor(P079_SHORT_BRAKE);
                  break;
              }

              break;
            }
            case P079_BoardType::LolinMotorshield: {
              LOLIN_I2C_MOTOR lolin(I2C_ADDR_PCFG_P079);
              lolin.changeFreq(MOTOR_CH_BOTH, MOTOR_FREQ_P079);

              switch (motor_dir) {
                case MOTOR_STATES::MOTOR_FWD:
                  lolin.changeStatus(motor_number, MOTOR_STATUS_CW);
                  lolin.changeDuty(motor_number, motor_speed);
                  break;
                case MOTOR_STATES::MOTOR_REV:
                  lolin.changeStatus(motor_number, MOTOR_STATUS_CCW);
                  lolin.changeDuty(motor_number, motor_speed);
                  break;
                case MOTOR_STATES::MOTOR_STOP:
                  lolin.changeStatus(motor_number, MOTOR_STATUS_STOP);
                  break;
                case MOTOR_STATES::MOTOR_STBY:
                  lolin.changeStatus(motor_number, MOTOR_STATUS_STANDBY);
                  break;
                case MOTOR_STATES::MOTOR_BRAKE:
                  lolin.changeStatus(motor_number, MOTOR_STATUS_SHORT_BRAKE);
                  break;
              }

              break;
            }
          }
        }

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          ModeStr += F(": Addr=");
          ModeStr += formatToHex(I2C_ADDR_PCFG_P079);
          ModeStr += F(": Mtr=");
          ModeStr += paramMotor;
          ModeStr += F(", Dir=");
          ModeStr += paramDirection;
          ModeStr += F(", Spd=");
          ModeStr += paramSpeed;
          addLogMove(LOG_LEVEL_INFO, ModeStr);
        }

        success = true;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P080_DallasIButton.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P080







# include "src/Helpers/Dallas1WireHelper.h"

#define PLUGIN_080 
#define PLUGIN_ID_080 80
#define PLUGIN_NAME_080 "Input - iButton"
#define PLUGIN_VALUENAME1_080 "iButton"


int8_t Plugin_080_DallasPin;

boolean Plugin_080(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_080;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_ULONG;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_080);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_080));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_bidirectional(F("1-Wire"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNote(F("External pull up resistor is needed, see docs!"));


      Plugin_080_DallasPin = CONFIG_PIN1;

      if (validGpio(Plugin_080_DallasPin)) {
        Dallas_addr_selector_webform_load(event->TaskIndex, Plugin_080_DallasPin, Plugin_080_DallasPin);
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {

      Dallas_addr_selector_webform_save(event->TaskIndex, CONFIG_PIN1, CONFIG_PIN1);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      uint8_t addr[8];
      Dallas_plugin_get_addr(addr, event->TaskIndex);
      string = Dallas_format_address(addr);
      success = true;
      break;
    }
    case PLUGIN_INIT:
    {
      Plugin_080_DallasPin = CONFIG_PIN1;

      if (validGpio(Plugin_080_DallasPin)) {
        uint8_t addr[8];



        pinMode(Plugin_080_DallasPin, INPUT);

        Dallas_plugin_get_addr(addr, event->TaskIndex);
        Dallas_startConversion(addr, Plugin_080_DallasPin, Plugin_080_DallasPin);

        delay(800);
        success = true;
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      uint8_t addr[8];
      Dallas_plugin_get_addr(addr, event->TaskIndex);

      if (addr[0] != 0) {
        Plugin_080_DallasPin = CONFIG_PIN1;

        if (Dallas_readiButton(addr, Plugin_080_DallasPin, Plugin_080_DallasPin))
        {
          UserVar.setUint32(event->TaskIndex, 0, 1);
          success = true;
        }
        else
        {
          UserVar.setUint32(event->TaskIndex, 0, 0);
        }
        Dallas_startConversion(addr, Plugin_080_DallasPin, Plugin_080_DallasPin);

        # ifndef BUILD_NO_DEBUG

        if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
          String log = F("DS   : iButton: ");

          if (success) {
            log += formatUserVarNoCheck(event->TaskIndex, 0);
          } else {
            log += F("Not Present!");
          }
          addLogMove(LOG_LEVEL_DEBUG, log);
        }
        # endif
      }
      break;
    }
    case PLUGIN_READ:
    {
      success = UserVar.getUint32(event->TaskIndex, 0) != UserVar.getUint32(event->TaskIndex, 2);


      UserVar.setUint32(event->TaskIndex, 2, UserVar.getUint32(event->TaskIndex, 0));
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P081_Cron.ino"
#include "_Plugin_Helper.h"







#ifdef USES_P081


# include "src/PluginStructs/P081_data_struct.h"

#define PLUGIN_081 
#define PLUGIN_ID_081 81
#define PLUGIN_NAME_081 "Generic - CRON"
#define PLUGIN_VALUENAME1_081 "LastExecution"
#define PLUGIN_VALUENAME2_081 "NextExecution"


boolean Plugin_081(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {


      Device[++deviceCount].Number = PLUGIN_ID_081;
      Device[deviceCount].Type = DEVICE_TYPE_DUMMY;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;

      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 2;

      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].TimerOptional = false;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].DecimalsOnly = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {

      string = F(PLUGIN_NAME_081);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {


      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_081));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_081));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Schedule"));
      addFormTextBox(F("CRON Expression")
                     , F("p081_cron_exp")
                     , P081_getCronExpr(event->TaskIndex)
                     , 39);

      addFormNote(F("S  M  H  DoM  Month  DoW"));

      P081_html_show_cron_expr(event);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      String expression = webArg(F("p081_cron_exp"));
      String log;
      {
        char expression_c[PLUGIN_081_EXPRESSION_SIZE] = {};
        safe_strncpy(expression_c, expression, PLUGIN_081_EXPRESSION_SIZE);
        log = SaveCustomTaskSettings(event->TaskIndex, reinterpret_cast<const uint8_t *>(&expression_c), PLUGIN_081_EXPRESSION_SIZE);
      }

      if (log.length() > 0)
      {
        addLog(LOG_LEVEL_ERROR, String(PSTR(PLUGIN_NAME_081)) + F(": Saving ") + log);
      }

      clearPluginTaskData(event->TaskIndex);
      P081_setCronExecTimes(event, CRON_INVALID_INSTANT, CRON_INVALID_INSTANT);
      success = true;
      break;
    }

    case PLUGIN_FORMAT_USERVAR:
    {
      switch (event->idx) {
        case 0:
          string = P081_formatExecTime(event->TaskIndex, LASTEXECUTION);
          break;
        case 1:
          string = P081_formatExecTime(event->TaskIndex, NEXTEXECUTION);
          break;
      }
      success = string.length() > 0;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P081_data_struct(P081_getCronExpr(event->TaskIndex)));
      P081_data_struct *P081_data =
        static_cast<P081_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P081_data) {
        return success;
      }

      if (P081_data->isInitialized()) {
        P081_check_or_init(event);
        success = true;
      } else {
        clearPluginTaskData(event->TaskIndex);
      }
      break;
    }


    case PLUGIN_READ:
    {

      success = true;
      break;
    }

    case PLUGIN_TIME_CHANGE:
    case PLUGIN_ONCE_A_SECOND:
    {

      if (node_time.systemTimePresent()) {
        P081_check_or_init(event);
        time_t next_exec_time = P081_getCronExecTime(event->TaskIndex, NEXTEXECUTION);

        if (next_exec_time != CRON_INVALID_INSTANT) {
          const time_t current_time = P081_getCurrentTime();
          const bool cron_elapsed = (next_exec_time <= current_time);

          if (cron_elapsed) {
            # ifndef BUILD_NO_DEBUG
            addLog(LOG_LEVEL_DEBUG, F("Cron Elapsed"));
            # endif

            time_t last_exec_time = next_exec_time;
            next_exec_time = P081_computeNextCronTime(event->TaskIndex, current_time);
            P081_setCronExecTimes(event, last_exec_time, next_exec_time);

            # ifndef BUILD_NO_DEBUG
            addLog(LOG_LEVEL_DEBUG, String(F("Next execution:")) + formatDateTimeString(*gmtime(&next_exec_time)));
            # endif

            if (function != PLUGIN_TIME_CHANGE) {
              if (Settings.UseRules) {
                eventQueue.addMove(concat(F("Cron#"), getTaskDeviceName(event->TaskIndex)));
              }
              success = true;
            }
          }
        } else {
          addLog(LOG_LEVEL_ERROR, F("CRON: INVALID INSTANT"));
        }
      } else {
        addLog(LOG_LEVEL_ERROR, F("CRON: Time not synced"));
      }


      break;
    }
  }

  return success;
}


#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P082_GPS.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P082
# 15 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P082_GPS.ino"
# include <ESPeasySerial.h>
# include <TinyGPS++.h>

# include "src/DataStructs/ESPEasy_packed_raw_data.h"
# include "src/Globals/ESPEasy_time.h"
# include "src/Helpers/ESPEasy_time_calc.h"

# include "src/PluginStructs/P082_data_struct.h"

#define PLUGIN_082 
#define PLUGIN_ID_082 82
#define PLUGIN_NAME_082 "Position - GPS"
#define PLUGIN_VALUENAME1_082 "Longitude"
#define PLUGIN_VALUENAME2_082 "Latitude"
#define PLUGIN_VALUENAME3_082 "Altitude"
#define PLUGIN_VALUENAME4_082 "Speed"




volatile unsigned long P082_pps_time = 0;
void Plugin_082_interrupt() IRAM_ATTR;

boolean Plugin_082(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_082;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL_PLUS1;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_082);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < P082_NR_OUTPUT_VALUES) {
          const uint8_t pconfigIndex = i + P082_QUERY1_CONFIG_POS;
          P082_query choice = static_cast<P082_query>(PCONFIG(pconfigIndex));
          ExtraTaskSettings.setTaskDeviceValueName(i, Plugin_082_valuename(choice, false));

          switch (choice) {
            case P082_query::P082_QUERY_LONG:
            case P082_query::P082_QUERY_LAT:
              ExtraTaskSettings.TaskDeviceValueDecimals[i] = 6;
              break;
            default:
              ExtraTaskSettings.TaskDeviceValueDecimals[i] = 2;
              break;
          }
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_WEBFORM_SHOW_VALUES:
    {
      P082_data_struct *P082_data =
        static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P082_data) && P082_data->isInitialized()) {
        uint8_t varNr = VARS_PER_TASK;
        pluginWebformShowValue(event->TaskIndex, varNr++, F("Fix"), String(P082_data->hasFix(P082_TIMEOUT) ? 1 : 0));
        pluginWebformShowValue(event->TaskIndex, varNr++, F("Tracked"),
                               String(P082_data->gps->satellitesStats.nrSatsTracked()));
        pluginWebformShowValue(event->TaskIndex, varNr++, F("Best SNR"), String(P082_data->gps->satellitesStats.getBestSNR()), true);


      }
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES: {
      serialHelper_getGpioNames(event, false, true);
      event->String3 = formatGpioName_input_optional(F("PPS"));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P082_TIMEOUT = P082_DEFAULT_FIX_TIMEOUT;
      P082_DISTANCE = P082_DISTANCE_DFLT;
      P082_QUERY1 = static_cast<uint8_t>(P082_QUERY1_DFLT);
      P082_QUERY2 = static_cast<uint8_t>(P082_QUERY2_DFLT);
      P082_QUERY3 = static_cast<uint8_t>(P082_QUERY3_DFLT);
      P082_QUERY4 = static_cast<uint8_t>(P082_QUERY4_DFLT);

      success = true;
      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      P082_data_struct *P082_data =
        static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P082_data) && P082_data->isInitialized()) {
        const P082_query query = Plugin_082_from_valuename(string);

        if (query != P082_query::P082_NR_OUTPUT_OPTIONS) {
          const float value = P082_data->_cache[static_cast<uint8_t>(query)];
          int nrDecimals = 2;

          if ((query == P082_query::P082_QUERY_LONG) || (query == P082_query::P082_QUERY_LAT)) {
            nrDecimals = 6;
          } else if ((query == P082_query::P082_QUERY_SATVIS) ||
                     (query == P082_query::P082_QUERY_SATUSE) ||
                     (query == P082_query::P082_QUERY_FIXQ) ||
                     (query == P082_query::P082_QUERY_CHKSUM_FAIL)) {
            nrDecimals = 0;
          }

          string = toString(value, nrDecimals);
          success = true;
        }
      }
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      const __FlashStringHelper *options[static_cast<uint8_t>(P082_query::P082_NR_OUTPUT_OPTIONS)];

      for (uint8_t i = 0; i < static_cast<uint8_t>(P082_query::P082_NR_OUTPUT_OPTIONS); ++i) {
        options[i] = Plugin_082_valuename(static_cast<P082_query>(i), true);
      }

      for (uint8_t i = 0; i < P082_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P082_QUERY1_CONFIG_POS;
        sensorTypeHelper_loadOutputSelector(event, pconfigIndex, i, static_cast<int>(P082_query::P082_NR_OUTPUT_OPTIONS), options);
      }
      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
# 183 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P082_GPS.ino"
      addFormNumericBox(F("Fix Timeout"), P082_TIMEOUT_LABEL, P082_TIMEOUT, 100, 10000);
      addUnit(F("ms"));

# ifdef P082_USE_U_BLOX_SPECIFIC

      addFormSubHeader(F("U-Blox specific"));

      {
        const __FlashStringHelper *options[3] = {
          toString(P082_PowerMode::Max_Performance),
          toString(P082_PowerMode::Power_Save),
          toString(P082_PowerMode::Eco)
        };
        const int indices[3] = {
          static_cast<int>(P082_PowerMode::Max_Performance),
          static_cast<int>(P082_PowerMode::Power_Save),
          static_cast<int>(P082_PowerMode::Eco)
        };
        addFormSelector(F("Power Mode"), F("pwrmode"), 3, options, indices, P082_POWER_MODE);
      }

      {
        const __FlashStringHelper *options[10] = {
          toString(P082_DynamicModel::Portable),
          toString(P082_DynamicModel::Stationary),
          toString(P082_DynamicModel::Pedestrian),
          toString(P082_DynamicModel::Automotive),
          toString(P082_DynamicModel::Sea),
          toString(P082_DynamicModel::Airborne_1g),
          toString(P082_DynamicModel::Airborne_2g),
          toString(P082_DynamicModel::Airborne_4g),
          toString(P082_DynamicModel::Wrist),
          toString(P082_DynamicModel::Bike)
        };
        const int indices[10] = {
          static_cast<int>(P082_DynamicModel::Portable),
          static_cast<int>(P082_DynamicModel::Stationary),
          static_cast<int>(P082_DynamicModel::Pedestrian),
          static_cast<int>(P082_DynamicModel::Automotive),
          static_cast<int>(P082_DynamicModel::Sea),
          static_cast<int>(P082_DynamicModel::Airborne_1g),
          static_cast<int>(P082_DynamicModel::Airborne_2g),
          static_cast<int>(P082_DynamicModel::Airborne_4g),
          static_cast<int>(P082_DynamicModel::Wrist),
          static_cast<int>(P082_DynamicModel::Bike)
        };
        addFormSelector(F("Dynamic Platform Model"), F("dynmodel"), 10, options, indices, P082_DYNAMIC_MODEL);
      }
# endif

      addFormSubHeader(F("Current Sensor Data"));

      P082_html_show_stats(event);
# 252 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P082_GPS.ino"
      {
        addFormSubHeader(F("Reference Point"));

        addFormFloatNumberBox(F("Latitude"), F("lat_ref"), P082_LAT_REF, -90.0f, 90.0f);
        addFormFloatNumberBox(F("Longitude"), F("lng_ref"), P082_LONG_REF, -180.0f, 180.0f);
      }

      addFormNumericBox(F("Distance Update Interval"), P082_DISTANCE_LABEL, P082_DISTANCE, 0, 10000);
      addUnit('m');
      addFormNote(F("0 = disable update based on distance travelled"));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      # ifdef P082_USE_U_BLOX_SPECIFIC
      P082_POWER_MODE = getFormItemInt(F("pwrmode"));
      P082_DYNAMIC_MODEL = getFormItemInt(F("dynmodel"));
      # endif
      P082_TIMEOUT = getFormItemInt(P082_TIMEOUT_LABEL);
      P082_DISTANCE = getFormItemInt(P082_DISTANCE_LABEL);

      P082_LONG_REF = getFormItemFloat(F("lng_ref"));
      P082_LAT_REF = getFormItemFloat(F("lat_ref"));


      for (int i = 0; i < P082_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P082_QUERY1_CONFIG_POS;
        const P082_query choice = static_cast<P082_query>(PCONFIG(pconfigIndex));
        sensorTypeHelper_saveOutputSelector(event, pconfigIndex, i, Plugin_082_valuename(choice, false));
      }

      success = true;
      break;
    }

# if FEATURE_PLUGIN_STATS
    case PLUGIN_WEBFORM_LOAD_SHOW_STATS:
    {
      P082_data_struct *P082_data =
        static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P082_data) {
        #if FEATURE_CHART_JS
        P082_data->webformLoad_show_position_scatterplot(event);
        #endif
        for (uint8_t i = 0; i < P082_NR_OUTPUT_VALUES; ++i) {
          const uint8_t pconfigIndex = i + P082_QUERY1_CONFIG_POS;

          if (P082_data->webformLoad_show_stats(event, i, static_cast<P082_query>(PCONFIG(pconfigIndex)))) {
            success = true;
          }
        }
      }
      break;
    }
# endif

    case PLUGIN_INIT: {
      if (P082_TIMEOUT < 100) {
        P082_TIMEOUT = P082_DEFAULT_FIX_TIMEOUT;
      }
      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);
      const int16_t serial_rx = CONFIG_PIN1;
      const int16_t serial_tx = CONFIG_PIN2;
      const int16_t pps_pin = CONFIG_PIN3;

      # ifdef USE_SECOND_HEAP
      HeapSelectIram ephemeral;
      # endif

      initPluginTaskData(event->TaskIndex, new (std::nothrow) P082_data_struct());
      P082_data_struct *P082_data =
        static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P082_data) {
        return success;
      }

      if (P082_data->init(port, serial_rx, serial_tx)) {
        success = true;
        serialHelper_log_GpioDescription(port, serial_rx, serial_tx);

        if (validGpio(pps_pin)) {

          attachInterrupt(pps_pin, Plugin_082_interrupt, RISING);
        }
        # ifdef P082_USE_U_BLOX_SPECIFIC
        P082_data->setPowerMode(static_cast<P082_PowerMode>(P082_POWER_MODE));
        P082_data->setDynamicModel(static_cast<P082_DynamicModel>(P082_DYNAMIC_MODEL));
        # endif
      } else {
        clearPluginTaskData(event->TaskIndex);
      }
      break;
    }

    case PLUGIN_EXIT: {
      P082_data_struct *P082_data =
        static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P082_data) {
        P082_data->powerDown();
      }

      const int16_t pps_pin = CONFIG_PIN3;

      if (validGpio(pps_pin)) {
        detachInterrupt(pps_pin);
      }
      success = true;
      break;
    }

    case PLUGIN_FIFTY_PER_SECOND: {
      P082_data_struct *P082_data =
        static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P082_data) && P082_data->loop()) {
        P082_setSystemTime(event);
# ifdef P082_SEND_GPS_TO_LOG

        if (P082_data->_lastSentence.substring(0, 10).indexOf(F("TXT")) != -1) {
          addLog(LOG_LEVEL_INFO, P082_data->_lastSentence);
        } else {
          # ifndef BUILD_NO_DEBUG
          addLog(LOG_LEVEL_DEBUG, P082_data->_lastSentence);
          # endif
        }
# endif
        Scheduler.schedule_task_device_timer(event->TaskIndex, millis());
        delay(0);

      }
      success = true;
      break;
    }

    case PLUGIN_READ: {
      P082_data_struct *P082_data =
        static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P082_data) && P082_data->isInitialized()) {
        static bool activeFix = P082_data->hasFix(P082_TIMEOUT);
        const bool curFixStatus = P082_data->hasFix(P082_TIMEOUT);

        if (activeFix != curFixStatus) {

          if (Settings.UseRules) {
            eventQueue.add(curFixStatus ? F("GPS#GotFix") : F("GPS#LostFix"));
          }
          activeFix = curFixStatus;
        }
        ESPEASY_RULES_FLOAT_TYPE distance{};

        if (curFixStatus) {
          if (P082_data->gps->location.isUpdated()) {
            const float lng = P082_data->gps->location.lng();
            const float lat = P082_data->gps->location.lat();
            P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_LONG), lng);
            P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_LAT), lat);

            P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_DISTANCE), P082_data->_distance);
            const float dist_ref = P082_data->gps->distanceBetween(P082_LAT_REF, P082_LONG_REF, lat, lng);
            P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_DIST_REF), dist_ref);


            if (P082_DISTANCE > 0) {
              distance = P082_data->distanceSinceLast(P082_TIMEOUT);
            }
            success = true;
            # ifndef BUILD_NO_DEBUG
            addLog(LOG_LEVEL_DEBUG, F("GPS: Position update."));
            # endif
          }

          if (P082_data->gps->altitude.isUpdated()) {

            P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_ALT), P082_data->gps->altitude.meters());
            success = true;
            # ifndef BUILD_NO_DEBUG
            addLog(LOG_LEVEL_DEBUG, F("GPS: Altitude update."));
            # endif
          }

          if (P082_data->gps->speed.isUpdated()) {

            P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_SPD), P082_data->gps->speed.mps());
            # ifndef BUILD_NO_DEBUG
            addLog(LOG_LEVEL_DEBUG, F("GPS: Speed update."));
            # endif
            success = true;
          }
        }
        P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_SATVIS), P082_data->gps->satellitesStats.nrSatsVisible());
        P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_SATUSE), P082_data->gps->satellitesStats.nrSatsTracked());
        P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_HDOP), P082_data->gps->hdop.value() / 100.0f);
        P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_FIXQ), P082_data->gps->location.Quality());
        P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_DB_MAX), P082_data->gps->satellitesStats.getBestSNR());
        P082_setOutputValue(event, static_cast<uint8_t>(P082_query::P082_QUERY_CHKSUM_FAIL), P082_data->gps->failedChecksum());

        P082_logStats(event);

        if (success) {
          bool distance_passed = false;
          bool interval_passed = false;

          if (P082_DISTANCE > 0) {

            if ((distance > static_cast<ESPEASY_RULES_FLOAT_TYPE>(P082_DISTANCE)) || (distance < 0)) {
              if (P082_data->storeCurPos(P082_TIMEOUT)) {
                distance_passed = true;


                if (distance > static_cast<ESPEASY_RULES_FLOAT_TYPE>(P082_DISTANCE)) {
                  if (Settings.UseRules) {
                    eventQueue.addMove(strformat(F("GPS#travelled=%f"), distance));
                  }

                  if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                    addLogMove(LOG_LEVEL_INFO, strformat(F("GPS: Distance trigger : %f m"), distance));
                  }
                }
              }
            }
          }

          if (P082_data->_last_measurement == 0) {
            interval_passed = true;
          } else if (timeOutReached(P082_data->_last_measurement + (Settings.TaskDeviceTimer[event->TaskIndex] * 1000))) {
            interval_passed = true;
          }
          success = (distance_passed || interval_passed);

          if (success) {
            P082_data->_last_measurement = millis();
          }
        }
      }
      break;
    }
    case PLUGIN_WRITE:
    {
      P082_data_struct *P082_data =
        static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P082_data) && P082_data->isInitialized()) {
        const String command = parseString(string, 1);
        const String subcommand = parseString(string, 2);

        if (equals(command, F("gps"))) {
          if (equals(subcommand, F("wake"))) {
            success = P082_data->wakeUp();
          } else if (equals(subcommand, F("sleep"))) {
            success = P082_data->powerDown();
          }
# ifdef P082_USE_U_BLOX_SPECIFIC
          else if (equals(subcommand, F("maxperf"))) {
            success = P082_data->setPowerMode(P082_PowerMode::Max_Performance);
          } else if (equals(subcommand, F("powersave"))) {
            success = P082_data->setPowerMode(P082_PowerMode::Power_Save);
          } else if (equals(subcommand, F("eco"))) {
            success = P082_data->setPowerMode(P082_PowerMode::Eco);
          }
# endif
        }
      }

      break;
    }
# if FEATURE_PACKED_RAW_DATA
    case PLUGIN_GET_PACKED_RAW_DATA:
    {
      P082_data_struct *P082_data =
        static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P082_data) && P082_data->isInitialized()) {





        string += LoRa_addFloat(P082_data->_cache[static_cast<uint8_t>(P082_query::P082_QUERY_LAT)], PackedData_latLng);
        string += LoRa_addFloat(P082_data->_cache[static_cast<uint8_t>(P082_query::P082_QUERY_LONG)], PackedData_latLng);
        string += LoRa_addFloat(P082_data->_cache[static_cast<uint8_t>(P082_query::P082_QUERY_ALT)], PackedData_altitude);
        string += LoRa_addFloat(P082_data->_cache[static_cast<uint8_t>(P082_query::P082_QUERY_SPD)], PackedData_uint16_1e2);
        string += LoRa_addFloat(P082_data->_cache[static_cast<uint8_t>(P082_query::P082_QUERY_HDOP)], PackedData_hdop);
        string += LoRa_addFloat(P082_data->_cache[static_cast<uint8_t>(P082_query::P082_QUERY_DB_MAX)], PackedData_uint8);
        string += LoRa_addFloat(P082_data->_cache[static_cast<uint8_t>(P082_query::P082_QUERY_SATUSE)], PackedData_uint8);
        string += LoRa_addFloat(P082_data->_cache[static_cast<uint8_t>(P082_query::P082_QUERY_DISTANCE)] / 1000, PackedData_uint24_1e2);



        event->Par1 = 8;

        if (P082_referencePointSet(event)) {
          string += LoRa_addFloat(P082_data->_cache[static_cast<uint8_t>(P082_query::P082_QUERY_DIST_REF)], PackedData_uint24_1e1);


          event->Par1 = 9;
        }

        success = true;
      }
      break;
    }
# endif
  }
  return success;
}

bool P082_referencePointSet(struct EventStruct *event) {
  return !((P082_LONG_REF < 0.1f) && (P082_LONG_REF > -0.1f)
           && (P082_LAT_REF < 0.1f) && (P082_LAT_REF > -0.1f));
}

void P082_setOutputValue(struct EventStruct *event, uint8_t outputType, float value) {
  P082_data_struct *P082_data =
    static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P082_data) || !P082_data->isInitialized()) {
    return;
  }

  if (outputType < static_cast<uint8_t>(P082_query::P082_NR_OUTPUT_OPTIONS)) {
    P082_data->_cache[outputType] = value;
  }

  for (uint8_t i = 0; i < P082_NR_OUTPUT_VALUES; ++i) {
    const uint8_t pconfigIndex = i + P082_QUERY1_CONFIG_POS;

    if (PCONFIG(pconfigIndex) == outputType) {
      UserVar.setFloat(event->TaskIndex, i, value);
    }
  }
}

void P082_logStats(struct EventStruct *event) {
  # ifndef BUILD_NO_DEBUG

  if (!loglevelActiveFor(LOG_LEVEL_DEBUG)) { return; }
  P082_data_struct *P082_data =
    static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P082_data) || !P082_data->isInitialized()) {
    return;
  }
  String log;

  if (log.reserve(128)) {
    log = F("GPS:");
    log += F(" Fix: ");
    log += P082_data->hasFix(P082_TIMEOUT) ? 1 : 0;
    log += F(" #sat: ");
    log += P082_data->gps->satellites.value();
    log += F(" #SNR: ");
    log += P082_data->gps->satellitesStats.getBestSNR();
    log += F(" HDOP: ");
    log += P082_data->gps->hdop.value() / 100.0f;
    log += F(" Chksum(pass/fail): ");
    log += P082_data->gps->passedChecksum();
    log += '/';
    log += P082_data->gps->failedChecksum();
    log += F(" invalid: ");
    log += P082_data->gps->invalidData();
    addLogMove(LOG_LEVEL_DEBUG, log);
  }
  # endif
}

void P082_html_show_satStats(struct EventStruct *event, bool tracked, bool onlyGPS) {
  P082_data_struct *P082_data =
    static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P082_data) || !P082_data->isInitialized()) {
    return;
  }

  bool first = true;

  for (uint8_t i = 0; i < _GPS_MAX_ARRAY_LENGTH; ++i) {
    uint8_t id = P082_data->gps->satellitesStats.id[i];
    uint8_t snr = P082_data->gps->satellitesStats.snr[i];

    if (id > 0) {
      if (((id <= 32) == onlyGPS) && ((snr > 0) == tracked)) {
        if (first) {
          first = false;
          String label;
          label.reserve(32);

          if (onlyGPS) {
            label = F("GPS");
          } else {
            label = F("Other");
          }
          label += F(" sat. ");

          if (tracked) {
            label += F("tracked - id(SNR)");
          } else {
            label += F("in view - id");
          }
          addRowLabel(label);
        } else {
          addHtml(',', ' ');
        }
        addHtmlInt(id);

        if (tracked) {
          addHtml(' ', '(');
          addHtmlInt(snr);
          addHtml(')');
        }
      }
    }
  }

  if (!first) {

    if (tracked) {
      html_I(F(" - SNR in dBHz"));
    }
  }
}

void P082_html_show_stats(struct EventStruct *event) {
  P082_data_struct *P082_data =
    static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P082_data) || !P082_data->isInitialized()) {
    return;
  }
  addRowLabel(F("Fix"));
  addEnabled(P082_data->hasFix(P082_TIMEOUT));

  addRowLabel(F("Fix Quality"));

  switch (P082_data->gps->location.Quality()) {
    case 0: addHtml(F("Invalid")); break;
    case 1: addHtml(F("GPS")); break;
    case 2: addHtml(F("DGPS")); break;
    case 3: addHtml(F("PPS")); break;
    case 4: addHtml(F("RTK")); break;
    case 5: addHtml(F("FloatRTK")); break;
    case 6: addHtml(F("Estimated")); break;
    case 7: addHtml(F("Manual")); break;
    case 8: addHtml(F("Simulated")); break;
    default:
      addHtml(F("Unknown"));
      break;
  }

  addRowLabel(F("Satellites tracked"));
  addHtmlInt(P082_data->gps->satellitesStats.nrSatsTracked());

  addRowLabel(F("Satellites visible"));
  addHtmlInt(P082_data->gps->satellitesStats.nrSatsVisible());

  addRowLabel(F("Best SNR"));
  addHtmlInt(P082_data->gps->satellitesStats.getBestSNR());
  addHtml(F(" dBHz"));


  P082_html_show_satStats(event, true, true);
  P082_html_show_satStats(event, false, true);
  P082_html_show_satStats(event, true, false);
  P082_html_show_satStats(event, false, false);

  addRowLabel(F("HDOP"));
  addHtmlFloat(P082_data->gps->hdop.value() / 100.0f);

  addRowLabel(F("UTC Time"));
  struct tm dateTime;
  uint32_t age;
  bool updated;
  bool pps_sync;

  if (P082_data->getDateTime(dateTime, age, updated, pps_sync)) {
    dateTime = node_time.addSeconds(dateTime, (age / 1000), false);
    addHtml(formatDateTimeString(dateTime));
  } else {
    addHtml('-');
  }

  addRowLabel(F("Distance Travelled"));
  addHtmlInt(static_cast<int>(P082_data->_cache[static_cast<uint8_t>(P082_query::P082_QUERY_DISTANCE)]));
  addUnit('m');

  if (P082_referencePointSet(event)) {
    addRowLabel(F("Distance from Ref. Point"));
    addHtmlInt(static_cast<int>(P082_data->_cache[static_cast<uint8_t>(P082_query::P082_QUERY_DIST_REF)]));
    addUnit('m');
  }

  addRowLabel(F("Checksum (pass/fail/invalid)"));
  {
    String chksumStats;

    chksumStats = P082_data->gps->passedChecksum();
    chksumStats += '/';
    chksumStats += P082_data->gps->failedChecksum();
    chksumStats += '/';
    chksumStats += P082_data->gps->invalidData();
    addHtml(chksumStats);
  }
}

void P082_setSystemTime(struct EventStruct *event) {
  P082_data_struct *P082_data =
    static_cast<P082_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P082_data) || !P082_data->isInitialized()) {
    return;
  }

  if ((timeSource_t::GPS_time_source == node_time.timeSource) &&
      (P082_data->_last_setSystemTime != 0) &&
      (timePassedSince(P082_data->_last_setSystemTime) < EXT_TIME_SOURCE_MIN_UPDATE_INTERVAL_MSEC))
  {

    return;
  }

  struct tm dateTime;
  uint32_t age;
  bool updated;
  bool pps_sync;

  P082_data->_pps_time = P082_pps_time;

  if (P082_data->getDateTime(dateTime, age, updated, pps_sync)) {
    if (updated) {


      ESPEASY_RULES_FLOAT_TYPE time = makeTime(dateTime);
      time += (static_cast<ESPEASY_RULES_FLOAT_TYPE>(age) / static_cast<ESPEASY_RULES_FLOAT_TYPE>(1000));
      node_time.setExternalTimeSource(time, timeSource_t::GPS_time_source);
      P082_data->_last_setSystemTime = millis();
    }
  }
  P082_pps_time = 0;
}

void Plugin_082_interrupt() {
  P082_pps_time = millis();
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P083_SGP30.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P083
# 12 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P083_SGP30.ino"
#include "src/PluginStructs/P083_data_struct.h"

#define PLUGIN_083 
#define PLUGIN_ID_083 83
#define PLUGIN_NAME_083 "Gases - SGP30 TVOC/eCO2"
#define PLUGIN_VALUENAME1_083 "TVOC"
#define PLUGIN_VALUENAME2_083 "eCO2"


#define P083_TVOC event->TaskIndex, 0
#define P083_ECO2 event->TaskIndex, 1
#define P083_TVOC_BASELINE event->TaskIndex, 2
#define P083_ECO2_BASELINE event->TaskIndex, 3


boolean Plugin_083(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_083;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_083);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_083));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_083));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x58);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x58;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Sensor"));
      addRowLabel(F("Sensor State"));
      P083_data_struct *P083_data =
        static_cast<P083_data_struct *>(getPluginTaskData(event->TaskIndex));

      bool isInitialized = false;

      if (nullptr != P083_data) {
        isInitialized = P083_data->initialized;
      }
      addHtml(isInitialized ? F("Initialized") : F("-"));
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P083_data_struct());
      P083_data_struct *P083_data =
        static_cast<P083_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P083_data) {
        if (!P083_data->initialized) {
          addLog(LOG_LEVEL_ERROR, F("SGP30: Sensor not found"));
        } else {

          uint16_t eco2_base = UserVar.getFloat(P083_TVOC_BASELINE);
          uint16_t tvoc_base = UserVar.getFloat(P083_ECO2_BASELINE);

          if ((eco2_base != 0) && (tvoc_base != 0)) {
            addLog(LOG_LEVEL_INFO, F("SGP30: Restore last known baseline values"));
            P083_data->sgp.setIAQBaseline(eco2_base, tvoc_base);
          }
          success = true;
        }
      }
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P083_data_struct *P083_data =
        static_cast<P083_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P083_data) {
        if (P083_data->initialized)
        {
          if (P083_data->sgp.IAQmeasure())
          {
            UserVar.setFloat(P083_TVOC, P083_data->sgp.TVOC);
            UserVar.setFloat(P083_ECO2, P083_data->sgp.eCO2);
            success = true;




            if ((timePassedSince(P083_data->init_time) > 15000) || ((P083_data->sgp.TVOC != 0) && (P083_data->sgp.eCO2 != 400))) {
              P083_data->newValues = true;
            }
          }
        }
      }
      break;
    }

    case PLUGIN_READ:
    {
      P083_data_struct *P083_data =
        static_cast<P083_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P083_data) {
        if (P083_data->initialized)
        {
          if (P083_data->newValues)
          {
            P083_data->newValues = false;



            uint16_t eco2_base, tvoc_base;

            if (P083_data->sgp.getIAQBaseline(&eco2_base, &tvoc_base)) {
              UserVar.setFloat(P083_TVOC_BASELINE, eco2_base);
              UserVar.setFloat(P083_ECO2_BASELINE, tvoc_base);
            }


            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("SGP30: TVOC: ");
              log += UserVar.getFloat(P083_TVOC);
              addLogMove(LOG_LEVEL_INFO, log);
              log = F("SGP30: eCO2: ");
              log += UserVar.getFloat(P083_ECO2);
              addLogMove(LOG_LEVEL_INFO, log);
            }
            success = true;
            break;
          } else {
            addLog(LOG_LEVEL_ERROR, F("SGP30: No new measured values"));
            break;
          }
        } else {
          addLog(LOG_LEVEL_ERROR, F("SGP30: Sensor not found"));
          break;
        }
      }
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P084_VEML6070.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P084
# 14 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P084_VEML6070.ino"
#define PLUGIN_084 
#define PLUGIN_ID_084 84
#define PLUGIN_NAME_084 "UV - VEML6070"
#define PLUGIN_VALUENAME1_084 "Raw"
#define PLUGIN_VALUENAME2_084 "Risk"
#define PLUGIN_VALUENAME3_084 "Power"

#define VEML6070_ADDR_H 0x39
#define VEML6070_ADDR_L 0x38
#define VEML6070_RSET_DEFAULT 270000
#define VEML6070_UV_MAX_INDEX 15
#define VEML6070_UV_MAX_DEFAULT 11
#define VEML6070_POWER_COEFFCIENT 0.025f
#define VEML6070_TABLE_COEFFCIENT 32.86270591f




#define VEML6070_base_value ((VEML6070_RSET_DEFAULT / VEML6070_TABLE_COEFFCIENT) / VEML6070_UV_MAX_DEFAULT) * (1)
#define VEML6070_max_value ((VEML6070_RSET_DEFAULT / VEML6070_TABLE_COEFFCIENT) / VEML6070_UV_MAX_DEFAULT) * (VEML6070_UV_MAX_INDEX)

boolean Plugin_084(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_084;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = false;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_084);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_084));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_084));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_084));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x38);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x38;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      const __FlashStringHelper * optionsMode[4] = { F("1/2T"), F("1T"), F("2T"), F("4T (Default)") };
      addFormSelector(F("Refresh Time Determination"), F("itime"), 4, optionsMode, nullptr, PCONFIG(0));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("itime"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = VEML6070_Init(PCONFIG(0));

      if (!success) {
        addLog(LOG_LEVEL_INFO, F("VEML6070: Not available!"));
      }

      break;
    }

    case PLUGIN_READ:
    {
      uint16_t uv_raw;
      ESPEASY_RULES_FLOAT_TYPE uv_risk, uv_power;
      bool read_status;

      uv_raw = VEML6070_ReadUv(&read_status);
      uv_risk = VEML6070_UvRiskLevel(uv_raw);
      uv_power = VEML6070_UvPower(uv_risk);

      if (isnan(uv_raw) || (uv_raw == 65535) || !read_status) {
        addLog(LOG_LEVEL_INFO, F("VEML6070: no data read!"));
        UserVar.setFloat(event->TaskIndex, 0, NAN);
        UserVar.setFloat(event->TaskIndex, 1, NAN);
        UserVar.setFloat(event->TaskIndex, 2, NAN);
        success = false;
      } else {
        UserVar.setFloat(event->TaskIndex, 0, uv_raw);
        UserVar.setFloat(event->TaskIndex, 1, uv_risk);
        UserVar.setFloat(event->TaskIndex, 2, uv_power);

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("VEML6070: UV: ");
          log += formatUserVarNoCheck(event->TaskIndex, 0);
          addLogMove(LOG_LEVEL_INFO, log);
        }

        success = true;
      }

      break;
    }
  }
  return success;
}






uint16_t VEML6070_ReadUv(bool *status)
{
  uint16_t uv_raw = 0;
  bool wire_status = false;

  uv_raw = I2C_read8(VEML6070_ADDR_H, &wire_status);
  *status = wire_status;
  uv_raw <<= 8;
  uv_raw |= I2C_read8(VEML6070_ADDR_L, &wire_status);
  *status &= wire_status;

  return uv_raw;
}

bool VEML6070_Init(uint8_t it)
{
  boolean succes = I2C_write8(VEML6070_ADDR_L, ((it << 2) | 0x02));

  return succes;
}
# 186 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P084_VEML6070.ino"
ESPEASY_RULES_FLOAT_TYPE VEML6070_UvRiskLevel(uint16_t uv_level)
{
  ESPEASY_RULES_FLOAT_TYPE risk{};

  constexpr ESPEASY_RULES_FLOAT_TYPE max_value = VEML6070_max_value;

  if (uv_level < max_value) {
    constexpr ESPEASY_RULES_FLOAT_TYPE factor = VEML6070_base_value;
    return (ESPEASY_RULES_FLOAT_TYPE)uv_level / factor;
  } else {

    if (loglevelActiveFor(LOG_LEVEL_INFO)) {
      String log = F("VEML6070 out of range: ");
      log += risk;
      addLogMove(LOG_LEVEL_INFO, log);
    }

    return 99;
  }
}

ESPEASY_RULES_FLOAT_TYPE VEML6070_UvPower(ESPEASY_RULES_FLOAT_TYPE uvrisk)
{

  return VEML6070_POWER_COEFFCIENT * uvrisk;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P085_AcuDC243.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P085





# include "src/PluginStructs/P085_data_struct.h"
# 19 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P085_AcuDC243.ino"
#define PLUGIN_085 
#define PLUGIN_ID_085 85
#define PLUGIN_NAME_085 "Energy - AccuEnergy AcuDC24x"
#define PLUGIN_VALUENAME1_085 ""


boolean Plugin_085(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_085;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL_PLUS1;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = P085_NR_OUTPUT_VALUES;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].ExitTaskBeforeSave = false;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_085);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < P085_NR_OUTPUT_VALUES) {
          const uint8_t pconfigIndex = i + P085_QUERY1_CONFIG_POS;
          uint8_t choice = PCONFIG(pconfigIndex);
          ExtraTaskSettings.setTaskDeviceValueName(i, Plugin_085_valuename(choice, false));
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES: {
      serialHelper_getGpioNames(event);
      event->String3 = formatGpioName_output_optional(F("DE"));
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS: {
      P085_DEV_ID = P085_DEV_ID_DFLT;
      P085_MODEL = P085_MODEL_DFLT;
      P085_BAUDRATE = P085_BAUDRATE_DFLT;
      P085_QUERY1 = P085_QUERY1_DFLT;
      P085_QUERY2 = P085_QUERY2_DFLT;
      P085_QUERY3 = P085_QUERY3_DFLT;
      P085_QUERY4 = P085_QUERY4_DFLT;

      success = true;
      break;
    }

    case PLUGIN_WRITE: {
      break;
    }

    case PLUGIN_WEBFORM_SHOW_SERIAL_PARAMS:
    {
      String options_baudrate[6];

      for (int i = 0; i < 6; ++i) {
        options_baudrate[i] = String(p085_storageValueToBaudrate(i));
      }
      addFormSelector(F("Baud Rate"), P085_BAUDRATE_LABEL, 6, options_baudrate, nullptr, P085_BAUDRATE);
      addUnit(F("baud"));
      addFormNumericBox(F("Modbus Address"), P085_DEV_ID_LABEL, P085_DEV_ID, 1, 247);
      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      const __FlashStringHelper *options[P085_NR_OUTPUT_OPTIONS];

      for (int i = 0; i < P085_NR_OUTPUT_OPTIONS; ++i) {
        options[i] = Plugin_085_valuename(i, true);
      }

      for (uint8_t i = 0; i < P085_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P085_QUERY1_CONFIG_POS;
        sensorTypeHelper_loadOutputSelector(event, pconfigIndex, i, P085_NR_OUTPUT_OPTIONS, options);
      }
      success = true;

      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
      P085_data_struct *P085_data =
        static_cast<P085_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P085_data) && P085_data->isInitialized()) {
        addFormNote(P085_data->modbus.detected_device_description);
        addRowLabel(F("Checksum (pass/fail/nodata)"));
        uint32_t reads_pass, reads_crc_failed, reads_nodata;
        P085_data->modbus.getStatistics(reads_pass, reads_crc_failed, reads_nodata);
        String chksumStats;
        chksumStats = reads_pass;
        chksumStats += '/';
        chksumStats += reads_crc_failed;
        chksumStats += '/';
        chksumStats += reads_nodata;
        addHtml(chksumStats);

        addFormSubHeader(F("Calibration"));


        {
          uint8_t errorcode = 0;
          int value = P085_data->modbus.readHoldingRegister(0x107, errorcode);

          if (errorcode == 0) {
            addFormNumericBox(F("Full Range Voltage Value"), F("fr_volt"), value, 5, 9999);
            addUnit('V');
          }
          value = P085_data->modbus.readHoldingRegister(0x104, errorcode);

          if (errorcode == 0) {
            addFormNumericBox(F("Full Range Current Value"), F("fr_curr"), value, 20, 50000);
            addUnit('A');
          }
          value = P085_data->modbus.readHoldingRegister(0x105, errorcode);

          if (errorcode == 0) {
            addFormNumericBox(F("Full Range Shunt Value"), F("fr_shunt"), value, 50, 100);
            addUnit(F("mV"));
          }

          addFormSubHeader(F("Logging"));

          value = P085_data->modbus.readHoldingRegister(0x500, errorcode);

          if (errorcode == 0) {
            addFormCheckBox(F("Enable data logging"), F("en_log"), value);
          }
          value = P085_data->modbus.readHoldingRegister(0x501, errorcode);

          if (errorcode == 0) {
            addRowLabel(F("Mode of data logging"));
            addHtmlInt(value);
          }
          value = P085_data->modbus.readHoldingRegister(0x502, errorcode);

          if (errorcode == 0) {
            addFormNumericBox(F("Log Interval"), F("log_int"), value, 1, 1440);
            addUnit(F("minutes"));
          }
        }

        addFormSubHeader(F("Logged Values"));
        p085_showValueLoadPage(P085_QUERY_Wh_imp, event);
        p085_showValueLoadPage(P085_QUERY_Wh_exp, event);
        p085_showValueLoadPage(P085_QUERY_Wh_tot, event);
        p085_showValueLoadPage(P085_QUERY_Wh_net, event);
        p085_showValueLoadPage(P085_QUERY_h_tot, event);
        p085_showValueLoadPage(P085_QUERY_h_load, event);



        addFormCheckBox(F("Clear logged values"), F("clear_log"), false);
        addFormNote(F("Will clear all logged values when checked and saved"));
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {

      for (int i = 0; i < P085_QUERY1_CONFIG_POS; ++i) {
        pconfig_webformSave(event, i);
      }


      for (uint8_t i = 0; i < P085_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P085_QUERY1_CONFIG_POS;
        const uint8_t choice = PCONFIG(pconfigIndex);
        sensorTypeHelper_saveOutputSelector(event, pconfigIndex, i, Plugin_085_valuename(choice, false));
      }
      P085_data_struct *P085_data =
        static_cast<P085_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P085_data) && P085_data->isInitialized()) {
        uint16_t log_enabled = isFormItemChecked(F("en_log")) ? 1 : 0;
        P085_data->modbus.writeMultipleRegisters(0x500, log_enabled);
        delay(1);

        uint16_t log_int = getFormItemInt(F("log_int"));
        P085_data->modbus.writeMultipleRegisters(0x502, log_int);
        delay(1);

        uint16_t current = getFormItemInt(F("fr_curr"));
        P085_data->modbus.writeMultipleRegisters(0x104, current);
        delay(1);

        uint16_t shunt = getFormItemInt(F("fr_shunt"));
        P085_data->modbus.writeMultipleRegisters(0x105, shunt);
        delay(1);

        uint16_t voltage = getFormItemInt(F("fr_volt"));
        P085_data->modbus.writeMultipleRegisters(0x107, voltage);

        if (isFormItemChecked(F("clear_log")))
        {

          P085_data->modbus.writeMultipleRegisters(0x122, 0x0A);
          P085_data->modbus.writeMultipleRegisters(0x123, 0x0A);
          P085_data->modbus.writeMultipleRegisters(0x124, 0x0A);
          P085_data->modbus.writeMultipleRegisters(0x127, 0x0A);
          P085_data->modbus.writeMultipleRegisters(0x128, 0x0A);
          P085_data->modbus.writeMultipleRegisters(0x129, 0x0A);
        }
      }


      success = true;
      break;
    }

    case PLUGIN_INIT: {
      const int16_t serial_rx = CONFIG_PIN1;
      const int16_t serial_tx = CONFIG_PIN2;
      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P085_data_struct());
      P085_data_struct *P085_data =
        static_cast<P085_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P085_data) {
        return success;
      }

      if (P085_data->init(port, serial_rx, serial_tx, P085_DEPIN,
                          p085_storageValueToBaudrate(P085_BAUDRATE),
                          P085_DEV_ID)) {
        serialHelper_log_GpioDescription(port, serial_rx, serial_tx);
        success = true;
      } else {
        clearPluginTaskData(event->TaskIndex);
      }
      break;
    }

    case PLUGIN_EXIT: {
      success = true;
      break;
    }

    case PLUGIN_READ: {
      P085_data_struct *P085_data =
        static_cast<P085_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P085_data) && P085_data->isInitialized()) {
        for (int i = 0; i < P085_NR_OUTPUT_VALUES; ++i) {
          UserVar.setFloat(event->TaskIndex, i, p085_readValue(PCONFIG(i + P085_QUERY1_CONFIG_POS), event));
          delay(1);
        }

        success = true;
      }
      break;
    }
# if FEATURE_PACKED_RAW_DATA
    case PLUGIN_GET_PACKED_RAW_DATA:
    {

      P085_data_struct *P085_data =
        static_cast<P085_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P085_data) && P085_data->isInitialized()) {



        for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
          const uint8_t pconfigIndex = i + P085_QUERY1_CONFIG_POS;
          const uint8_t choice = PCONFIG(pconfigIndex);
          string += LoRa_addInt(choice, PackedData_uint8);
          string += LoRa_addFloat(UserVar[event->BaseVarIndex + i], PackedData_int32_1e4);
        }
        event->Par1 = 8;

        success = true;
      }
      break;
    }
# endif
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P086_Homie.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P086





#define PLUGIN_086 
#define PLUGIN_ID_086 86
#define PLUGIN_NAME_086 "Generic - Homie receiver"


#define PLUGIN_VALUENAME1_086 ""
#define PLUGIN_VALUENAME2_086 ""
#define PLUGIN_VALUENAME3_086 ""
#define PLUGIN_VALUENAME4_086 ""

#define PLUGIN_086_VALUE_INTEGER 0
#define PLUGIN_086_VALUE_FLOAT 1
#define PLUGIN_086_VALUE_BOOLEAN 2
#define PLUGIN_086_VALUE_STRING 3
#define PLUGIN_086_VALUE_ENUM 4
#define PLUGIN_086_VALUE_RGB 5
#define PLUGIN_086_VALUE_HSV 6

#define PLUGIN_086_VALUE_TYPES 7
#define PLUGIN_086_VALUE_MAX 4

#define PLUGIN_086_DEBUG true

boolean Plugin_086(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {

    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_086;
        Device[deviceCount].Type = DEVICE_TYPE_DUMMY;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = false;
        Device[deviceCount].DecimalsOnly = true;
        Device[deviceCount].ValueCount = PLUGIN_086_VALUE_MAX;
        Device[deviceCount].SendDataOption = false;
        Device[deviceCount].TimerOption = false;
        Device[deviceCount].GlobalSyncOption = false;
        Device[deviceCount].Custom = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_086);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_086));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_086));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_086));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_086));

        break;
      }

    case PLUGIN_WEBFORM_LOAD:
      {
        addFormNote(F("Translation Plugin for controllers able to receive value updates according to the Homie convention."));

        uint8_t choice = 0;
        String labelText;
        String keyName;
        const __FlashStringHelper * options[PLUGIN_086_VALUE_TYPES] = {
          F("integer"),
          F("float"),
          F("boolean"),
          F("string"),
          F("enum"),
          F("rgb"),
          F("hsv")
        };
        const int optionValues[PLUGIN_086_VALUE_TYPES] = {
          PLUGIN_086_VALUE_INTEGER,
          PLUGIN_086_VALUE_FLOAT,
          PLUGIN_086_VALUE_BOOLEAN,
          PLUGIN_086_VALUE_STRING,
          PLUGIN_086_VALUE_ENUM,
          PLUGIN_086_VALUE_RGB,
         PLUGIN_086_VALUE_HSV
        };
        for (int i=0;i<PLUGIN_086_VALUE_MAX;i++) {
          labelText = F("Function #");
          labelText += (i+1);
          addFormSubHeader(labelText);
          choice = PCONFIG(i);
          if (i==0) addFormNote(F("Triggers an event when a ../%event%/set topic arrives"));
          labelText = F("Event Name");
          keyName = F("functionName");
          keyName += i;
          addFormTextBox(labelText, keyName, Cache.getTaskDeviceValueName(event->TaskIndex, i), NAME_FORMULA_LENGTH_MAX);
          labelText = F("Parameter Type");
          keyName = F("valueType");
          keyName += i;
          addFormSelector(labelText, keyName, PLUGIN_086_VALUE_TYPES, options, optionValues, choice );
          keyName += F("_min");
          addFormNumericBox(F("Min"),keyName,Cache.getTaskDevicePluginConfig(event->TaskIndex, i));
          keyName = F("valueType");
          keyName += i;
          keyName += F("_max");
          addFormNumericBox(F("Max"),keyName,Cache.getTaskDevicePluginConfig(event->TaskIndex, i+PLUGIN_086_VALUE_MAX));
          if (i==0) addFormNote(F("min max values only valid for numeric parameter"));
          keyName = F("decimals");
          keyName += i;
          addFormNumericBox(F("Decimals"),keyName,Cache.getTaskDeviceValueDecimals(event->TaskIndex, i) ,0,8);
          if (i==0) addFormNote(F("Decimal counts for float parameter"));
          keyName = F("string");
          keyName += i;
          addFormTextBox(F("String or enum"), keyName, Cache.getTaskDeviceFormula(event->TaskIndex, i), NAME_FORMULA_LENGTH_MAX);
          if (i==0) addFormNote(F("Default string or enumumeration list (comma seperated)."));
        }
        success = true;
        break;
      }

    case PLUGIN_WEBFORM_SAVE:
      {
        String keyName;
        for (int i=0;i<PLUGIN_086_VALUE_MAX;i++) {
          keyName = F("valueType");
          keyName += i;
          PCONFIG(i) = getFormItemInt(keyName);
          keyName = F("functionName");
          keyName += i;
          strncpy_webserver_arg(ExtraTaskSettings.TaskDeviceValueNames[i], keyName);
          keyName = F("valueType");
          keyName += i;
          keyName += F("_min");
          ExtraTaskSettings.TaskDevicePluginConfig[i]=getFormItemInt(keyName);
          keyName = F("valueType");
          keyName += i;
          keyName += F("_max");
          ExtraTaskSettings.TaskDevicePluginConfig[i+PLUGIN_086_VALUE_MAX]=getFormItemInt(keyName);
          keyName = F("decimals");
          keyName += i;
          ExtraTaskSettings.TaskDeviceValueDecimals[i]=getFormItemInt(keyName);
          keyName = F("string");
          keyName += i;
          strncpy_webserver_arg(ExtraTaskSettings.TaskDeviceFormula[i], keyName);
        }
        success = true;
        break;
      }

    case PLUGIN_INIT:
      {
        success = true;
        break;
      }

    case PLUGIN_READ:
      {
        for (uint8_t x=0; x<PLUGIN_086_VALUE_MAX;x++)
        {
          String log = F("P086 : Value ");
          log += x+1;
          log += F(": ");
          log += formatUserVarNoCheck(event->TaskIndex, x);
          addLogMove(LOG_LEVEL_INFO, log);
        }
        success = true;
        break;
      }

    case PLUGIN_WRITE:
      {
        String command = parseString(string, 1);
        if (equals(command, F("homievalueset")))
        {
          const taskVarIndex_t taskVarIndex = event->Par2 - 1;
          const userVarIndex_t userVarIndex = event->BaseVarIndex + taskVarIndex;
          if (validTaskIndex(event->TaskIndex) &&
              validTaskVarIndex(taskVarIndex) &&
              validUserVarIndex(userVarIndex) &&
              (event->Par1 == (event->TaskIndex + 1))) {
            String parameter = parseStringToEndKeepCase(string,4);
            String log;
# 228 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P086_Homie.ino"
            float floatValue = 0.0f;
            String enumList;
            int i = 0;
            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              log = F("P086 : deviceNr:");
              log += event->TaskIndex + 1;
              log += F(" valueNr:");
              log += event->Par2;
              log += F(" valueType:");
              log += Settings.TaskDevicePluginConfig[event->TaskIndex][taskVarIndex];
            }

            switch (Settings.TaskDevicePluginConfig[event->TaskIndex][taskVarIndex]) {
              case PLUGIN_086_VALUE_INTEGER:
              case PLUGIN_086_VALUE_FLOAT:
                if (!parameter.isEmpty()) {
                  if (string2float(parameter,floatValue)) {
                    if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                      log += F(" integer/float set to ");
                      log += floatValue;
                      addLogMove(LOG_LEVEL_INFO, log);
                    }
                    UserVar.setFloat(event->TaskIndex, taskVarIndex, floatValue);
                  } else {
                    if (loglevelActiveFor(LOG_LEVEL_ERROR)) {
                      log += F(" parameter:");
                      log += parameter;
                      log += F(" not a float value!");
                      addLogMove(LOG_LEVEL_ERROR, log);
                    }
                  }
                } else {
                  if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                    log += F(" value:");
                    log += UserVar[userVarIndex];
                    addLogMove(LOG_LEVEL_INFO, log);
                  }
                }
                break;

              case PLUGIN_086_VALUE_BOOLEAN:
                if (parameter=="false") {
                  floatValue = 0.0f;
                } else {
                  floatValue = 1.0f;
                }
                UserVar.setFloat(event->TaskIndex, taskVarIndex, floatValue);
                if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                  log += F(" boolean set to ");
                  log += floatValue;
                  addLogMove(LOG_LEVEL_INFO, log);
                }
                break;

              case PLUGIN_086_VALUE_STRING:


                if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                  log += F(" string set to ");
                  log += parameter;
                  addLogMove(LOG_LEVEL_INFO, log);
                }
                break;

              case PLUGIN_086_VALUE_ENUM:
                enumList = Cache.getTaskDeviceFormula(event->TaskIndex, taskVarIndex);
                i = 1;
                while (!parseString(enumList,i).isEmpty()) {
                  if (parseString(enumList,i)==parameter) {
                    floatValue = i;
                    break;
                  }
                  i++;
                }
                UserVar.setFloat(event->TaskIndex, taskVarIndex, floatValue);
                if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                  log += F(" enum set to ");
                  log += floatValue;
                  log += ' ';
                  log += wrap_braces(parameter);
                  addLogMove(LOG_LEVEL_INFO, log);
                }
                break;

              case PLUGIN_086_VALUE_RGB:


                if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                  log += F(" RGB received ");
                  log += parameter;
                  addLogMove(LOG_LEVEL_INFO, log);
                }
                break;

              case PLUGIN_086_VALUE_HSV:


                if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                  log += F(" HSV received ");
                  log += parameter;
                  addLogMove(LOG_LEVEL_INFO, log);
                }
                break;
            }
            success = true;
          }
        }
      }
      break;
    }
  return success;
}
#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P087_SerialProxy.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P087
# 25 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P087_SerialProxy.ino"
# include "src/PluginStructs/P087_data_struct.h"

# include <Regexp.h>

#define PLUGIN_087 
#define PLUGIN_ID_087 87
#define PLUGIN_NAME_087 "Communication - Serial Proxy"


#define P087_BAUDRATE PCONFIG_LONG(0)
#define P087_BAUDRATE_LABEL PCONFIG_LABEL(0)
#define P087_SERIAL_CONFIG PCONFIG_LONG(1)

#define P087_QUERY_VALUE 0
#define P087_NR_OUTPUT_OPTIONS 1

#define P087_NR_OUTPUT_VALUES 1
#define P087_QUERY1_CONFIG_POS 3

#define P087_DEFAULT_BAUDRATE 38400
# 65 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P087_SerialProxy.ino"
boolean Plugin_087(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_087;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_STRING;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = false;


      Device[deviceCount].ExitTaskBeforeSave = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_087);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < P087_NR_OUTPUT_VALUES) {
          const uint8_t pconfigIndex = i + P087_QUERY1_CONFIG_POS;
          uint8_t choice = PCONFIG(pconfigIndex);
          ExtraTaskSettings.setTaskDeviceValueName(i, Plugin_087_valuename(choice, false));
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES: {
      serialHelper_getGpioNames(event, false, true);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_VALUES:
    {
      P087_data_struct *P087_data =
        static_cast<P087_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P087_data) && P087_data->isInitialized()) {
        uint32_t success, error, length_last;
        P087_data->getSentencesReceived(success, error, length_last);
        uint8_t varNr = VARS_PER_TASK;
        pluginWebformShowValue(event->TaskIndex, varNr++, F("Success"), String(success));
        pluginWebformShowValue(event->TaskIndex, varNr++, F("Error"), String(error));
        pluginWebformShowValue(event->TaskIndex, varNr++, F("Length Last"), String(length_last), true);


      }
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P087_BAUDRATE = P087_DEFAULT_BAUDRATE;

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_SERIAL_PARAMS:
    {
      addFormNumericBox(F("Baudrate"), P087_BAUDRATE_LABEL, P087_BAUDRATE, 300, 115200);
      addUnit(F("baud"));
      uint8_t serialConfChoice = serialHelper_convertOldSerialConfig(P087_SERIAL_CONFIG);
      serialHelper_serialconfig_webformLoad(event, serialConfChoice);
      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
      addFormSubHeader(F("Filtering"));
      P087_html_show_matchForms(event);

      addFormSubHeader(F("Statistics"));
      P087_html_show_stats(event);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      P087_BAUDRATE = getFormItemInt(P087_BAUDRATE_LABEL);
      P087_SERIAL_CONFIG = serialHelper_serialconfig_webformSave();

      P087_data_struct *P087_data =
        static_cast<P087_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P087_data) {
        for (uint8_t varNr = 0; varNr < P87_Nlines; varNr++)
        {
          P087_data->setLine(varNr, webArg(getPluginCustomArgName(varNr)));
        }

        addHtmlError(SaveCustomTaskSettings(event->TaskIndex, P087_data->_lines, P87_Nlines, 0));
        success = true;
      }

      break;
    }

    case PLUGIN_INIT: {
      const int16_t serial_rx = CONFIG_PIN1;
      const int16_t serial_tx = CONFIG_PIN2;
      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P087_data_struct());
      P087_data_struct *P087_data =
        static_cast<P087_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P087_data) {
        return success;
      }

      if (P087_data->init(port, serial_rx, serial_tx, P087_BAUDRATE, static_cast<uint8_t>(P087_SERIAL_CONFIG))) {
        LoadCustomTaskSettings(event->TaskIndex, P087_data->_lines, P87_Nlines, 0);
        P087_data->post_init();
        success = true;
        serialHelper_log_GpioDescription(port, serial_rx, serial_tx);
      } else {
        clearPluginTaskData(event->TaskIndex);
      }
      break;
    }

    case PLUGIN_FIFTY_PER_SECOND: {
      if (Settings.TaskDeviceEnabled[event->TaskIndex]) {
        P087_data_struct *P087_data =
          static_cast<P087_data_struct *>(getPluginTaskData(event->TaskIndex));

        if ((nullptr != P087_data) && P087_data->loop()) {
          Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 10);
          delay(0);

        }
        success = true;
      }
      break;
    }

    case PLUGIN_READ: {
      P087_data_struct *P087_data =
        static_cast<P087_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P087_data) && P087_data->getSentence(event->String2)) {
        if (Plugin_087_match_all(event->TaskIndex, event->String2)) {

# ifndef BUILD_NO_DEBUG
          addLog(LOG_LEVEL_DEBUG, event->String2);
# endif
          success = true;
        }
      }

      if ((nullptr != P087_data)) {}
      break;
    }

    case PLUGIN_WRITE: {
      P087_data_struct *P087_data =
        static_cast<P087_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P087_data)) {
        String cmd = parseString(string, 1);

        if (equals(cmd, F("serialproxy_write"))) {
          String param1 = parseStringKeepCase(string, 2, ',', false);
          parseSystemVariables(param1, false);
          P087_data->sendString(param1);
          addLogMove(LOG_LEVEL_INFO, param1);
          success = true;
        } else
        if (equals(cmd, F("serialproxy_writemix"))) {
          std::vector<uint8_t> param1 = parseHexTextData(string);
          if (param1.size())
            P087_data->sendData(&param1[0], param1.size());
          success = true;
        }
      }

      break;
    }
  }
  return success;
}

bool Plugin_087_match_all(taskIndex_t taskIndex, String& received)
{
  P087_data_struct *P087_data =
    static_cast<P087_data_struct *>(getPluginTaskData(taskIndex));

  if ((nullptr == P087_data)) {
    return false;
  }


  if (P087_data->disableFilterWindowActive()) {
    addLog(LOG_LEVEL_INFO, F("Serial Proxy: Disable Filter Window active"));
    return true;
  }

  bool res = P087_data->matchRegexp(received);

  if (P087_data->invertMatch()) {
    addLog(LOG_LEVEL_INFO, F("Serial Proxy: invert filter"));
    return !res;
  }
  return res;
}

String Plugin_087_valuename(uint8_t value_nr, bool displayString) {
  switch (value_nr) {
    case P087_QUERY_VALUE: return displayString ? F("Value") : F("v");
  }
  return "";
}

void P087_html_show_matchForms(struct EventStruct *event) {
  P087_data_struct *P087_data =
    static_cast<P087_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr != P087_data)) {
    addFormTextBox(F("RegEx"), getPluginCustomArgName(P087_REGEX_POS), P087_data->getRegEx(), P87_Nchars);
    addFormNote(F("Captures are specified using round brackets."));

    addFormNumericBox(F("Nr Chars use in regex"), getPluginCustomArgName(P087_NR_CHAR_USE_POS), P087_data->getRegExpMatchLength(), 0, 1024);
    addFormNote(F("0 = Use all of the received string."));

    addFormNumericBox(F("Filter Off Window after send"),
                      getPluginCustomArgName(P087_FILTER_OFF_WINDOW_POS),
                      P087_data->getFilterOffWindowTime(),
                      0,
                      60000);
    addUnit(F("msec"));
    addFormNote(F("0 = Do not turn off filter after sending to the connected device."));

    {
      const __FlashStringHelper *options[P087_Match_Type_NR_ELEMENTS];
      int optionValues[P087_Match_Type_NR_ELEMENTS];

      for (int i = 0; i < P087_Match_Type_NR_ELEMENTS; ++i) {
        P087_Match_Type matchType = static_cast<P087_Match_Type>(i);
        options[i] = P087_data_struct::MatchType_toString(matchType);
        optionValues[i] = matchType;
      }
      P087_Match_Type choice = P087_data->getMatchType();
      addFormSelector(F("Match Type"),
                      getPluginCustomArgName(P087_MATCH_TYPE_POS),
                      P087_Match_Type_NR_ELEMENTS,
                      options,
                      optionValues,
                      choice,
                      false);
      addFormNote(F("Capture filter can only be used on Global Match"));
    }


    uint8_t lineNr = 0;
    uint8_t capture = 0;
    P087_Filter_Comp comparator = P087_Filter_Comp::Equal;
    String filter;

    for (uint8_t varNr = P087_FIRST_FILTER_POS; varNr < P87_Nlines; ++varNr)
    {
      String id = getPluginCustomArgName(varNr);

      switch (varNr % 3) {
        case 0:
        {

          filter = P087_data->getFilter(lineNr, capture, comparator);
          ++lineNr;
          String label;
          label = F("Capture Filter ");
          label += String(lineNr);
          addRowLabel_tr_id(label, id);

          addNumericBox(id, capture, -1, P87_MAX_CAPTURE_INDEX);
          break;
        }
        case 1:
        {

          const __FlashStringHelper *options[2];
          options[P087_Filter_Comp::Equal] = F("==");
          options[P087_Filter_Comp::NotEqual] = F("!=");
          int optionValues[2] = { P087_Filter_Comp::Equal, P087_Filter_Comp::NotEqual };
          addSelector(id, 2, options, optionValues, nullptr, static_cast<int>(comparator), false, true, F(""));
          break;
        }
        case 2:
        {

          addTextBox(id, filter, 32, false, false, EMPTY_STRING, F(""));
          break;
        }
      }
    }
  }
}

void P087_html_show_stats(struct EventStruct *event) {
  P087_data_struct *P087_data =
    static_cast<P087_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P087_data) || !P087_data->isInitialized()) {
    return;
  }
  {
    addRowLabel(F("Current Sentence"));
    String sentencePart;
    P087_data->getSentence(sentencePart);
    addHtml(sentencePart);
  }

  {
    addRowLabel(F("Sentences (pass/fail)"));
    String chksumStats;
    uint32_t success, error, length_last;
    P087_data->getSentencesReceived(success, error, length_last);
    chksumStats = success;
    chksumStats += '/';
    chksumStats += error;
    addHtml(chksumStats);
    addRowLabel(F("Length Last Sentence"));
    addHtmlInt(length_last);
  }
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P088_HeatpumpIR.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P088




#define PLUGIN_088 
#define PLUGIN_ID_088 88
#define PLUGIN_NAME_088 "Energy (Heat) - Heatpump IR transmitter"
# 47 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P088_HeatpumpIR.ino"
#include <HeatpumpIRFactory.h>

#include "ESPEasy-Globals.h"

IRSenderIRremoteESP8266 *Plugin_088_irSender = nullptr;
int panasonicCKPTimer = 0;

boolean Plugin_088(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_088;
        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = false;
        Device[deviceCount].ValueCount = 0;
        Device[deviceCount].SendDataOption = false;
        Device[deviceCount].TimerOption = false;
        Device[deviceCount].TimerOptional = false;
        Device[deviceCount].GlobalSyncOption = false;
        Device[deviceCount].DecimalsOnly = false;

        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_088);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        break;
      }

    case PLUGIN_WEBFORM_LOAD:
      {


        controllerIndex_t controllerNr = 0;
          for (controllerIndex_t i=0; i < CONTROLLER_MAX; i++)
          {
            if (Settings.Protocol[i] == 2) { controllerNr = i; }
          }

        if (Settings.ControllerEnabled[controllerNr])
        {
          addRowLabel(F("IDX"));
          String id = F("TDID");
          id += controllerNr + 1;
          addNumericBox(id, Settings.TaskDeviceID[controllerNr][event->TaskIndex], 0, 9999);
        }
        success = true;
        break;
      }

    case PLUGIN_WEBFORM_SAVE:
      {
        success = true;
        break;
      }

    case PLUGIN_INIT:
      {
        int irPin = CONFIG_PIN1;
        if (validGpio(irPin))
        {
          addLog(LOG_LEVEL_INFO, F("P088: Heatpump IR transmitter activated"));
          if (Plugin_088_irSender != nullptr)
          {
            delete Plugin_088_irSender;
          }
          Plugin_088_irSender = new (std::nothrow) IRSenderIRremoteESP8266(irPin);
        }
        if (Plugin_088_irSender != nullptr && irPin == -1)
        {
          addLog(LOG_LEVEL_INFO, F("P088: Heatpump IR transmitter deactivated"));
          delete Plugin_088_irSender;
          Plugin_088_irSender = nullptr;
        }
        success = true;
        break;
      }

    case PLUGIN_READ:
      {
        success = true;
        break;
      }

    case PLUGIN_WRITE:
      {
        String heatpumpModel;
        unsigned int powerMode = POWER_ON;
        unsigned int operatingMode = MODE_HEAT;
        unsigned int fanSpeed = FAN_2;
        unsigned int temperature = 22;
        unsigned int vDir = VDIR_UP;
        unsigned int hDir = HDIR_AUTO;

        String cmd = parseString(string, 1);
        if (cmd.equalsIgnoreCase(F("HEATPUMPIR")) && Plugin_088_irSender != nullptr)
        {
          String TmpStr1;
          if (GetArgv(string.c_str(), TmpStr1, 2)) heatpumpModel = TmpStr1;
          if (GetArgv(string.c_str(), TmpStr1, 3)) powerMode = str2int(TmpStr1.c_str());
          if (GetArgv(string.c_str(), TmpStr1, 4)) operatingMode = str2int(TmpStr1.c_str());
          if (GetArgv(string.c_str(), TmpStr1, 5)) fanSpeed = str2int(TmpStr1.c_str());
          if (GetArgv(string.c_str(), TmpStr1, 6)) temperature = str2int(TmpStr1.c_str());
          if (GetArgv(string.c_str(), TmpStr1, 7)) vDir = str2int(TmpStr1.c_str());
          if (GetArgv(string.c_str(), TmpStr1, 8)) hDir = str2int(TmpStr1.c_str());
#ifdef IR_SEND_TIME
          sendHour = node_time.hour();
          sendMinute = node_time.minute();
          sendWeekday = node_time.weekday();
#endif
          HeatpumpIR *heatpumpIR = HeatpumpIRFactory::create(heatpumpModel.c_str());

          if (heatpumpIR != nullptr) {
            enableIR_RX(false);
            heatpumpIR->send(*Plugin_088_irSender, powerMode, operatingMode, fanSpeed, temperature, vDir, hDir);
            enableIR_RX(true);

            delete heatpumpIR;
            heatpumpIR = nullptr;

            addLog(LOG_LEVEL_INFO, F("P088: Heatpump IR code transmitted"));
#ifdef IR_DEBUG_PACKET
# ifndef BUILD_NO_DEBUG
            addLog(LOG_LEVEL_DEBUG, IRPacket);
#endif
#endif
            if (printToWeb)
            {
              printWebString += F("P088: Heatpump IR code transmitted");
#ifdef IR_DEBUG_PACKET
              printWebString += F(" <BR>\n");
              printWebString += IRPacket;
              printWebString += F("\n");
#endif
            }



            if (strcmp_P(heatpumpModel.c_str(), PSTR("panasonic_ckp")) == 0)
            {
              panasonicCKPTimer = 120;
            }

            success = true;
          }
        }
        break;
      }

    case PLUGIN_EXIT:
     {
        addLog(LOG_LEVEL_INFO, F("P088: Heatpump IR transmitter deactivated"));

        if (Plugin_088_irSender != nullptr)
        {
          delete Plugin_088_irSender;
          Plugin_088_irSender = nullptr;
        }

       break;
     }

    case PLUGIN_ONCE_A_SECOND:
      {
        if (panasonicCKPTimer > 0)
        {
          panasonicCKPTimer--;
          if (panasonicCKPTimer == 0)
          {
            PanasonicCKPHeatpumpIR *panasonicHeatpumpIR = new (std::nothrow) PanasonicCKPHeatpumpIR();
            if (panasonicHeatpumpIR != nullptr) {
              enableIR_RX(false);
              panasonicHeatpumpIR->sendPanasonicCKPCancelTimer(*Plugin_088_irSender);
              enableIR_RX(true);

              delete panasonicHeatpumpIR;
              addLog(LOG_LEVEL_INFO, F("P088: The TIMER led on Panasonic CKP should now be OFF"));
            }
          }
        }
        success = true;
        break;
      }

    case PLUGIN_TEN_PER_SECOND:
      {
        success = true;
        break;
      }
  }

  return success;
}
#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P089_Ping.ino"
#include "_Plugin_Helper.h"
#if defined(USES_P089) && defined(ESP8266)

# include "src/PluginStructs/P089_data_struct.h"
# 29 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P089_Ping.ino"
#define PLUGIN_089 
#define PLUGIN_NAME_089 "Communication - Ping"
#define PLUGIN_VALUENAME1_089 "Fails"


boolean Plugin_089(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_089;
      Device[deviceCount].Type = DEVICE_TYPE_CUSTOM0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].DecimalsOnly = true;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {

      string = F(PLUGIN_NAME_089);
      break;
    }
    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_089));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      ExtraTaskSettings.TaskDeviceValueDecimals[0] = 0;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      char hostname[PLUGIN_089_HOSTNAME_SIZE]{};
      LoadCustomTaskSettings(event->TaskIndex, (uint8_t *)&hostname, PLUGIN_089_HOSTNAME_SIZE);
      string = hostname;
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      char hostname[PLUGIN_089_HOSTNAME_SIZE]{};
      LoadCustomTaskSettings(event->TaskIndex, (uint8_t *)&hostname, PLUGIN_089_HOSTNAME_SIZE);
      addFormTextBox(F("Hostname"), F("host"), hostname, PLUGIN_089_HOSTNAME_SIZE - 2);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      char hostname[PLUGIN_089_HOSTNAME_SIZE]{};


      UserVar.setFloat(event->TaskIndex, 0, 0);
      strncpy(hostname, webArg(F("host")).c_str(), sizeof(hostname));
      SaveCustomTaskSettings(event->TaskIndex, (uint8_t *)&hostname, PLUGIN_089_HOSTNAME_SIZE);
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P089_data_struct());
      UserVar.setFloat(event->TaskIndex, 0, 0);
      break;
    }

    case PLUGIN_READ:
    {
      P089_data_struct *P089_taskdata =
        static_cast<P089_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P089_taskdata) {
        break;
      }

      if (P089_taskdata->send_ping(event)) {
        UserVar.setFloat(event->TaskIndex, 0, UserVar.getFloat(event->TaskIndex, 0) + 1);
      }

      success = true;
      break;
    }

    case PLUGIN_WRITE:
    {
      String command = parseString(string, 1);

      if (equals(command, F("pingset")))
      {
        String taskName = parseString(string, 2);
        String param1 = parseString(string, 3);
        taskIndex_t taskIndex = findTaskIndexByName(taskName);

        if (param1.isEmpty() ||
            (!param1.isEmpty() && (taskIndex != TASKS_MAX) && (taskIndex == event->TaskIndex))) {
          int32_t val_new{};

          if (param1.isEmpty()) {
            param1 = taskName;
          }

          if (validIntFromString(param1, val_new)) {

            if ((val_new > -1024) && (val_new < 1024)) {
              UserVar.setFloat(event->TaskIndex, 0, val_new);
              success = true;
            }
          }
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P090_CCS811.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P090
# 22 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P090_CCS811.ino"
#define PLUGIN_090 
#define PLUGIN_ID_090 90
#define PLUGIN_NAME_090 "Gases - CCS811 TVOC/eCO2"
#define PLUGIN_VALUENAME1_090 "TVOC"
#define PLUGIN_VALUENAME2_090 "eCO2"







#define Plugin_090_D_AWAKE 20
#define Plugin_090_T_AWAKE 100
# 59 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P090_CCS811.ino"
# include "src/PluginStructs/P090_data_struct.h"


#define P090_I2C_ADDR PCONFIG(0)
#define P090_COMPENSATE_ENABLE PCONFIG(1)
#define P090_TEMPERATURE_TASK_INDEX PCONFIG(2)
#define P090_TEMPERATURE_TASK_VALUE PCONFIG(3)
#define P090_HUMIDITY_TASK_INDEX PCONFIG(4)
#define P090_HUMIDITY_TASK_VALUE PCONFIG(5)
#define P090_TEMPERATURE_SCALE PCONFIG(6)
#define P090_READ_INTERVAL PCONFIG_LONG(0)


boolean Plugin_090(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_090;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_090);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_090));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_090));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const int i2cAddressValues[] = { 0x5A, 0x5B };


      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        const __FlashStringHelper *options[2] = { F("0x5A (ADDR pin is LOW)"), F("0x5B (ADDR pin is HIGH)") };
        addFormSelector(F("I2C Address"), F("i2c_addr"), 2, options, i2cAddressValues, P090_I2C_ADDR);
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P090_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      {

        int frequencyChoice = P090_READ_INTERVAL;
        const __FlashStringHelper *frequencyOptions[3] = { F("1 second"), F("10 seconds"), F("60 seconds") };
        const int frequencyValues[3] = { 1, 2, 3 };
        addFormSelector(F("Take reading every"), F("read_frequency"), 3, frequencyOptions, frequencyValues, frequencyChoice);
      }

      addFormSeparator(2);

      {

        addFormCheckBox(F("Enable temp/humid compensation"), F("enable_compensation"), P090_COMPENSATE_ENABLE);
        addFormNote(F("If this is enabled, the Temperature and Humidity values below need to be configured."));


        addRowLabel(F("Temperature"));
        addTaskSelect(F("temperature_task"), P090_TEMPERATURE_TASK_INDEX);
        if (validTaskIndex(P090_TEMPERATURE_TASK_INDEX)) {
          addRowLabel(F("Temperature Value:"));
          addTaskValueSelect(F("temperature_value"), P090_TEMPERATURE_TASK_VALUE, P090_TEMPERATURE_TASK_INDEX);


          int temperatureScale = P090_TEMPERATURE_SCALE;
          addRowLabel(F("Temperature Scale"));
          addHtml(F("<input type='radio' id='p090_temperature_c' name='p090_temperature_scale' value='0'"));
          addHtml((temperatureScale == 0) ? F(" checked>") : F(">"));
          addHtml(F("<label for='p090_temperature_c'> &deg;C</label> &nbsp; "));
          addHtml(F("<input type='radio' id='p090_temperature_f' name='p090_temperature_scale' value='1'"));
          addHtml((temperatureScale == 1) ? F(" checked>") : F(">"));
          addHtml(F("<label for='p090_temperature_f'> &deg;F</label><br>"));


          addRowLabel(F("Humidity"));
          addTaskSelect(F("humidity_task"), P090_HUMIDITY_TASK_INDEX);
          if (validTaskIndex(P090_HUMIDITY_TASK_INDEX)) {
            addRowLabel(F("Humidity Value"));
            addTaskValueSelect(F("humidity_value"), P090_HUMIDITY_TASK_VALUE, P090_HUMIDITY_TASK_INDEX);
          }
        }
      }


      addFormSeparator(2);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P090_I2C_ADDR = getFormItemInt(F("i2c_addr"));
      P090_COMPENSATE_ENABLE = isFormItemChecked(F("enable_compensation"));
      P090_TEMPERATURE_TASK_INDEX = getFormItemInt(F("temperature_task"));
      P090_TEMPERATURE_TASK_VALUE = getFormItemInt(F("temperature_value"));
      P090_HUMIDITY_TASK_INDEX = getFormItemInt(F("humidity_task"));
      P090_HUMIDITY_TASK_VALUE = getFormItemInt(F("humidity_value"));
      P090_TEMPERATURE_SCALE = getFormItemInt(F("temperature_scale"));
      P090_READ_INTERVAL = getFormItemInt(F("read_frequency"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P090_data_struct(P090_I2C_ADDR));
      P090_data_struct *P090_data =
        static_cast<P090_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P090_data) {
        break;
      }


      CCS811Core::status returnCode;
      returnCode = P090_data->myCCS811.begin();

      # ifndef BUILD_NO_DEBUG

      if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
        String log = F("CCS811 : Begin exited with: ");
        log += P090_data->myCCS811.getDriverError(returnCode);
        addLogMove(LOG_LEVEL_DEBUG, log);
      }
      # endif
      UserVar.setFloat(event->TaskIndex, 0, NAN);
      UserVar.setFloat(event->TaskIndex, 1, NAN);







      returnCode = P090_data->myCCS811.setDriveMode(P090_READ_INTERVAL);

      if (returnCode != CCS811Core::SENSOR_SUCCESS) {
      # ifndef BUILD_NO_DEBUG

        if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
          String log = F("CCS811 : Mode request exited with: ");
          log += P090_data->myCCS811.getDriverError(returnCode);
          addLogMove(LOG_LEVEL_DEBUG, log);
        }
      # endif
      } else {
        success = true;
      }
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P090_data_struct *P090_data =
        static_cast<P090_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P090_data) {
        break;
      }

      if (P090_data->myCCS811.dataAvailable())
      {

        CCS811Core::status readstatus = P090_data->myCCS811.readAlgorithmResults();

        if (readstatus == 0)
        {
          success = true;

          if (P090_data->compensation_set) {

            P090_data->compensation_set = false;
          } else {
            UserVar.setFloat(event->TaskIndex, 0, P090_data->myCCS811.getTVOC());
            UserVar.setFloat(event->TaskIndex, 1, P090_data->myCCS811.getCO2());
            P090_data->newReadingAvailable = true;

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("CCS811 : tVOC: ");
              log += P090_data->myCCS811.getTVOC();
              log += F(", eCO2: ");
              log += P090_data->myCCS811.getCO2();
              addLogMove(LOG_LEVEL_INFO, log);
            }
          }
        }
      }

      break;
    }

    case PLUGIN_READ:
    {
      P090_data_struct *P090_data =
        static_cast<P090_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P090_data) {
        break;
      }


      if (P090_COMPENSATE_ENABLE)
      {

        uint8_t TaskIndex = P090_TEMPERATURE_TASK_INDEX;
        if (validTaskIndex(TaskIndex)) {
          uint8_t BaseVarIndex = TaskIndex * VARS_PER_TASK + P090_TEMPERATURE_TASK_VALUE;
          float temperature = UserVar[BaseVarIndex];

          int temperature_in_fahrenheit = P090_TEMPERATURE_SCALE;
          String temp;
          temp += 'C';

          if (temperature_in_fahrenheit)
          {
            temperature = ((temperature - 32) * 5.0f) / 9.0f;
            temp = F("F");
          }

          uint8_t TaskIndex2 = P090_HUMIDITY_TASK_INDEX;
          if (validTaskIndex(TaskIndex2)) {
            uint8_t BaseVarIndex2 = TaskIndex2 * VARS_PER_TASK + P090_HUMIDITY_TASK_VALUE;
            float humidity = UserVar[BaseVarIndex2];

          #ifndef BUILD_NO_DEBUG

            if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {
              String log = F("CCS811 : Compensating for Temperature: ");
              log += toString(temperature) + temp + F(" & Humidity: ") + toString(humidity) + F("%");
              addLogMove(LOG_LEVEL_DEBUG, log);
            }
          #endif

            P090_data->myCCS811.setEnvironmentalData(humidity, temperature);
          }
        }
        P090_data->compensation_set = true;
      }

      if (P090_data->newReadingAvailable) {
        P090_data->newReadingAvailable = false;
        success = true;
      }
      else if (P090_data->myCCS811.checkForStatusError())
      {

        String errorMsg = P090_data->myCCS811.getSensorError();

        if (loglevelActiveFor(LOG_LEVEL_ERROR)) {

          String log = F("CCS811 : Error: ");
          log += errorMsg;
          addLogMove(LOG_LEVEL_ERROR, log);
        }
      }
# 357 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P090_CCS811.ino"
      break;
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P091_SerSwitch.ino"
#include "_Plugin_Helper.h"
# 52 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P091_SerSwitch.ino"
#ifdef USES_P091


#define PLUGIN_091 
#define PLUGIN_ID_091 91
#define PLUGIN_NAME_091 "Serial MCU controlled switch"
#define PLUGIN_VALUENAME1_091 "Relay0"
#define PLUGIN_VALUENAME2_091 "Relay1"
#define PLUGIN_VALUENAME3_091 "Relay2"
#define PLUGIN_VALUENAME4_091 "Relay3"

#define BUFFER_SIZE 168

#define SER_SWITCH_YEWE 1
#define SER_SWITCH_SONOFFDUAL 2
#define SER_SWITCH_LCTECH 3
#define SER_SWITCH_WIFIDIMMER 4

static uint8_t Plugin_091_switchstate[4];
static uint8_t Plugin_091_ostate[4];
uint8_t Plugin_091_commandstate = 0;
Sensor_VType Plugin_091_type = Sensor_VType::SENSOR_TYPE_NONE;
uint8_t Plugin_091_numrelay = 1;
uint8_t Plugin_091_ownindex;
uint8_t Plugin_091_globalpar0;
uint8_t Plugin_091_globalpar1;
uint8_t Plugin_091_cmddbl = false;
uint8_t Plugin_091_ipd = false;
boolean Plugin_091_init = false;

boolean Plugin_091(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_091;
        Device[deviceCount].Type = DEVICE_TYPE_DUMMY;
        Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = false;
        Device[deviceCount].ValueCount = 4;
        Device[deviceCount].SendDataOption = true;
        Device[deviceCount].TimerOption = true;
        Device[deviceCount].TimerOptional = true;
        Device[deviceCount].GlobalSyncOption = true;
        break;
      }
    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_091);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_091));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_091));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_091));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_091));
        success = true;
        break;
      }

    case PLUGIN_WEBFORM_LOAD:
      {
        {
          const __FlashStringHelper * options[4] = {
            F("Yewelink/TUYA"),
            F("Sonoff Dual"),
            F("LC TECH"),
            F("Moes Wifi Dimmer")
          };
          const int optionValues[4] = { SER_SWITCH_YEWE, SER_SWITCH_SONOFFDUAL, SER_SWITCH_LCTECH, SER_SWITCH_WIFIDIMMER };
          addFormSelector(F("Switch Type"), F("type"), 4, options, optionValues, PCONFIG(0));
        }

        if (PCONFIG(0) == SER_SWITCH_YEWE)
        {
          const __FlashStringHelper * buttonOptions[4] = {
            F("1"),
            F("2/Dimmer#2"),
            F("3/Dimmer#3"),
            F("4"),
          };
          const int buttonoptionValues[4] = { 1, 2, 3, 4 };
          addFormSelector(F("Number of relays"), F("button"), 4, buttonOptions, buttonoptionValues, PCONFIG(1));
        }

        if (PCONFIG(0) == SER_SWITCH_SONOFFDUAL)
        {
          const __FlashStringHelper * modeoptions[3] = {
            F("Normal"),
            F("Exclude/Blinds mode"),
            F("Simultaneous mode"),
          };
          const int modeoptionValues[3] = { 0, 1, 2 };
          addFormSelector(F("Relay working mode"), F("mode"), 3, modeoptions, modeoptionValues, PCONFIG(1));
        }

        if (PCONFIG(0) == SER_SWITCH_LCTECH)
        {
          {
            const __FlashStringHelper * buttonOptions[4] = {
              F("1"),
              F("2"),
              F("3"),
              F("4"),
            };
            const int buttonoptionValues[4] = { 1, 2, 3, 4 };
            addFormSelector(F("Number of relays"), F("button"), 4, buttonOptions, buttonoptionValues, PCONFIG(1));
          }

          {
            const __FlashStringHelper * speedOptions[8] = {
              F("9600"),
              F("19200"),
              F("115200"),
              F("1200"),
              F("2400"),
              F("4800"),
              F("38400"),
              F("57600"),
            };
            addFormSelector(F("Serial speed"), F("speed"), 8, speedOptions, nullptr, PCONFIG(2));
          }

          addFormCheckBox(F("Use command doubling"), F("dbl"), PCONFIG(3));
          addFormCheckBox(F("Use IPD preamble"), F("ipd"), PCONFIG(4));
        }

        success = true;
        break;
      }

    case PLUGIN_WEBFORM_SAVE:
      {

        PCONFIG(0) = getFormItemInt(F("type"));
        if (PCONFIG(0) == SER_SWITCH_YEWE)
        {
          PCONFIG(1) = getFormItemInt(F("button"));
        }
        if (PCONFIG(0) == SER_SWITCH_SONOFFDUAL)
        {
          PCONFIG(1) = getFormItemInt(F("mode"));
        }
        if (PCONFIG(0) == SER_SWITCH_LCTECH)
        {
          PCONFIG(1) = getFormItemInt(F("button"));
          PCONFIG(2) = getFormItemInt(F("speed"));
          PCONFIG(3) = isFormItemChecked(F("dbl"));
          PCONFIG(4) = isFormItemChecked(F("ipd"));
          Plugin_091_cmddbl = PCONFIG(3);
          Plugin_091_ipd = PCONFIG(4);
        }

        Plugin_091_globalpar0 = PCONFIG(0);
        Plugin_091_globalpar1 = PCONFIG(1);

        success = true;
        break;
      }

    case PLUGIN_INIT:
      {
        String log;
        Plugin_091_ownindex = event->TaskIndex;
        Settings.UseSerial = true;
        Settings.SerialLogLevel = 0;
        ESPEASY_SERIAL_0.setDebugOutput(false);
        log = F("SerSW : Init ");
        if (PCONFIG(0) == SER_SWITCH_YEWE)
        {
          Plugin_091_numrelay = PCONFIG(1);
          ESPEASY_SERIAL_0.begin(9600, SERIAL_8N1);
          ESPEASY_SERIAL_0.setRxBufferSize(BUFFER_SIZE);
          delay(1);
          getmcustate();
          log += F(" Yewe ");
          log += Plugin_091_numrelay;
          log += F(" btn");
        } else
        if (PCONFIG(0) == SER_SWITCH_SONOFFDUAL)
        {
          Plugin_091_numrelay = 3;
          ESPEASY_SERIAL_0.begin(19230, SERIAL_8N1);
          log += F(" Sonoff Dual");
        } else
        if (PCONFIG(0) == SER_SWITCH_LCTECH)
        {
          Plugin_091_numrelay = PCONFIG(1);
          Plugin_091_cmddbl = PCONFIG(3);
          Plugin_091_ipd = PCONFIG(4);
          unsigned long Plugin_091_speed = 9600;
          switch (PCONFIG(2)) {
            case 1: {
                Plugin_091_speed = 19200;
                break;
              }
            case 2: {
                Plugin_091_speed = 115200;
                break;
              }
            case 3: {
                Plugin_091_speed = 1200;
                break;
              }
            case 4: {
                Plugin_091_speed = 2400;
                break;
              }
            case 5: {
                Plugin_091_speed = 4800;
                break;
              }
            case 6: {
                Plugin_091_speed = 38400;
                break;
              }
            case 7: {
                Plugin_091_speed = 57600;
                break;
              }
          }
          ESPEASY_SERIAL_0.begin(Plugin_091_speed, SERIAL_8N1);
          log += F(" LCTech ");
          log += Plugin_091_speed;
          log += F(" baud ");
          log += Plugin_091_numrelay;
          log += F(" btn");
        } else
        if (PCONFIG(0) == SER_SWITCH_WIFIDIMMER)
        {
          Plugin_091_numrelay = 2;
          Plugin_091_switchstate[1] = 255;
          Plugin_091_ostate[1] = 255;
          ESPEASY_SERIAL_0.begin(9600, SERIAL_8N1);
          log += F(" Wifi Dimmer");
        }

        Plugin_091_globalpar0 = PCONFIG(0);
        Plugin_091_globalpar1 = PCONFIG(1);
        switch (Plugin_091_numrelay)
        {
          case 1:
            Plugin_091_type = Sensor_VType::SENSOR_TYPE_SWITCH;
            break;
          case 2:
            Plugin_091_type = Sensor_VType::SENSOR_TYPE_DUAL;
            break;
          case 3:
            Plugin_091_type = Sensor_VType::SENSOR_TYPE_TRIPLE;
            break;
          case 4:
            Plugin_091_type = Sensor_VType::SENSOR_TYPE_QUAD;
            break;
        }
        addLogMove(LOG_LEVEL_INFO, log);

        success = true;
        Plugin_091_init = true;
        break;
      }


    case PLUGIN_SERIAL_IN:
      {
        int bytes_read = 0;
        uint8_t serial_buf[BUFFER_SIZE];
        String log;

        if (Plugin_091_init)
        {
          while (ESPEASY_SERIAL_0.available() > 0) {
            yield();
            if (bytes_read < BUFFER_SIZE) {
              serial_buf[bytes_read] = ESPEASY_SERIAL_0.read();

              if (bytes_read == 0) {

                Plugin_091_commandstate = 0;
                switch (PCONFIG(0))
                {
                  case SER_SWITCH_YEWE:
                    {
                      if (serial_buf[bytes_read] == 0x55) {
                        Plugin_091_commandstate = 1;
                      }
                      break;
                    }
                  case SER_SWITCH_SONOFFDUAL:
                    {
                      if (serial_buf[bytes_read] == 0xA0) {
                        Plugin_091_commandstate = 1;
                      }
                      break;
                    }
                }
              } else {

                if (Plugin_091_commandstate == 1) {

                  if (bytes_read == 1) {
                    switch (PCONFIG(0))
                    {
                      case SER_SWITCH_YEWE:
                        {
                          if (serial_buf[bytes_read] != 0xAA) {
                            Plugin_091_commandstate = 0;
                            bytes_read = 0;
                          }
                          break;
                        }
                      case SER_SWITCH_SONOFFDUAL:
                        {
                          if ((serial_buf[bytes_read] != 0x04) && (serial_buf[bytes_read] != 0x00)) {
                            Plugin_091_commandstate = 0;
                            bytes_read = 0;
                          }
                          break;
                        }
                    }
                  }

                  if ( (bytes_read == 2) && (PCONFIG(0) == SER_SWITCH_SONOFFDUAL)) {
                    Plugin_091_ostate[0] = Plugin_091_switchstate[0]; Plugin_091_ostate[1] = Plugin_091_switchstate[1]; Plugin_091_ostate[2] = Plugin_091_switchstate[2];
                    Plugin_091_switchstate[0] = 0; Plugin_091_switchstate[1] = 0; Plugin_091_switchstate[2] = 0;
                    if ((serial_buf[bytes_read] & 1) == 1) {
                      Plugin_091_switchstate[0] = 1;
                    }
                    if ((serial_buf[bytes_read] & 2) == 2) {
                      Plugin_091_switchstate[1] = 1;
                    }
                    if ((serial_buf[bytes_read] & 4) == 4) {
                      Plugin_091_switchstate[2] = 1;
                    }
                    Plugin_091_commandstate = 2; bytes_read = 0;

                    if (PCONFIG(1) == 1)
                    {
                      if ((Plugin_091_ostate[0] == 1) && (Plugin_091_switchstate[1] == 1)) {
                        sendmcucommand(0, 0, PCONFIG(0), PCONFIG(1));
                        Plugin_091_switchstate[0] = 0;
                      }
                      if ((Plugin_091_ostate[1] == 1) && (Plugin_091_switchstate[0] == 1)) {
                        sendmcucommand(1, 0, PCONFIG(0), PCONFIG(1));
                        Plugin_091_switchstate[1] = 0;
                      }
                    }
                    if (PCONFIG(1) == 2)
                    {
                      if ((Plugin_091_ostate[0] + Plugin_091_switchstate[0]) == 1) {
                        sendmcucommand(1, Plugin_091_switchstate[0], PCONFIG(0), PCONFIG(1));
                        Plugin_091_switchstate[1] = Plugin_091_switchstate[0];
                      } else {
                        if ((Plugin_091_ostate[1] + Plugin_091_switchstate[1]) == 1) {
                          sendmcucommand(0, Plugin_091_switchstate[1], PCONFIG(0), PCONFIG(1));
                          Plugin_091_switchstate[0] = Plugin_091_switchstate[1];
                        }
                      }
                    }

                    if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                      log = F("SerSW   : State ");
                    }
                    for (int i = 0; i < 3; ++i) {
                      if (Plugin_091_ostate[i] != Plugin_091_switchstate[i]) {
                        UserVar.setFloat(event->TaskIndex, i, Plugin_091_switchstate[i]);
                        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                          log += F(" r");
                          log += i;
                          log += ':';
                          log += Plugin_091_switchstate[i];
                        }
                      }
                    }
                    addLogMove(LOG_LEVEL_INFO, log);
                    if ( (Plugin_091_ostate[0] != Plugin_091_switchstate[0]) || (Plugin_091_ostate[1] != Plugin_091_switchstate[1]) || (Plugin_091_ostate[2] != Plugin_091_switchstate[2]) || (Plugin_091_ostate[3] != Plugin_091_switchstate[3]) ) {
                      event->sensorType = Plugin_091_type;
                      sendData(event);
                    }
                  }
                  if (PCONFIG(0) == SER_SWITCH_YEWE) {
                    if ((bytes_read == 3) && (serial_buf[bytes_read] != 7))
                    {
                      Plugin_091_commandstate = 0;
                      bytes_read = 0;
                    }
                    if (bytes_read == 10) {
                      if (serial_buf[5] == 5) {
                        uint8_t btnnum = (serial_buf[6] - 1);
                        Plugin_091_ostate[btnnum] = Plugin_091_switchstate[btnnum];
                        Plugin_091_switchstate[btnnum] = serial_buf[10];
                        Plugin_091_commandstate = 2; bytes_read = 0;

                        if (Plugin_091_ostate[btnnum] != Plugin_091_switchstate[btnnum]) {
                          log = F("SerSW   : State");
                          switch (btnnum) {
                            case 0: {
                                if (Plugin_091_numrelay > 0) {
                                  UserVar.setFloat(event->TaskIndex, btnnum, Plugin_091_switchstate[btnnum]);
                                  log += F(" r0:");
                                  log += Plugin_091_switchstate[btnnum];
                                }
                                break;
                              }
                            case 1: {
                                if (Plugin_091_numrelay > 1) {
                                  UserVar.setFloat(event->TaskIndex, btnnum, Plugin_091_switchstate[btnnum]);
                                  log += F(" r1:");
                                  log += Plugin_091_switchstate[btnnum];
                                }
                                break;
                              }
                            case 2: {
                                if (Plugin_091_numrelay > 2) {
                                  UserVar.setFloat(event->TaskIndex, btnnum, Plugin_091_switchstate[btnnum]);
                                  log += F(" r2:");
                                  log += Plugin_091_switchstate[btnnum];
                                }
                                break;
                              }
                            case 3: {
                                if (Plugin_091_numrelay > 3) {
                                  UserVar.setFloat(event->TaskIndex, btnnum, Plugin_091_switchstate[btnnum]);
                                  log += F(" r3:");
                                  log += Plugin_091_switchstate[btnnum];
                                }
                                break;
                              }
                          }
                          event->sensorType = Plugin_091_type;
                          addLogMove(LOG_LEVEL_INFO, log);
                          sendData(event);
                        }
                      }
                    }

                    if (bytes_read == 13) {
                      if (serial_buf[5] == 8) {
                        uint8_t btnnum = (serial_buf[6] - 1);
                        Plugin_091_ostate[btnnum] = Plugin_091_switchstate[btnnum];
                        Plugin_091_switchstate[btnnum] = serial_buf[13];
                        Plugin_091_commandstate = 2; bytes_read = 0;

                        if (Plugin_091_ostate[btnnum] != Plugin_091_switchstate[btnnum]) {
                          log = F("SerSW   : Dimmer");
                          switch (btnnum) {
                            case 1: {
                                if (Plugin_091_numrelay > 1) {
                                  UserVar.setFloat(event->TaskIndex, btnnum, Plugin_091_switchstate[btnnum]);
                                  log += F(" d1:");
                                  log += Plugin_091_switchstate[btnnum];
                                }
                                break;
                              }
                            case 2: {
                                if (Plugin_091_numrelay > 2) {
                                  UserVar.setFloat(event->TaskIndex, btnnum, Plugin_091_switchstate[btnnum]);
                                  log += F(" d2:");
                                  log += Plugin_091_switchstate[btnnum];
                                }
                                break;
                              }
                          }
                          event->sensorType = Plugin_091_type;
                          addLogMove(LOG_LEVEL_INFO, log);
                          sendData(event);
                        }
                      }
                    }

                  }
                }
              }

              if (Plugin_091_commandstate == 1) {
                bytes_read++;
              }
            } else
              ESPEASY_SERIAL_0.read();
          }
        }
        success = true;
        break;
      }

    case PLUGIN_READ:
      {
        if (Plugin_091_init)
        {
          if ((PCONFIG(0) == SER_SWITCH_YEWE) && (Plugin_091_commandstate != 1))
          {
            addLog(LOG_LEVEL_INFO, F("SerSW   : ReadState"));
            getmcustate();
          }
          if (PCONFIG(0) == SER_SWITCH_WIFIDIMMER) {
            if (Plugin_091_switchstate[1] < 1)
            {
              UserVar.setFloat(event->TaskIndex, 0, 0);
            } else {
              UserVar.setFloat(event->TaskIndex, 0, 1);
            }
            UserVar.setFloat(event->TaskIndex, 1, Plugin_091_switchstate[1]);
          }
          success = true;
        }
        break;
      }

    case PLUGIN_WRITE:
      {
        String log;
        String command = parseString(string, 1);
        uint8_t rnum = 0;
        uint8_t rcmd = 0;
        uint8_t par3 = 0;

        if (Plugin_091_init)
        {
          if ( equals(command, F("relay")))
          {
            success = true;

            if ((event->Par1 >= 0) && (event->Par1 < Plugin_091_numrelay)) {
              rnum = event->Par1;
            }
            if ((event->Par2 == 0) || (event->Par2 == 1)) {
              rcmd = event->Par2;
            }


            event->setTaskIndex(Plugin_091_ownindex);

            if (event->Par2 == 2) {
              rcmd = 1 - UserVar[(event->BaseVarIndex + rnum)];
            }

            if ( Plugin_091_globalpar0 < SER_SWITCH_LCTECH) {
              par3 = Plugin_091_globalpar1;
            }
            sendmcucommand(rnum, rcmd, Plugin_091_globalpar0, par3);
            if ( Plugin_091_globalpar0 > SER_SWITCH_YEWE) {
              if (UserVar[(event->BaseVarIndex + rnum)] != Plugin_091_switchstate[rnum]) {
                UserVar.setFloat(event->TaskIndex, rnum, Plugin_091_switchstate[rnum]);
                if (( par3 == 1) && (rcmd == 1) && (rnum < 2))
                {

                  UserVar.setFloat(event->TaskIndex, 1 - rnum, 0);
                }
                if (par3 == 2) {

                  UserVar.setFloat(event->TaskIndex, 1 - rnum, Plugin_091_switchstate[1 - rnum]);
                }
                if (Plugin_091_globalpar0 == SER_SWITCH_WIFIDIMMER) {
                  UserVar.setFloat(event->TaskIndex, 1, Plugin_091_switchstate[1]);
                }
                event->sensorType = Plugin_091_type;
                sendData(event);
              }
            }
            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("SerSW   : SetSwitch r");
              log += rnum;
              log += ':';
              log += rcmd;
              addLogMove(LOG_LEVEL_INFO, log);
            }
          } else

          if ( equals(command, F("relaypulse")))
          {
            success = true;

            if ((event->Par1 >= 0) && (event->Par1 < Plugin_091_numrelay)) {
              rnum = event->Par1;
            }
            if ((event->Par2 == 0) || (event->Par2 == 1)) {
              rcmd = event->Par2;
            }

            event->setTaskIndex(Plugin_091_ownindex);

            if ( Plugin_091_globalpar0 < SER_SWITCH_LCTECH) {
              par3 = Plugin_091_globalpar1;
            }

            sendmcucommand(rnum, rcmd, Plugin_091_globalpar0, par3);
            delay(event->Par3);
            sendmcucommand(rnum, !rcmd, Plugin_091_globalpar0, par3);
            if ( Plugin_091_globalpar0 > SER_SWITCH_YEWE) {
              if (UserVar[(event->BaseVarIndex + rnum)] != Plugin_091_switchstate[rnum]) {
                UserVar.setFloat(event->TaskIndex, rnum, Plugin_091_switchstate[rnum]);
                if (( par3 == 1) && (rcmd == 1) && (rnum < 2))
                {

                  UserVar.setFloat(event->TaskIndex, 1 - rnum, 0);
                }
                if (par3 == 2) {

                  UserVar.setFloat(event->TaskIndex, 1 - rnum, Plugin_091_switchstate[1 - rnum]);
                }
                if (Plugin_091_globalpar0 == SER_SWITCH_WIFIDIMMER) {
                  UserVar.setFloat(event->TaskIndex, 1, Plugin_091_switchstate[1]);
                }
                event->sensorType = Plugin_091_type;
                sendData(event);
              }
            }

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("SerSW   : SetSwitchPulse r");
              log += rnum;
              log += ':';
              log += rcmd;
              log += F(" Pulsed for ");
              log += String(event->Par3);
              log += F(" mS");
              addLogMove(LOG_LEVEL_INFO, log);
            }
          } else

          if ( equals(command, F("relaylongpulse")))
          {
            success = true;

            if ((event->Par1 >= 0) && (event->Par1 < Plugin_091_numrelay)) {
              rnum = event->Par1;
            }
            if ((event->Par2 == 0) || (event->Par2 == 1)) {
              rcmd = event->Par2;
            }

            event->setTaskIndex(Plugin_091_ownindex);

            if ( Plugin_091_globalpar0 < SER_SWITCH_LCTECH) {
              par3 = Plugin_091_globalpar1;
            }
            unsigned long timer = event->Par3 * 1000;

            sendmcucommand(rnum, rcmd, Plugin_091_globalpar0, par3);

            Scheduler.setPluginTaskTimer(timer, event->TaskIndex, rnum, !rcmd);
            if ( Plugin_091_globalpar0 > SER_SWITCH_YEWE) {
              if (UserVar[(event->BaseVarIndex + rnum)] != Plugin_091_switchstate[rnum]) {
                UserVar.setFloat(event->TaskIndex, rnum, Plugin_091_switchstate[rnum]);
                if (( par3 == 1) && (rcmd == 1) && (rnum < 2))
                {

                  UserVar.setFloat(event->TaskIndex, 1 - rnum, 0);
                }
                if (par3 == 2) {

                  UserVar.setFloat(event->TaskIndex, 1 - rnum, Plugin_091_switchstate[1 - rnum]);
                }
                if (Plugin_091_globalpar0 == SER_SWITCH_WIFIDIMMER) {
                  UserVar.setFloat(event->TaskIndex, 1, Plugin_091_switchstate[1]);
                }
                event->sensorType = Plugin_091_type;
                sendData(event);
              }
            }

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("SerSW   : SetSwitchPulse r");
              log += rnum;
              log += ':';
              log += rcmd;
              log += F(" Pulse for ");
              log += String(event->Par3);
              log += F(" sec");
              addLogMove(LOG_LEVEL_INFO, log);
            }
          } else
          if ( equals(command, F("ydim")) )
          {
            if (( (Plugin_091_globalpar0 == SER_SWITCH_YEWE) && (Plugin_091_numrelay > 1)) || (Plugin_091_globalpar0 == SER_SWITCH_WIFIDIMMER)) {
              success = true;


              event->setTaskIndex(Plugin_091_ownindex);

              sendmcudim(event->Par1, Plugin_091_globalpar0);
              if (Plugin_091_globalpar0 == SER_SWITCH_WIFIDIMMER) {
                if (Plugin_091_switchstate[1] < 1)
                {
                  UserVar.setFloat(event->TaskIndex, 0, 0);
                  UserVar.setFloat(event->TaskIndex, 1, Plugin_091_switchstate[1]);
                } else {
                  UserVar.setFloat(event->TaskIndex, 0, 1);
                  UserVar.setFloat(event->TaskIndex, 1, Plugin_091_switchstate[1]);
                }
                event->sensorType = Plugin_091_type;
                sendData(event);
              }
              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log = F("SerSW   : SetDim ");
                log += event->Par1;
                addLogMove(LOG_LEVEL_INFO, log);
              }
            } else {
              SendStatus(event, F("\nYDim not supported"));
            }
          }

        }

        break;
      }

    case PLUGIN_TASKTIMER_IN:
      {
        uint8_t par3 = 0;


        event->setTaskIndex(Plugin_091_ownindex);

        if ( Plugin_091_globalpar0 < SER_SWITCH_LCTECH) {
          par3 = Plugin_091_globalpar1;
        }

        uint8_t rnum = event->Par1;
        uint8_t rcmd = event->Par2;

        sendmcucommand(rnum, rcmd, Plugin_091_globalpar0, par3);
        if ( Plugin_091_globalpar0 > SER_SWITCH_YEWE) {
          if (UserVar[(event->BaseVarIndex + rnum)] != Plugin_091_switchstate[rnum]) {
            UserVar.setFloat(event->TaskIndex, rnum, Plugin_091_switchstate[rnum]);
            if (( par3 == 1) && (rcmd == 1) && (rnum < 2))
            {

              UserVar.setFloat(event->TaskIndex, 1 - rnum, 0);
            }
            if (par3 == 2) {

              UserVar.setFloat(event->TaskIndex, 1 - rnum, Plugin_091_switchstate[1 - rnum]);
            }
            if (Plugin_091_globalpar0 == SER_SWITCH_WIFIDIMMER) {
              UserVar.setFloat(event->TaskIndex, 1, Plugin_091_switchstate[1]);
            }
            event->sensorType = Plugin_091_type;
            sendData(event);
          }
        }

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log = F("SerSW   : SetSwitchPulse r");
          log += rnum;
          log += ':';
          log += rcmd;
          log += F(" Pulse ended");
          addLogMove(LOG_LEVEL_INFO, log);
        }

        break;
      }


  }
  return success;
}

void getmcustate() {
  ESPEASY_SERIAL_0.write(0x55);
  ESPEASY_SERIAL_0.write(0xAA);
  ESPEASY_SERIAL_0.write(0x00);
  ESPEASY_SERIAL_0.write(0x08);
  ESPEASY_SERIAL_0.write(0x00);
  ESPEASY_SERIAL_0.write(0x00);
  ESPEASY_SERIAL_0.write(0x07);
  ESPEASY_SERIAL_0.flush();
}

void sendmcucommand(uint8_t btnnum, uint8_t state, uint8_t swtype, uint8_t btnum_mode)
{
  uint8_t sstate;

  switch (swtype)
  {
    case SER_SWITCH_YEWE:
      {
        ESPEASY_SERIAL_0.write(0x55);
        ESPEASY_SERIAL_0.write(0xAA);
        ESPEASY_SERIAL_0.write(0x00);
        ESPEASY_SERIAL_0.write(0x06);
        ESPEASY_SERIAL_0.write(0x00);
        ESPEASY_SERIAL_0.write(0x05);
        ESPEASY_SERIAL_0.write( (btnnum + 1) );
        ESPEASY_SERIAL_0.write(0x01);
        ESPEASY_SERIAL_0.write(0x00);
        ESPEASY_SERIAL_0.write(0x01);
        ESPEASY_SERIAL_0.write( state );
        ESPEASY_SERIAL_0.write((13 + btnnum + state));
        ESPEASY_SERIAL_0.flush();
        break;
      }
    case SER_SWITCH_SONOFFDUAL:
      {
        Plugin_091_switchstate[btnnum] = state;
        if (( btnum_mode == 1) && (state == 1) && (btnnum < 2))
        {
          Plugin_091_switchstate[(1 - btnnum)] = 0;
        }
        if (btnum_mode == 2)
        {
          Plugin_091_switchstate[0] = state;
          Plugin_091_switchstate[1] = state;
        }
        sstate = Plugin_091_switchstate[0] + (Plugin_091_switchstate[1] << 1) + (Plugin_091_switchstate[2] << 2);
        ESPEASY_SERIAL_0.write(0xA0);
        ESPEASY_SERIAL_0.write(0x04);
        ESPEASY_SERIAL_0.write( sstate );
        ESPEASY_SERIAL_0.write(0xA1);
        ESPEASY_SERIAL_0.flush();
        break;
      }
    case SER_SWITCH_LCTECH:
      {
        uint8_t c_d = 1;
        if (Plugin_091_cmddbl) {
          c_d = 2;
        }
        Plugin_091_switchstate[btnnum] = state;
        for (uint8_t x = 0; x < c_d; x++)
        {
          if (x > 0) {
            delay(1);
          }
          if (Plugin_091_ipd) {
            ESPEASY_SERIAL_0.write(0x0D);
            ESPEASY_SERIAL_0.write(0x0A);
            ESPEASY_SERIAL_0.write(0x2B);
            ESPEASY_SERIAL_0.write(0x49);
            ESPEASY_SERIAL_0.write(0x50);
            ESPEASY_SERIAL_0.write(0x44);
            ESPEASY_SERIAL_0.write(0x2C);
            ESPEASY_SERIAL_0.write(0x30);
            ESPEASY_SERIAL_0.write(0x2C);
            ESPEASY_SERIAL_0.write(0x34);
            ESPEASY_SERIAL_0.write(0x3A);
          }
          ESPEASY_SERIAL_0.write(0xA0);
          ESPEASY_SERIAL_0.write((0x01 + btnnum));
          ESPEASY_SERIAL_0.write((0x00 + state));
          ESPEASY_SERIAL_0.write((0xA1 + state + btnnum));
          ESPEASY_SERIAL_0.flush();
        }

        break;

      }
    case SER_SWITCH_WIFIDIMMER:
      {
        if (btnnum == 0) {
          if (state == 0) {
            Plugin_091_switchstate[0] = 0;
            if (Plugin_091_switchstate[1] < 1) {
              if (Plugin_091_ostate[1] < 1) {
                Plugin_091_ostate[1] = 255;
              }
            } else {
              Plugin_091_ostate[1] = Plugin_091_switchstate[1];
            }
            sendmcudim(0, SER_SWITCH_WIFIDIMMER);
          } else {
            Plugin_091_switchstate[0] = 1;
            if (Plugin_091_ostate[1] < 1) {
              if (Plugin_091_switchstate[1] > 0) {
                sstate = Plugin_091_switchstate[1];
              } else {
                sstate = 255;
              }
            } else {
              sstate = Plugin_091_ostate[1];
            }
            sendmcudim(sstate, SER_SWITCH_WIFIDIMMER);
          }
        }
        break;
      }
  }
}

void sendmcudim(uint8_t dimvalue, uint8_t swtype)
{
  switch (swtype)
  {
    case SER_SWITCH_YEWE:
      {
        ESPEASY_SERIAL_0.write(0x55);
        ESPEASY_SERIAL_0.write(0xAA);
        ESPEASY_SERIAL_0.write(0x00);
        ESPEASY_SERIAL_0.write(0x06);
        ESPEASY_SERIAL_0.write(0x00);
        ESPEASY_SERIAL_0.write(0x08);
        ESPEASY_SERIAL_0.write(Plugin_091_numrelay);
        ESPEASY_SERIAL_0.write(0x02);
        ESPEASY_SERIAL_0.write(0x00);
        ESPEASY_SERIAL_0.write(0x04);
        ESPEASY_SERIAL_0.write(0x00);
        ESPEASY_SERIAL_0.write(0x00);
        ESPEASY_SERIAL_0.write(0x00);
        ESPEASY_SERIAL_0.write( dimvalue );
        ESPEASY_SERIAL_0.write( uint8_t(19 + Plugin_091_numrelay + dimvalue) );
        ESPEASY_SERIAL_0.flush();
        break;
      }
    case SER_SWITCH_WIFIDIMMER:
      {
        ESPEASY_SERIAL_0.write(0xFF);
        ESPEASY_SERIAL_0.write(0x55);
        ESPEASY_SERIAL_0.write( dimvalue );
        ESPEASY_SERIAL_0.write(0x05);
        ESPEASY_SERIAL_0.write(0xDC);
        ESPEASY_SERIAL_0.write(0x0A);
        ESPEASY_SERIAL_0.flush();
        Plugin_091_switchstate[1] = dimvalue;
        break;
      }
  }
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P092_DLbus.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P092
# 69 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P092_DLbus.ino"
# include "src/PluginStructs/P092_data_struct.h"

# include "src/ESPEasyCore/ESPEasyNetwork.h"

#define PLUGIN_092 
#define PLUGIN_ID_092 92


#define PLUGIN_NAME_092 "Heating - DL-Bus (Technische Alternative)"
#define PLUGIN_VALUENAME1_092 "Value"


uint8_t P092_Last_DLB_Pin = 0xFF;
boolean P092_init = false;
P092_data_struct *P092_data = nullptr;

boolean Plugin_092(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_092;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].DecimalsOnly = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_092);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_092));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        uint8_t choice = PCONFIG(2);

        if (choice == 0) {

          if ((PCONFIG(0) == 6133) || (PCONFIG(0) == 6132)) {

            choice = static_cast<uint8_t>(eP092pinmode::ePPM_Input);
          }
          else {

            choice = static_cast<uint8_t>(eP092pinmode::ePPM_InputPullUp);
          }
        }
        const __FlashStringHelper *options[] = {
          F("Input"),
          F("Input pullup")
        };
        const int optionValues[] = {
          static_cast<int>(eP092pinmode::ePPM_Input),
          static_cast<int>(eP092pinmode::ePPM_InputPullUp)
        };
        addFormSelector(F("Pin mode"), F("ppinmode"), 2, options, optionValues, choice);
      }
      {
        const __FlashStringHelper *Devices[P092_DLbus_DeviceCount] = {
          F("ESR21"),
          F("UVR31"),
          F("UVR42"),
          F("UVR1611"),
          F("UVR 61-3 (up to v8.2)"),
          F("UVR 61-3 (v8.3 or higher)") };
        const int DevTypes[P092_DLbus_DeviceCount] = { 21, 31, 42, 1611, 6132, 6133 };

        addFormSelector(F("DL-Bus Type"), F("pdlbtype"), P092_DLbus_DeviceCount, Devices, DevTypes, nullptr, PCONFIG(0), true);
      }
      {
        int P092_ValueType, P092_ValueIdx;
        P092_Last_DLB_Pin = CONFIG_PIN1;
        const String plugin_092_DefValueName = F(PLUGIN_VALUENAME1_092);
        const int P092_OptionTypes[P092_DLbus_OptionCount] = {

          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7
        };
        const __FlashStringHelper *Options[P092_DLbus_OptionCount] = {
          F("None"),
          F("Sensor"),
          F("Ext. sensor"),
          F("Digital output"),
          F("Speed step"),
          F("Analog output"),
          F("Heat power (kW)"),
          F("Heat meter (MWh)")
        };

        uint8_t P092_MaxIdx[P092_DLbus_OptionCount];



        P092_MaxIdx[0] = 0;
        P092_MaxIdx[1] = 3;
        P092_MaxIdx[2] = 0;
        P092_MaxIdx[3] = 1;
        P092_MaxIdx[4] = 0;
        P092_MaxIdx[5] = 0;
        P092_MaxIdx[6] = 0;
        P092_MaxIdx[7] = 0;

        switch (PCONFIG(0)) {
          case 21:
            P092_MaxIdx[2] = 6;
            P092_MaxIdx[4] = 1;
            P092_MaxIdx[5] = 1;
            P092_MaxIdx[6] = 1;
            P092_MaxIdx[7] = 1;
            break;
          case 42:
            P092_MaxIdx[1] = 4;
            P092_MaxIdx[3] = 2;
            break;
          case 1611:
            P092_MaxIdx[1] = 16;
            P092_MaxIdx[3] = 13;
            P092_MaxIdx[4] = 4;
            P092_MaxIdx[6] = 2;
            P092_MaxIdx[7] = 2;
            break;
          case 6132:
            P092_MaxIdx[1] = 6;
            P092_MaxIdx[3] = 8;
            P092_MaxIdx[4] = 1;
            P092_MaxIdx[5] = 1;
            P092_MaxIdx[6] = 1;
            P092_MaxIdx[7] = 1;
            break;
          case 6133:
            P092_MaxIdx[1] = 6;
            P092_MaxIdx[2] = 9;
            P092_MaxIdx[3] = 3;
            P092_MaxIdx[4] = 1;
            P092_MaxIdx[5] = 2;
            P092_MaxIdx[6] = 3;
            P092_MaxIdx[7] = 3;
            break;
        }

        addFormSubHeader(F("Inputs"));

        P092_ValueType = PCONFIG(1) >> 8;
        P092_ValueIdx = PCONFIG(1) & 0x00FF;

        addFormSelector(plugin_092_DefValueName,
                        F("pValue"),
                        P092_DLbus_OptionCount,
                        Options,
                        P092_OptionTypes,
                        nullptr,
                        P092_ValueType,
                        true);

        if (P092_MaxIdx[P092_ValueType] > 1) {
          int CurIdx = P092_ValueIdx;

          if (CurIdx < 1) {
            CurIdx = 1;
          }

          if (CurIdx > P092_MaxIdx[P092_ValueType]) {
            CurIdx = P092_MaxIdx[P092_ValueType];
          }
          addHtml(F(" Index: "));
          addNumericBox(F("pIdx"), CurIdx, 1, P092_MaxIdx[P092_ValueType]);
        }
      }

      UserVar.setFloat(event->TaskIndex, 0, NAN);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      int P092_OptionValueDecimals[P092_DLbus_OptionCount] = {

        0,
        1,
        1,
        0,
        0,
        1,
        1,
        4
      };

      PCONFIG(0) = getFormItemInt(F("pdlbtype"));

      if (PCONFIG(0) == 1611) {
        P092_OptionValueDecimals[6] = 2;
      }

      int OptionIdx = getFormItemInt(F("pValue"));
      int CurIdx = getFormItemInt(F("pIdx"));

      if (CurIdx < 1) {
        CurIdx = 1;
      }
      PCONFIG(1) = (OptionIdx << 8) + CurIdx;
      ExtraTaskSettings.TaskDeviceValueDecimals[event->BaseVarIndex] = P092_OptionValueDecimals[OptionIdx];

      PCONFIG(2) = getFormItemInt(F("ppinmode"));

      if (nullptr == P092_data) {
        addLog(LOG_LEVEL_ERROR, F("## P092_save: Error DL-Bus: Class not initialized!"));
        return false;
      }

      if (P092_Last_DLB_Pin != CONFIG_PIN1) {

        P092_init = false;

        if (P092_data->DLbus_Data->IsISRset) {

          P092_data->DLbus_Data->IsISRset = false;
          detachInterrupt(digitalPinToInterrupt(P092_data->DLbus_Data->ISR_DLB_Pin));
          # ifndef LIMIT_BUILD_SIZE
          addLog(LOG_LEVEL_INFO, F("P092_save: detachInterrupt"));
          # endif
        }
      }

      # ifdef PLUGIN_092_DEBUG

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log = F("PLUGIN_WEBFORM_SAVE :");
        log += F(" DLB_Pin:");
        log += CONFIG_PIN1;
        log += F(" DLbus_MinPulseWidth:");
        log += P092_data->P092_DataSettings.DLbus_MinPulseWidth;
        log += F(" DLbus_MaxPulseWidth:");
        log += P092_data->P092_DataSettings.DLbus_MaxPulseWidth;
        log += F(" DLbus_MinDoublePulseWidth:");
        log += P092_data->P092_DataSettings.DLbus_MinDoublePulseWidth;
        log += F(" DLbus_MaxDoublePulseWidth:");
        log += P092_data->P092_DataSettings.DLbus_MaxDoublePulseWidth;
        log += F(" IdxSensor:");
        log += P092_data->P092_DataSettings.IdxSensor;
        log += F(" IdxExtSensor:");
        log += P092_data->P092_DataSettings.IdxExtSensor;
        log += F(" IdxOutput:");
        log += P092_data->P092_DataSettings.IdxOutput;

        if (P092_data->P092_DataSettings.SpeedBytes > 0) {
          log += F(" IdxDrehzahl:");
          log += P092_data->P092_DataSettings.IdxDrehzahl;
        }

        if (P092_data->P092_DataSettings.AnalogBytes > 0) {
          log += F(" IdxAnalog:");
          log += P092_data->P092_DataSettings.IdxAnalog;
        }

        if (P092_data->P092_DataSettings.MaxHeatMeters > 0) {
          log += F(" IdxHmRegister:");
          log += P092_data->P092_DataSettings.IdxHmRegister;
        }

        if (P092_data->P092_DataSettings.VolumeBytes > 0) {
          log += F(" IdxVolume:");
          log += P092_data->P092_DataSettings.IdxVolume;
        }

        if (P092_data->P092_DataSettings.MaxHeatMeters > 0) {
          log += F(" IdxHM1:");
          log += P092_data->P092_DataSettings.IdxHeatMeter1;
          log += F(" IdxkWh1:");
          log += P092_data->P092_DataSettings.IdxkWh1;
          log += F(" IdxMWh1:");
          log += P092_data->P092_DataSettings.IdxMWh1;
        }

        if (P092_data->P092_DataSettings.MaxHeatMeters > 1) {
          log += F(" IdxHM2:");
          log += P092_data->P092_DataSettings.IdxHeatMeter2;
          log += F(" IdxkWh2:");
          log += P092_data->P092_DataSettings.IdxkWh2;
          log += F(" IdxMWh2:");
          log += P092_data->P092_DataSettings.IdxMWh2;
        }

        if (P092_data->P092_DataSettings.MaxHeatMeters > 2) {
          log += F(" IdxHM3:");
          log += P092_data->P092_DataSettings.IdxHeatMeter3;
          log += F(" IdxkWh3:");
          log += P092_data->P092_DataSettings.IdxkWh3;
          log += F(" IdxMWh3:");
          log += P092_data->P092_DataSettings.IdxMWh3;
        }
        log += F(" IdxCRC:");
        log += P092_data->P092_DataSettings.IdxCRC;
        addLogMove(LOG_LEVEL_INFO, log);
      }
      # endif
      UserVar.setFloat(event->TaskIndex, 0, NAN);
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
# ifndef P092_LIMIT_BUILD_SIZE
      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        addLogMove(LOG_LEVEL_INFO, concat(F("PLUGIN_092_INIT Task:"), event->TaskIndex));
      }
# endif

      if (P092_init) {
# ifndef P092_LIMIT_BUILD_SIZE
        addLog(LOG_LEVEL_INFO, F("INIT -> Already done!"));
# endif
      }
      else {
        if (P092_data == nullptr) {
# ifndef P092_LIMIT_BUILD_SIZE
          addLog(LOG_LEVEL_INFO, F("Create P092_data_struct ..."));
# endif

          P092_data = new (std::nothrow) P092_data_struct();
          initPluginTaskData(event->TaskIndex, P092_data);

          if (P092_data == nullptr) {
            addLog(LOG_LEVEL_ERROR, F("## P092_init: Create P092_data_struct failed!"));
            return false;
          }
        }
        else {
# ifndef P092_LIMIT_BUILD_SIZE
          addLog(LOG_LEVEL_INFO, F("P092_data_struct -> Already created"));
# endif
        }
        P092_data_struct *P092_data = static_cast<P092_data_struct *>(getPluginTaskData(event->TaskIndex));

# ifndef P092_LIMIT_BUILD_SIZE
        addLog(LOG_LEVEL_INFO, F("Init P092_data_struct ..."));
# endif

        if (!P092_data->init(CONFIG_PIN1, PCONFIG(0), static_cast<eP092pinmode>(PCONFIG(2)))) {
          addLog(LOG_LEVEL_ERROR, F("## P092_init: Error DL-Bus: Class not initialized!"));
          clearPluginTaskData(event->TaskIndex);
          return false;
        }

        P092_init = true;
      }

      success = true;
      UserVar.setFloat(event->TaskIndex, 0, NAN);
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      if (!NetworkConnected()) {
        return false;
      }

      if (!P092_init) {
        return false;
      }

      if (nullptr == P092_data) {
        return false;
      }

      if (!P092_data->DLbus_Data->IsISRset) {

        P092_data->DLbus_Data->attachDLBusInterrupt();
# ifndef P092_LIMIT_BUILD_SIZE
       addLog(LOG_LEVEL_INFO, F("P092 ISR set"));
# endif
      }

      if (P092_data->DLbus_Data->ISR_Receiving) {
        return false;
      }

      P092_data->Plugin_092_SetIndices(PCONFIG(0));

      if (P092_data->DLbus_Data->ISR_AllBitsReceived) {
        P092_data->DLbus_Data->ISR_AllBitsReceived = false;
        success = P092_data->DLbus_Data->CheckTimings();

        if (success) {
          success = P092_data->DLbus_Data->Processing();
        }

        if (success) {
          success = P092_data->DLbus_Data->CheckCRC(P092_data->P092_DataSettings.IdxCRC);
        }

        if (success) {
          P092_data->P092_LastReceived = millis();
# ifndef P092_LIMIT_BUILD_SIZE
          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            addLogMove(LOG_LEVEL_INFO, concat(F("Received data OK TI:"), event->TaskIndex));
          }
# endif
        }
        P092_data->P092_ReceivedOK = success;
      }
      else {
        success = P092_data->P092_ReceivedOK;
      }

      if ((!P092_data->DLbus_Data->IsNoData) &&
          ((!P092_data->P092_ReceivedOK) ||
           (timePassedSince(P092_data->P092_LastReceived) > (static_cast<long>(Settings.TaskDeviceTimer[event->TaskIndex] * 1000 / 2))))) {
        P092_data->Plugin_092_StartReceiving(event->TaskIndex);
        success = true;
      }
      break;
    }

    case PLUGIN_READ:
    {
# ifndef P092_LIMIT_BUILD_SIZE
      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        addLogMove(LOG_LEVEL_INFO, concat(F("PLUGIN_092_READ Task:"), event->TaskIndex));
      }
# endif

      if (!NetworkConnected()) {

        addLog(LOG_LEVEL_ERROR, F("## P092_read: Error DL-Bus: WiFi not connected!"));
        return false;
      }

      if (!P092_init) {
        addLog(LOG_LEVEL_ERROR, F("## P092_read: Error DL-Bus: Not initialized!"));
        return false;
      }

      if (nullptr == P092_data) {
        addLog(LOG_LEVEL_ERROR, F("## P092_read: Error DL-Bus: Class not initialized!"));
        return false;
      }

      if (P092_data->DLbus_Data->ISR_DLB_Pin != CONFIG_PIN1) {
        if (loglevelActiveFor(LOG_LEVEL_ERROR)) {
          String log;
          log += F("## P092_read: Error DL-Bus: Device Pin setting not correct! DLB_Pin:");
          log += P092_data->DLbus_Data->ISR_DLB_Pin;
          log += F(" Setting:");
          log += CONFIG_PIN1;
          addLogMove(LOG_LEVEL_ERROR, log);
        }
        return false;
      }

      if (!P092_data->DLbus_Data->IsISRset) {
        addLog(LOG_LEVEL_ERROR, F("## P092_read: Error DL-Bus: ISR not set"));
        return true;
      }

      if (P092_data->DLbus_Data->IsNoData) {

        P092_data->DLbus_Data->IsNoData = false;
        return true;
      }

      success = P092_data->P092_ReceivedOK;

      if (!P092_data->P092_ReceivedOK) {
# ifndef P092_LIMIT_BUILD_SIZE
        addLog(LOG_LEVEL_INFO, F("P092_read: Still receiving DL-Bus bits!"));
# endif
        success = true;
      }
      else {
        P092_data_struct::sP092_ReadData P092_ReadData;

        int OptionIdx = PCONFIG(1) >> 8;
        int CurIdx = PCONFIG(1) & 0x00FF;

        if (P092_data->P092_GetData(OptionIdx, CurIdx, &P092_ReadData)) {
          UserVar.setFloat(event->TaskIndex, 0, P092_ReadData.value);
        }
        else {
          addLog(LOG_LEVEL_ERROR, F("## P092_read: Error: No readings!"));
        }
      }
      break;
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P093_MitsubishiHP.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P093
# 31 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P093_MitsubishiHP.ino"
# include "src/PluginStructs/P093_data_struct.h"

#define PLUGIN_093 
#define PLUGIN_ID_093 93
#define PLUGIN_NAME_093 "Energy (Heat) - Mitsubishi Heat Pump"
#define PLUGIN_VALUENAME1_093 "settings"

#define P093_REQUEST_STATUS PCONFIG(0)
#define P093_REQUEST_STATUS_LABEL PCONFIG_LABEL(0)


boolean Plugin_093(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_093;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_STRING;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_093);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_093));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES: {
      serialHelper_getGpioNames(event);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG: {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS: {
      P093_REQUEST_STATUS = 0;
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
      addFormCheckBox(F("Include AC status"), P093_REQUEST_STATUS_LABEL, P093_REQUEST_STATUS);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      P093_REQUEST_STATUS = isFormItemChecked(P093_REQUEST_STATUS_LABEL);
      success = true;
      break;
    }

    case PLUGIN_INIT: {
      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P093_data_struct(port, CONFIG_PIN1, CONFIG_PIN2, P093_REQUEST_STATUS));
      P093_data_struct *heatPump = static_cast<P093_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (heatPump != nullptr) {
        heatPump->init();
        success = true;
      }
      break;
    }

    case PLUGIN_READ: {
      P093_data_struct *heatPump = static_cast<P093_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (heatPump != nullptr) {
        success = heatPump->read(event->String2);
      }
      break;
    }

    case PLUGIN_WRITE: {
      if (parseString(string, 1).equalsIgnoreCase(F("MitsubishiHP"))) {
        P093_data_struct *heatPump = static_cast<P093_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (heatPump != nullptr) {
          heatPump->write(parseString(string, 2), parseStringKeepCase(string, 3));
          success = true;
        }
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND: {
      P093_data_struct *heatPump = static_cast<P093_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((heatPump != nullptr) && heatPump->sync()) {
        Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 10);
      }
      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      P093_data_struct *heatPump = static_cast<P093_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (heatPump != nullptr) {
        success = heatPump->plugin_get_config_value(event, string);
      }
      break;
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P094_CULReader.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P094
# 13 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P094_CULReader.ino"
#include "src/Helpers/ESPEasy_Storage.h"
#include "src/Helpers/StringConverter.h"
#include "src/PluginStructs/P094_data_struct.h"

#include <Regexp.h>

#define PLUGIN_094 
#define PLUGIN_ID_094 94
#define PLUGIN_NAME_094 "Communication - CUL Reader"


#define P094_BAUDRATE PCONFIG_LONG(0)
#define P094_BAUDRATE_LABEL PCONFIG_LABEL(0)

#define P094_DEBUG_SENTENCE_LENGTH PCONFIG_LONG(1)
#define P094_DEBUG_SENTENCE_LABEL PCONFIG_LABEL(1)

#define P094_APPEND_RECEIVE_SYSTIME PCONFIG(0)

#define P094_QUERY_VALUE 0
#define P094_NR_OUTPUT_OPTIONS 1

#define P094_NR_OUTPUT_VALUES 1
#define P094_QUERY1_CONFIG_POS 3

#define P094_DEFAULT_BAUDRATE 38400
# 59 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P094_CULReader.ino"
boolean Plugin_094(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_094;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_STRING;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = false;
      Device[deviceCount].DuplicateDetection = true;

      Device[deviceCount].ExitTaskBeforeSave = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_094);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < P094_NR_OUTPUT_VALUES) {
          const uint8_t pconfigIndex = i + P094_QUERY1_CONFIG_POS;
          uint8_t choice = PCONFIG(pconfigIndex);
          ExtraTaskSettings.setTaskDeviceValueName(i, Plugin_094_valuename(choice, false));
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES: {
      serialHelper_getGpioNames(event, false, true);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_VALUES:
    {
      P094_data_struct *P094_data =
        static_cast<P094_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P094_data) && P094_data->isInitialized()) {
        uint32_t success, error, length_last;
        P094_data->getSentencesReceived(success, error, length_last);
        uint8_t varNr = VARS_PER_TASK;
        pluginWebformShowValue(event->TaskIndex, varNr++, F("Success"), String(success));
        pluginWebformShowValue(event->TaskIndex, varNr++, F("Error"), String(error));
        pluginWebformShowValue(event->TaskIndex, varNr++, F("Length Last"), String(length_last), true);


      }
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P094_BAUDRATE = P094_DEFAULT_BAUDRATE;
      P094_DEBUG_SENTENCE_LENGTH = 0;

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_SERIAL_PARAMS:
    {
      addFormNumericBox(F("Baudrate"), P094_BAUDRATE_LABEL, P094_BAUDRATE, 2400, 115200);
      addUnit(F("baud"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Filtering"));
      P094_html_show_matchForms(event);

      addFormSubHeader(F("Statistics"));
      P094_html_show_stats(event);

      addFormNumericBox(F("(debug) Generated length"), P094_DEBUG_SENTENCE_LABEL, P094_DEBUG_SENTENCE_LENGTH, 0, 1024);

      addFormCheckBox(F("Append system time"), F("systime"), P094_APPEND_RECEIVE_SYSTIME);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      P094_BAUDRATE = getFormItemInt(P094_BAUDRATE_LABEL);
      P094_DEBUG_SENTENCE_LENGTH = getFormItemInt(P094_DEBUG_SENTENCE_LABEL);

      P094_data_struct *P094_data =
        static_cast<P094_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P094_data) {
        for (uint8_t varNr = 0; varNr < P94_Nlines; varNr++)
        {
          P094_data->setLine(varNr, webArg(getPluginCustomArgName(varNr)));
        }

        addHtmlError(SaveCustomTaskSettings(event->TaskIndex, P094_data->_lines, P94_Nlines, 0));
        success = true;
      }

      P094_APPEND_RECEIVE_SYSTIME = isFormItemChecked(F("systime"));

      break;
    }

    case PLUGIN_INIT: {
      const int16_t serial_rx = CONFIG_PIN1;
      const int16_t serial_tx = CONFIG_PIN2;
      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P094_data_struct());
      P094_data_struct *P094_data =
        static_cast<P094_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P094_data) {
        return success;
      }

      if (P094_data->init(port, serial_rx, serial_tx, P094_BAUDRATE)) {
        LoadCustomTaskSettings(event->TaskIndex, P094_data->_lines, P94_Nlines, 0);
        P094_data->post_init();
        success = true;

        serialHelper_log_GpioDescription(port, serial_rx, serial_tx);
      } else {
        clearPluginTaskData(event->TaskIndex);
      }
      break;
    }

    case PLUGIN_FIFTY_PER_SECOND: {
      if (Settings.TaskDeviceEnabled[event->TaskIndex]) {
        P094_data_struct *P094_data =
          static_cast<P094_data_struct *>(getPluginTaskData(event->TaskIndex));

        if ((nullptr != P094_data) && P094_data->loop()) {

          delay(0);

          P094_data->getSentence(event->String2, P094_APPEND_RECEIVE_SYSTIME);

          if (event->String2.length() > 0) {
            if (Plugin_094_match_all(event->TaskIndex, event->String2)) {
              if (loglevelActiveFor(LOG_LEVEL_INFO)) {
                String log;
                if (log.reserve(128)) {
                  log = F("CUL Reader: Sending: ");
                  const size_t messageLength = event->String2.length();
                  if (messageLength < 100) {
                    log += event->String2;
                  } else {

                    log += event->String2.substring(0, 40);
                    log += F("...");
                    log += event->String2.substring(messageLength - 40);
                  }
                  addLogMove(LOG_LEVEL_INFO, log);
                }
              }




              sendData(event);
            }
          }
        }
        success = true;
      }
      break;
    }

    case PLUGIN_READ: {
      if (P094_DEBUG_SENTENCE_LENGTH > 0) {
        P094_data_struct *P094_data =
          static_cast<P094_data_struct *>(getPluginTaskData(event->TaskIndex));

        if ((nullptr != P094_data)) {
          const uint32_t debug_count = P094_data->getDebugCounter();
          event->String2.reserve(P094_DEBUG_SENTENCE_LENGTH);
          event->String2 += String(debug_count);
          event->String2 += '_';
          const char c = '0' + debug_count % 10;
          for (long i = event->String2.length(); i < P094_DEBUG_SENTENCE_LENGTH; ++i) {
            event->String2 += c;
          }
          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log = F("CUL Reader: Sending: ");
            log += event->String2.substring(0, 20);
            log += F("...");
            addLogMove(LOG_LEVEL_INFO, log);
          }

          sendData(event);
        }
      }
      break;
    }

    case PLUGIN_WRITE: {
      String cmd = parseString(string, 1);

      if (cmd.startsWith(F("culreader"))) {
        if (equals(cmd, F("culreader_write"))) {
          P094_data_struct *P094_data =
            static_cast<P094_data_struct *>(getPluginTaskData(event->TaskIndex));

          if ((nullptr != P094_data)) {
            String param1 = parseStringKeepCase(string, 2);
            parseSystemVariables(param1, false);
            P094_data->sendString(param1);
            addLogMove(LOG_LEVEL_INFO, param1);
            success = true;
          }
        }
      }


      break;
    }
  }
  return success;
}

bool Plugin_094_match_all(taskIndex_t taskIndex, const String& received)
{
  P094_data_struct *P094_data =
    static_cast<P094_data_struct *>(getPluginTaskData(taskIndex));

  if ((nullptr == P094_data)) {
    return false;
  }


  if (P094_data->disableFilterWindowActive()) {
    addLog(LOG_LEVEL_INFO, F("CUL Reader: Disable Filter Window active"));
    return true;
  }

  bool res = P094_data->parsePacket(received);

  if (P094_data->invertMatch()) {
    addLog(LOG_LEVEL_INFO, F("CUL Reader: invert filter"));
    return !res;
  }
  return res;
}

String Plugin_094_valuename(uint8_t value_nr, bool displayString) {
  switch (value_nr) {
    case P094_QUERY_VALUE: return displayString ? F("Value") : F("v");
  }
  return EMPTY_STRING;
}

void P094_html_show_matchForms(struct EventStruct *event) {
  P094_data_struct *P094_data =
    static_cast<P094_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr != P094_data)) {
    addFormNumericBox(F("Filter Off Window after send"),
                      getPluginCustomArgName(P094_FILTER_OFF_WINDOW_POS),
                      P094_data->getFilterOffWindowTime(),
                      0,
                      60000);
    addUnit(F("msec"));
    addFormNote(F("0 = Do not turn off filter after sending to the connected device."));

    {
      const __FlashStringHelper * options[P094_Match_Type_NR_ELEMENTS];
      int optionValues[P094_Match_Type_NR_ELEMENTS];

      for (int i = 0; i < P094_Match_Type_NR_ELEMENTS; ++i) {
        P094_Match_Type matchType = static_cast<P094_Match_Type>(i);
        options[i] = P094_data_struct::MatchType_toString(matchType);
        optionValues[i] = matchType;
      }
      P094_Match_Type choice = P094_data->getMatchType();
      addFormSelector(F("Filter Mode"),
                      getPluginCustomArgName(P094_MATCH_TYPE_POS),
                      P094_Match_Type_NR_ELEMENTS,
                      options,
                      optionValues,
                      choice,
                      false);
    }


    uint8_t filterSet = 0;
    uint32_t optional = 0;
    P094_Filter_Value_Type capture = P094_Filter_Value_Type::P094_packet_length;
    P094_Filter_Comp comparator = P094_Filter_Comp::P094_Equal_OR;
    String filter;

    for (uint8_t filterLine = 0; filterLine < P094_NR_FILTERS; ++filterLine)
    {

      bool newLine = (filterLine % P094_AND_FILTER_BLOCK) == 0;

      for (uint8_t filterLinePar = 0; filterLinePar < P094_ITEMS_PER_FILTER; ++filterLinePar)
      {
        String id = getPluginCustomArgName(P094_data_struct::P094_Get_filter_base_index(filterLine) + filterLinePar);

        switch (filterLinePar) {
          case 0:
          {
            filter = P094_data->getFilter(filterLine, capture, optional, comparator);

            if (newLine) {

              ++filterSet;
              addRowLabel_tr_id(concat(F("Filter "), static_cast<int>(filterSet)), id);
            } else {
              html_B(F("AND"));
              html_BR();
            }


            {
              const __FlashStringHelper * options[P094_FILTER_VALUE_Type_NR_ELEMENTS];
              int optionValues[P094_FILTER_VALUE_Type_NR_ELEMENTS];

              for (int i = 0; i < P094_FILTER_VALUE_Type_NR_ELEMENTS; ++i) {
                P094_Filter_Value_Type filterValueType = static_cast<P094_Filter_Value_Type>(i);
                options[i] = P094_data_struct::P094_FilterValueType_toString(filterValueType);
                optionValues[i] = filterValueType;
              }
              addSelector(id, P094_FILTER_VALUE_Type_NR_ELEMENTS, options, optionValues, nullptr, capture, false, true, F(""));
            }

            break;
          }
          case 1:
          {

            addNumericBox(id, optional, 0, 1024);
            break;
          }
          case 2:
          {

            const __FlashStringHelper * options[P094_FILTER_COMP_NR_ELEMENTS];
            int optionValues[P094_FILTER_COMP_NR_ELEMENTS];

            for (int i = 0; i < P094_FILTER_COMP_NR_ELEMENTS; ++i) {
              P094_Filter_Comp enumValue = static_cast<P094_Filter_Comp>(i);
              options[i] = P094_data_struct::P094_FilterComp_toString(enumValue);
              optionValues[i] = enumValue;
            }
            addSelector(id, P094_FILTER_COMP_NR_ELEMENTS, options, optionValues, nullptr, comparator, false, true, F(""));
            break;
          }
          case 3:
          {

            addTextBox(id, filter, 8, false, false, EMPTY_STRING, F(""));
            break;
          }
        }
      }
    }
  }
}

void P094_html_show_stats(struct EventStruct *event) {
  P094_data_struct *P094_data =
    static_cast<P094_data_struct *>(getPluginTaskData(event->TaskIndex));

  if ((nullptr == P094_data) || !P094_data->isInitialized()) {
    return;
  }
  {
    addRowLabel(F("Current Sentence"));
    addHtml(P094_data->peekSentence());
  }

  {
    addRowLabel(F("Sentences (pass/fail)"));
    uint32_t success, error, length_last;
    P094_data->getSentencesReceived(success, error, length_last);
    addHtmlInt(success);
    addHtml('/');
    addHtmlInt(error);
    addRowLabel(F("Length Last Sentence"));
    addHtmlInt(length_last);
  }
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P095_ILI9341.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P095





#define PLUGIN_095 
#define PLUGIN_ID_095 95
#define PLUGIN_NAME_095 "Display - TFT ILI934x/ILI948x"
#define PLUGIN_VALUENAME1_095 "CursorX"
#define PLUGIN_VALUENAME2_095 "CursorY"
#define PLUGIN_095_MAX_DISPLAY 1
# 134 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P095_ILI9341.ino"
# include "src/PluginStructs/P095_data_struct.h"


boolean Plugin_095(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_095;
      Device[deviceCount].Type = DEVICE_TYPE_SPI3;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_095);
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_095));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_095));
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("TFT CS"));
      event->String2 = formatGpioName_output(F("TFT DC"));
      event->String3 = formatGpioName_output(F("TFT RST"));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      # ifdef ESP32

      if (Settings.InitSPI == 2) {
        PIN(0) = P095_TFT_CS_HSPI;
      } else {
        PIN(0) = P095_TFT_CS;
      }
      # else
      PIN(0) = P095_TFT_CS;
      # endif
      PIN(1) = P095_TFT_DC;
      PIN(2) = P095_TFT_RST;
      P095_CONFIG_BUTTON_PIN = -1;
      P095_CONFIG_BACKLIGHT_PIN = P095_BACKLIGHT_PIN;
      P095_CONFIG_BACKLIGHT_PERCENT = 100;

      uint32_t lSettings = 0;

      set4BitToUL(lSettings, P095_CONFIG_FLAG_FONTSCALE, 1);


      P095_CONFIG_FLAGS = lSettings;

      P095_CONFIG_COLORS = ADAGFX_WHITE | (ADAGFX_BLACK << 16);

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      if (P095_CONFIG_VERSION < 2) {
        P095_CONFIG_BUTTON_PIN = -1;
        P095_CONFIG_BACKLIGHT_PIN = P095_BACKLIGHT_PIN;
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_095));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_095));
      }

      AdaGFXFormBacklight(F("backlight"), P095_CONFIG_BACKLIGHT_PIN,
                          F("backpercentage"), P095_CONFIG_BACKLIGHT_PERCENT);

      AdaGFXFormDisplayButton(F("button"), P095_CONFIG_BUTTON_PIN,
                              F("buttonInverse"), bitRead(P095_CONFIG_FLAGS, P095_CONFIG_FLAG_INVERT_BUTTON),
                              F("timer"), P095_CONFIG_DISPLAY_TIMEOUT);

      {
        const __FlashStringHelper *hardwareTypes[] = {
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9341_240x320),
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9342_240x320),
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9481_320x480),
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9481_CPT29_320x480),
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9481_PVI35_320x480),
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9481_AUO317_320x480),
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9481_CMO35_320x480),
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9481_RGB_320x480),
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9481_CMI7_320x480),
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9481_CMI8_320x480),
          # ifdef P095_ENABLE_ILI948X
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9486_320x480),
          ILI9xxx_type_toString(ILI9xxx_type_e::ILI9488_320x480),
          # endif
        };
        constexpr int hardwareOptions[] = {
          static_cast<int>(ILI9xxx_type_e::ILI9341_240x320),
          static_cast<int>(ILI9xxx_type_e::ILI9342_240x320),
          static_cast<int>(ILI9xxx_type_e::ILI9481_320x480),
          static_cast<int>(ILI9xxx_type_e::ILI9481_CPT29_320x480),
          static_cast<int>(ILI9xxx_type_e::ILI9481_PVI35_320x480),
          static_cast<int>(ILI9xxx_type_e::ILI9481_AUO317_320x480),
          static_cast<int>(ILI9xxx_type_e::ILI9481_CMO35_320x480),
          static_cast<int>(ILI9xxx_type_e::ILI9481_RGB_320x480),
          static_cast<int>(ILI9xxx_type_e::ILI9481_CMI7_320x480),
          static_cast<int>(ILI9xxx_type_e::ILI9481_CMI8_320x480),
          # ifdef P095_ENABLE_ILI948X
          static_cast<int>(ILI9xxx_type_e::ILI9486_320x480),
          static_cast<int>(ILI9xxx_type_e::ILI9488_320x480),
          # endif
        };
        addFormSelector(F("TFT display model"),
                        F("dsptype"),
                        NR_ELEMENTS(hardwareOptions),
                        hardwareTypes,
                        hardwareOptions,
                        P095_CONFIG_FLAG_GET_TYPE);
      }

      addFormCheckBox(F("Invert display"), F("invert"), P095_CONFIG_FLAG_GET_INVERTDISPLAY);

      addFormSubHeader(F("Layout"));

      AdaGFXFormRotation(F("rotate"), P095_CONFIG_ROTATION);

      AdaGFXFormTextPrintMode(F("tpmode"), P095_CONFIG_FLAG_GET_MODE);

      AdaGFXFormFontScaling(F("fontscale"), P095_CONFIG_FLAG_GET_FONTSCALE);

      # ifdef P095_SHOW_SPLASH
      addFormCheckBox(F("Show splash on start"), F("splash"), P095_CONFIG_FLAG_GET_SHOW_SPLASH);
      # endif

      addFormCheckBox(F("Clear display on exit"), F("clearOnExit"), bitRead(P095_CONFIG_FLAGS, P095_CONFIG_FLAG_CLEAR_ON_EXIT));

      {
        const __FlashStringHelper *commandTriggers[] = {
          F("tft"),
          F("ili9341"),
          F("ili9342"),
          F("ili9481"),
          # ifdef P095_ENABLE_ILI948X
          F("ili9486"),
          F("ili9488"),
          # endif
        };
        constexpr int commandTriggerOptions[] = {
          static_cast<int>(P095_CommandTrigger::tft),
          static_cast<int>(P095_CommandTrigger::ili9341),
          static_cast<int>(P095_CommandTrigger::ili9342),
          static_cast<int>(P095_CommandTrigger::ili9481),
          # ifdef P095_ENABLE_ILI948X
          static_cast<int>(P095_CommandTrigger::ili9486),
          static_cast<int>(P095_CommandTrigger::ili9488),
          # endif
        };
        addFormSelector(F("Write Command trigger"),
                        F("commandtrigger"),
                        NR_ELEMENTS(commandTriggerOptions),
                        commandTriggers,
                        commandTriggerOptions,
                        P095_CONFIG_FLAG_GET_CMD_TRIGGER);
        # ifndef LIMIT_BUILD_SIZE
        addFormNote(F("Select the command that is used to handle commands for this display."));
        # endif
      }


      addFormCheckBox(F("Wake display on receiving text"), F("NoDisplay"), !bitRead(P095_CONFIG_FLAGS, P095_CONFIG_FLAG_NO_WAKE));
      # ifndef LIMIT_BUILD_SIZE
      addFormNote(F("When checked, the display wakes up at receiving remote updates."));
      # endif

      AdaGFXFormTextColRowMode(F("colrow"), bitRead(P095_CONFIG_FLAGS, P095_CONFIG_FLAG_USE_COL_ROW) == 1);

      AdaGFXFormOnePixelCompatibilityOption(F("compat"), !bitRead(P095_CONFIG_FLAGS, P095_CONFIG_FLAG_COMPAT_P095));

      AdaGFXFormTextBackgroundFill(F("backfill"), bitRead(P095_CONFIG_FLAGS, P095_CONFIG_FLAG_BACK_FILL) == 0);

      addFormSubHeader(F("Content"));

      if (P095_CONFIG_COLORS == 0) {
        P095_CONFIG_COLORS = ADAGFX_WHITE | (ADAGFX_BLACK << 16);
      }
      AdaGFXFormForeAndBackColors(F("pfgcolor"),
                                  P095_CONFIG_GET_COLOR_FOREGROUND,
                                  F("pbgcolor"),
                                  P095_CONFIG_GET_COLOR_BACKGROUND);

      uint16_t remain = DAT_TASKS_CUSTOM_SIZE;
      {
        String strings[P095_Nlines];
        LoadCustomTaskSettings(event->TaskIndex, strings, P095_Nlines, 0);


        for (uint8_t varNr = 0; varNr < P095_Nlines; varNr++) {
          addFormTextBox(
            concat(F("Line "), varNr + 1),
            getPluginCustomArgName(varNr),
            strings[varNr],
            P095_Nchars);
          remain -= (strings[varNr].length() + 1);
        }
      }
      addUnit(concat(F("Remaining: "), remain));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P095_CONFIG_VERSION = 2;


      P095_CONFIG_ROTATION = getFormItemInt(F("rotate"));
      P095_CONFIG_BUTTON_PIN = getFormItemInt(F("button"));
      P095_CONFIG_DISPLAY_TIMEOUT = getFormItemInt(F("timer"));
      P095_CONFIG_BACKLIGHT_PIN = getFormItemInt(F("backlight"));
      P095_CONFIG_BACKLIGHT_PERCENT = getFormItemInt(F("backpercentage"));

      uint32_t lSettings = 0;
      bitWrite(lSettings, P095_CONFIG_FLAG_NO_WAKE, !isFormItemChecked(F("NoDisplay")));

      bitWrite(lSettings, P095_CONFIG_FLAG_INVERT_BUTTON, isFormItemChecked(F("buttonInverse")));
      bitWrite(lSettings, P095_CONFIG_FLAG_CLEAR_ON_EXIT, isFormItemChecked(F("clearOnExit")));
      bitWrite(lSettings, P095_CONFIG_FLAG_USE_COL_ROW, isFormItemChecked(F("colrow")));
      bitWrite(lSettings, P095_CONFIG_FLAG_COMPAT_P095, !isFormItemChecked(F("compat")));
      bitWrite(lSettings, P095_CONFIG_FLAG_BACK_FILL, !isFormItemChecked(F("backfill")));
      # ifdef P095_SHOW_SPLASH
      bitWrite(lSettings, P095_CONFIG_FLAG_SHOW_SPLASH, !isFormItemChecked(F("splash")));
      # endif
      bitWrite(lSettings, P095_CONFIG_FLAG_INVERTDISPLAY, isFormItemChecked(F("invert")));

      set4BitToUL(lSettings, P095_CONFIG_FLAG_CMD_TRIGGER, getFormItemInt(F("commandtrigger")));
      set4BitToUL(lSettings, P095_CONFIG_FLAG_FONTSCALE, getFormItemInt(F("fontscale")));
      set4BitToUL(lSettings, P095_CONFIG_FLAG_MODE, getFormItemInt(F("tpmode")));
      set4BitToUL(lSettings, P095_CONFIG_FLAG_TYPE, getFormItemInt(F("dsptype")));
      P095_CONFIG_FLAGS = lSettings;

      {
        String color = webArg(F("pfgcolor"));
        uint16_t fgcolor = ADAGFX_WHITE;

        if (!color.isEmpty()) {
          fgcolor = AdaGFXparseColor(color);
        }
        color = webArg(F("pbgcolor"));
        uint16_t bgcolor = AdaGFXparseColor(color);

        P095_CONFIG_COLORS = fgcolor | (bgcolor << 16);
      }
      {
        String strings[P095_Nlines];

        for (uint8_t varNr = 0; varNr < P095_Nlines; varNr++) {
          strings[varNr] = webArg(getPluginCustomArgName(varNr));
        }

        String error = SaveCustomTaskSettings(event->TaskIndex, strings, P095_Nlines, 0);

        if (error.length() > 0) {
          addHtmlError(error);
        }
      }

      success = true;
      break;
    }

    case PLUGIN_GET_DISPLAY_PARAMETERS:
    {
      uint16_t _x, _y;
      ILI9xxx_type_toResolution(static_cast<ILI9xxx_type_e>(P095_CONFIG_FLAG_GET_TYPE), _x, _y);

      event->Par1 = _x;
      event->Par2 = _y;
      event->Par3 = P095_CONFIG_ROTATION;
      event->Par4 = static_cast<int>(AdaGFXColorDepth::FullColor);

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      if (Settings.InitSPI != 0) {
        initPluginTaskData(event->TaskIndex,
                           new (std::nothrow) P095_data_struct(static_cast<ILI9xxx_type_e>(P095_CONFIG_FLAG_GET_TYPE),
                                                               P095_CONFIG_ROTATION,
                                                               P095_CONFIG_FLAG_GET_FONTSCALE,
                                                               static_cast<AdaGFXTextPrintMode>(P095_CONFIG_FLAG_GET_MODE),
                                                               P095_CONFIG_BACKLIGHT_PIN,
                                                               P095_CONFIG_BACKLIGHT_PERCENT,
                                                               P095_CONFIG_DISPLAY_TIMEOUT,
                                                               P095_CommandTrigger_toString(static_cast<P095_CommandTrigger>(
                                                                                              P095_CONFIG_FLAG_GET_CMD_TRIGGER)),
                                                               P095_CONFIG_GET_COLOR_FOREGROUND,
                                                               P095_CONFIG_GET_COLOR_BACKGROUND,
                                                               bitRead(P095_CONFIG_FLAGS, P095_CONFIG_FLAG_BACK_FILL) == 0));
        P095_data_struct *P095_data = static_cast<P095_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P095_data) {
          success = P095_data->plugin_init(event);
        }
      } else {
        addLog(LOG_LEVEL_ERROR, F("ILI9341: SPI not enabled, init cancelled."));
      }
      break;
    }

    case PLUGIN_EXIT:
    {
      P095_data_struct *P095_data = static_cast<P095_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P095_data) {
        success = P095_data->plugin_exit(event);
      }
      break;
    }


    case PLUGIN_FIFTY_PER_SECOND:
    {
      if (P095_CONFIG_BUTTON_PIN != -1) {
        P095_data_struct *P095_data = static_cast<P095_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P095_data) {
          P095_data->registerButtonState(digitalRead(P095_CONFIG_BUTTON_PIN), bitRead(P095_CONFIG_FLAGS, P095_CONFIG_FLAG_INVERT_BUTTON));
          success = true;
        }
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P095_data_struct *P095_data = static_cast<P095_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P095_data) {
        success = P095_data->plugin_ten_per_second(event);
      }
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P095_data_struct *P095_data = static_cast<P095_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P095_data) {
        success = P095_data->plugin_once_a_second(event);
      }
      break;
    }

    case PLUGIN_READ:
    {
      P095_data_struct *P095_data = static_cast<P095_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P095_data) {
        success = P095_data->plugin_read(event);
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P095_data_struct *P095_data = static_cast<P095_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P095_data) {
        success = P095_data->plugin_write(event, string);
      }
      break;
    }

    # if ADAGFX_ENABLE_GET_CONFIG_VALUE
    case PLUGIN_GET_CONFIG_VALUE:
    {
      P095_data_struct *P095_data = static_cast<P095_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P095_data) {
        success = P095_data->plugin_get_config_value(event, string);

      }
      break;
    }
    # endif
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P096_eInk.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P096





#define PLUGIN_096 
#define PLUGIN_ID_096 96
#define PLUGIN_NAME_096 "Display - eInk with Lolin ePaper screen"
#define PLUGIN_VALUENAME1_096 "CursorX"
#define PLUGIN_VALUENAME2_096 "CursorY"
# 107 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P096_eInk.ino"
# include "src/PluginStructs/P096_data_struct.h"







# ifndef P096_USE_ADA_GRAPHICS


void Plugin_096_printText(const char *string,
                          int X,
                          int Y,
                          unsigned int textSize = 1,
                          unsigned short color = EPD_WHITE,
                          unsigned short bkcolor = EPD_BLACK);
# endif


# ifdef ESP32


  # define EPD_CS 14
  # define EPD_CS_HSPI 26
  # define EPD_DC 27
  # define EPD_RST 33
  # define EPD_BUSY -1
# else


  # define EPD_CS 16
  # define EPD_DC 15
  # define EPD_RST -1
  # define EPD_BUSY -1
# endif
# 170 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P096_eInk.ino"
boolean Plugin_096(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_096;
      Device[deviceCount].Type = DEVICE_TYPE_SPI3;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      # if P096_USE_EXTENDED_SETTINGS
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      # else
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].TimerOption = false;
      # endif
      Device[deviceCount].SendDataOption = false;

      success = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_096);
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_096));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_096));
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("EPD CS"));
      event->String2 = formatGpioName_output(F("EPD DC"));
      event->String3 = formatGpioName_output(F("EPD RST"));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      PIN(0) = EPD_CS;
      # ifdef ESP32

      if (Settings.InitSPI == 2) {
        PIN(0) = EPD_CS_HSPI;
      }
      # endif
      PIN(1) = EPD_DC;
      PIN(2) = EPD_RST;
      PIN(3) = EPD_BUSY;
      # if P096_USE_EXTENDED_SETTINGS

      P096_CONFIG_COLORS = static_cast<uint16_t>(AdaGFXMonoRedGreyscaleColors::ADAGFXEPD_BLACK) |
                           (static_cast<uint16_t>(AdaGFXMonoRedGreyscaleColors::ADAGFXEPD_WHITE) << 16);

      uint32_t lSettings = 0;
      set4BitToUL(lSettings, P096_CONFIG_FLAG_COLORDEPTH, static_cast<uint8_t>(AdaGFXColorDepth::Monochrome));
      P096_CONFIG_FLAGS = lSettings;
      # else
      P096_CONFIG_WIDTH = 250;
      P096_CONFIG_HEIGHT = 122;
      # endif
      break;
    }

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      string = F("EPD BUSY: ");
      string += formatGpioLabel(PIN(3), false);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormPinSelect(PinSelectPurpose::Generic_output, formatGpioName_output(F("EPD BUSY")), F("_epd_busy"), PIN(3));

      # if P096_USE_EXTENDED_SETTINGS

      if (P096_CONFIG_VERSION < 2) {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_096));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_096));
      }

      {
        const __FlashStringHelper *options4[] = {
          EPD_type_toString(EPD_type_e::EPD_IL3897),
          EPD_type_toString(EPD_type_e::EPD_UC8151D),
          EPD_type_toString(EPD_type_e::EPD_SSD1680),
          # if P096_USE_WAVESHARE_2IN7
          EPD_type_toString(EPD_type_e::EPD_WS2IN7)
          # endif
        };
        const int optionValues4[] = {
          static_cast<int>(EPD_type_e::EPD_IL3897),
          static_cast<int>(EPD_type_e::EPD_UC8151D),
          static_cast<int>(EPD_type_e::EPD_SSD1680),
          # if P096_USE_WAVESHARE_2IN7
          static_cast<int>(EPD_type_e::EPD_WS2IN7)
          # endif
        };
        addFormSelector(F("eInk display model"),
                        F("_type"),
                        static_cast<int>(EPD_type_e::EPD_MAX),
                        options4,
                        optionValues4,
                        P096_CONFIG_FLAG_GET_DISPLAYTYPE);
      }

      addFormSubHeader(F("Layout"));
      # endif

      # ifdef P096_USE_ADA_GRAPHICS
      AdaGFXFormRotation(F("_rotate"), P096_CONFIG_ROTATION);
      # else
      {
        const __FlashStringHelper *options2[4] = { F("Normal"), F("+90&deg;"), F("+180&deg;"), F("+270&deg;") };
        int optionValues2[4] = { 0, 1, 2, 3 };
        addFormSelector(F("Rotation"), F("_rotate"), 4, options2, optionValues2, P096_CONFIG_ROTATION);
      }
      # endif

      # if !P096_USE_EXTENDED_SETTINGS


      uint16_t width_ = P096_CONFIG_WIDTH;

      if (width_ == 0) {
        width_ = 250;
      }
      addFormNumericBox(F("Width (px)"), F("_width"), width_, 1, 65535);

      uint16_t height_ = P096_CONFIG_HEIGHT;

      if (height_ == 0) {
        height_ = 122;
      }
      addFormNumericBox(F("Height (px)"), F("_height"), height_, 1, 65535);
      # endif

      # if P096_USE_EXTENDED_SETTINGS
      {
        const __FlashStringHelper *colorDepths[] = {
          toString(AdaGFXColorDepth::Monochrome),
          toString(AdaGFXColorDepth::BlackWhiteRed),
          toString(AdaGFXColorDepth::BlackWhite2Greyscales),
          # if ADAGFX_SUPPORT_7COLOR
          toString(AdaGFXColorDepth::SevenColor)
          # endif
        };
        const int colorDepthOptions[] = {
          static_cast<int>(AdaGFXColorDepth::Monochrome),
          static_cast<int>(AdaGFXColorDepth::BlackWhiteRed),
          static_cast<int>(AdaGFXColorDepth::BlackWhite2Greyscales),
          # if ADAGFX_SUPPORT_7COLOR
          static_cast<int>(AdaGFXColorDepth::SevenColor)
          # endif
        };

        if (P096_CONFIG_FLAG_GET_COLORDEPTH == 0) {
          uint32_t lSettings = 0;
          set4BitToUL(lSettings, P096_CONFIG_FLAG_COLORDEPTH, static_cast<uint8_t>(AdaGFXColorDepth::Monochrome));
          P096_CONFIG_FLAGS = lSettings;
        }
        addFormSelector(F("Greyscale levels"),
                        F("_colorDepth"),
                        ADAGFX_MONOCOLORS_COUNT,
                        colorDepths,
                        colorDepthOptions,
                        P096_CONFIG_FLAG_GET_COLORDEPTH);
      }

      AdaGFXFormTextPrintMode(F("_mode"), P096_CONFIG_FLAG_GET_MODE);

      AdaGFXFormFontScaling(F("_fontscale"), P096_CONFIG_FLAG_GET_FONTSCALE);

      {
        const __FlashStringHelper *commandTriggers[] = {
          P096_CommandTrigger_toString(P096_CommandTrigger::epd),
          P096_CommandTrigger_toString(P096_CommandTrigger::eInk),
          P096_CommandTrigger_toString(P096_CommandTrigger::ePaper),
          P096_CommandTrigger_toString(P096_CommandTrigger::il3897),
          P096_CommandTrigger_toString(P096_CommandTrigger::uc8151d),
          P096_CommandTrigger_toString(P096_CommandTrigger::ssd1680),
          # if P096_USE_WAVESHARE_2IN7
          P096_CommandTrigger_toString(P096_CommandTrigger::ws2in7)
          # endif
        };
        const int commandTriggerOptions[] = {
          static_cast<int>(P096_CommandTrigger::epd),
          static_cast<int>(P096_CommandTrigger::eInk),
          static_cast<int>(P096_CommandTrigger::ePaper),
          static_cast<int>(P096_CommandTrigger::il3897),
          static_cast<int>(P096_CommandTrigger::uc8151d),
          static_cast<int>(P096_CommandTrigger::ssd1680),
          # if P096_USE_WAVESHARE_2IN7
          static_cast<int>(P096_CommandTrigger::ws2in7)
          # endif
        };
        addFormSelector(F("Write Command trigger"),
                        F("_commandtrigger"),
                        static_cast<int>(P096_CommandTrigger::MAX),
                        commandTriggers,
                        commandTriggerOptions,
                        P096_CONFIG_FLAG_GET_CMD_TRIGGER);
        addFormNote(F("Select the command that is used to handle commands for this display."));
      }

      AdaGFXFormTextColRowMode(F("_colrow"), bitRead(P096_CONFIG_FLAGS, P096_CONFIG_FLAG_USE_COL_ROW) == 1);

      AdaGFXFormOnePixelCompatibilityOption(F("_compat"), !bitRead(P096_CONFIG_FLAGS, P096_CONFIG_FLAG_COMPAT_P096));

      AdaGFXFormTextBackgroundFill(F("_backfill"), bitRead(P096_CONFIG_FLAGS, P096_CONFIG_FLAG_BACK_FILL) == 0);

      addFormSubHeader(F("Content"));

      if (P096_CONFIG_COLORS == 0) {
        P096_CONFIG_COLORS = static_cast<uint16_t>(AdaGFXMonoRedGreyscaleColors::ADAGFXEPD_WHITE) |
                             (static_cast<uint16_t>(AdaGFXMonoRedGreyscaleColors::ADAGFXEPD_BLACK) << 16);
      }
      AdaGFXFormForeAndBackColors(F("_foregroundcolor"),
                                  P096_CONFIG_GET_COLOR_FOREGROUND,
                                  F("_backgroundcolor"),
                                  P096_CONFIG_GET_COLOR_BACKGROUND,
                                  static_cast<AdaGFXColorDepth>(P096_CONFIG_FLAG_GET_COLORDEPTH));

      String strings[P096_Nlines];
      LoadCustomTaskSettings(event->TaskIndex, strings, P096_Nlines, 0);

      uint16_t remain = DAT_TASKS_CUSTOM_SIZE;

      for (uint8_t varNr = 0; varNr < P096_Nlines; varNr++) {
        addFormTextBox(concat(F("Line "), (varNr + 1)), getPluginCustomArgName(varNr), strings[varNr], P096_Nchars);
        remain -= (strings[varNr].length() + 1);
      }
      addUnit(concat(F("Remaining: "), remain));

      # endif

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      # if P096_USE_EXTENDED_SETTINGS
      P096_CONFIG_VERSION = 2;
      # else
      P096_CONFIG_VERSION = 1;
      # endif


      PIN(3) = getFormItemInt(F("_epd_busy"));
      P096_CONFIG_ROTATION = getFormItemInt(F("_rotate"));
      # if !P096_USE_EXTENDED_SETTINGS
      P096_CONFIG_WIDTH = getFormItemInt(F("_width"));
      P096_CONFIG_HEIGHT = getFormItemInt(F("_height"));
      # endif

      # if P096_USE_EXTENDED_SETTINGS

      uint32_t lSettings = 0;

      bitWrite(lSettings, P096_CONFIG_FLAG_USE_COL_ROW, isFormItemChecked(F("_colrow")));
      bitWrite(lSettings, P096_CONFIG_FLAG_COMPAT_P096, !isFormItemChecked(F("_compat")));
      bitWrite(lSettings, P096_CONFIG_FLAG_BACK_FILL, !isFormItemChecked(F("_backfill")));

      set4BitToUL(lSettings, P096_CONFIG_FLAG_CMD_TRIGGER, getFormItemInt(F("_commandtrigger")));
      set4BitToUL(lSettings, P096_CONFIG_FLAG_FONTSCALE, getFormItemInt(F("_fontscale")));
      set4BitToUL(lSettings, P096_CONFIG_FLAG_MODE, getFormItemInt(F("_mode")));
      set4BitToUL(lSettings, P096_CONFIG_FLAG_COLORDEPTH, getFormItemInt(F("_colorDepth")));
      set4BitToUL(lSettings, P096_CONFIG_FLAG_DISPLAYTYPE, getFormItemInt(F("_type")));

      P096_CONFIG_FLAGS = lSettings;

      String color = webArg(F("_foregroundcolor"));
      uint16_t fgcolor = static_cast<uint16_t>(AdaGFXMonoRedGreyscaleColors::ADAGFXEPD_BLACK);

      if (!color.isEmpty()) {
        fgcolor = AdaGFXparseColor(color, static_cast<AdaGFXColorDepth>(P096_CONFIG_FLAG_GET_COLORDEPTH));
      }
      color = webArg(F("_backgroundcolor"));
      uint16_t bgcolor = AdaGFXparseColor(color, static_cast<AdaGFXColorDepth>(P096_CONFIG_FLAG_GET_COLORDEPTH));

      P096_CONFIG_COLORS = fgcolor | (bgcolor << 16);

      String strings[P096_Nlines];

      for (uint8_t varNr = 0; varNr < P096_Nlines; varNr++) {
        strings[varNr] = webArg(getPluginCustomArgName(varNr));
      }

      const String error = SaveCustomTaskSettings(event->TaskIndex, strings, P096_Nlines, 0);

      if (error.length() > 0) {
        addHtmlError(error);
      }
      # endif

      success = true;
      break;
    }

    case PLUGIN_GET_DISPLAY_PARAMETERS:
    {
      # if P096_USE_EXTENDED_SETTINGS
      uint16_t x, y;
      EPD_type_toResolution(static_cast<EPD_type_e>(P096_CONFIG_FLAG_GET_DISPLAYTYPE), x, y);
      event->Par1 = x;
      event->Par2 = y;
      event->Par4 = P096_CONFIG_FLAG_GET_COLORDEPTH;
      # else
      event->Par1 = P096_CONFIG_WIDTH;
      event->Par2 = P096_CONFIG_HEIGHT;
      event->Par4 = static_cast<int>(AdaGFXColorDepth::Monochrome);
      # endif
      event->Par3 = P096_CONFIG_ROTATION;

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      if (Settings.InitSPI != 0) {
        initPluginTaskData(event->TaskIndex,
                           # if P096_USE_EXTENDED_SETTINGS
                           new (std::nothrow) P096_data_struct(static_cast<EPD_type_e>(P096_CONFIG_FLAG_GET_DISPLAYTYPE),
                                                               P096_CONFIG_ROTATION,
                                                               P096_CONFIG_FLAG_GET_FONTSCALE,
                                                               static_cast<AdaGFXTextPrintMode>(P096_CONFIG_FLAG_GET_MODE),
                                                               P096_CommandTrigger_toString(static_cast<P096_CommandTrigger>(
                                                                                              P096_CONFIG_FLAG_GET_CMD_TRIGGER)),
                                                               P096_CONFIG_GET_COLOR_FOREGROUND,
                                                               P096_CONFIG_GET_COLOR_BACKGROUND,
                                                               static_cast<AdaGFXColorDepth>(P096_CONFIG_FLAG_GET_COLORDEPTH),
                                                               bitRead(P096_CONFIG_FLAGS, P096_CONFIG_FLAG_BACK_FILL) == 0)
                           # else
                           new (std::nothrow) P096_data_struct(static_cast<EPD_type_e>(P096_CONFIG_FLAG_GET_DISPLAYTYPE),
                                                               P096_CONFIG_WIDTH,
                                                               P096_CONFIG_HEIGHT,
                                                               P096_CONFIG_ROTATION,
                                                               P096_CONFIG_FLAG_GET_FONTSCALE,
                                                               AdaGFXTextPrintMode::ContinueToNextLine,
                                                               F("epd"))
                           # endif
                           );
        P096_data_struct *P096_data = static_cast<P096_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P096_data) {
          success = P096_data->plugin_init(event);
        }
      } else {
        addLog(LOG_LEVEL_ERROR, F("EPD  : SPI not enabled, init cancelled."));
      }

      break;
    }

    case PLUGIN_EXIT:
    {
      P096_data_struct *P096_data = static_cast<P096_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P096_data) {
        success = P096_data->plugin_exit(event);
      }
      break;
    }

    case PLUGIN_READ:
    {
      P096_data_struct *P096_data = static_cast<P096_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P096_data) {
        success = P096_data->plugin_read(event);
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P096_data_struct *P096_data = static_cast<P096_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P096_data) {
        success = P096_data->plugin_write(event, string);
      }
      break;
    }

  }

  return success;
}

# ifndef P096_USE_ADA_GRAPHICS
# 587 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P096_eInk.ino"
void Plugin_096_printText(const char *string, int X, int Y, unsigned int textSize, unsigned short color, unsigned short bkcolor)
{
  eInkScreen->clearBuffer();
  eInkScreen->clearDisplay();
  eInkScreen->setCursor(X, Y);
  eInkScreen->setTextColor(color, bkcolor);
  eInkScreen->setTextSize(textSize);
  String fixString = string;

  Plugin_096_FixText(fixString);
  eInkScreen->println(fixString);
  eInkScreen->display();
}

# endif




unsigned short Plugin_096_ParseColor(const String& colorString)
{


  String s = colorString;

  s.toLowerCase();

  if (equals(s, F("black"))) {
    return EPD_BLACK;
  }

  if (equals(s, F("white"))) {
    return EPD_WHITE;
  }

  if (equals(s, F("inverse"))) {
    return EPD_INVERSE;
  }

  if (equals(s, F("red"))) {
    return EPD_RED;
  }

  if (equals(s, F("dark"))) {
    return EPD_DARK;
  }

  if (equals(s, F("light"))) {
    return EPD_LIGHT;
  }
  return EPD_WHITE;
}

# ifndef P096_USE_ADA_GRAPHICS




void Plugin_096_FixText(String& s)
{
  const char degree[3] = { 0xc2, 0xb0, 0 };
  const char degree_eink[2] = { 0xf7, 0 };

  s.replace(degree, degree_eink);
  s.replace(F("{D}"), degree_eink);
  s.replace(F("&deg;"), degree_eink);

  const char euro[4] = { 0xe2, 0x82, 0xac, 0 };
  const char euro_eink[2] = { 0xED, 0 };

  s.replace(euro, euro_eink);
  s.replace(F("{E}"), euro_eink);
  s.replace(F("&euro;"), euro_eink);

  const char pound[3] = { 0xc2, 0xa3, 0 };
  const char pound_eink[2] = { 0x9C, 0 };

  s.replace(pound, pound_eink);
  s.replace(F("{P}"), pound_eink);
  s.replace(F("&pound;"), pound_eink);

  const char yen[3] = { 0xc2, 0xa5, 0 };
  const char yen_eink[2] = { 0x9D, 0 };

  s.replace(yen, yen_eink);
  s.replace(F("{Y}"), yen_eink);
  s.replace(F("&yen;"), yen_eink);

  const char cent[3] = { 0xc2, 0xa2, 0 };
  const char cent_eink[2] = { 0x9B, 0 };

  s.replace(cent, cent_eink);
  s.replace(F("{c}"), cent_eink);
  s.replace(F("&cent;"), cent_eink);
}







int Plugin_096_StringSplit(const String& s, char c, String op[], int limit)
{
  int count = 0;
  char *pch;
  String d = String(c);

  pch = strtok((char *)(s.c_str()), d.c_str());

  while (pch != NULL && count < limit)
  {
    op[count] = String(pch);
    count++;
    pch = strtok(NULL, ",");
  }
  return count;
}

# endif

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P097_Esp32Touch.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P097






#if defined(ESP32) && !defined(ESP32C2) && !defined(ESP32C3) && !defined(ESP32C6)

#ifdef ESP32_CLASSIC
  # define HAS_T0_INPUT 1
  # define HAS_T10_TO_T14 0
  # define LAST_TOUCH_INPUT_INDEX 10
#endif
#if defined(ESP32S2) || defined(ESP32S3)
  # define HAS_T0_INPUT 0
  # define HAS_T10_TO_T14 1
  # define LAST_TOUCH_INPUT_INDEX 15

#endif



#define PLUGIN_097 
#define PLUGIN_ID_097 97
#define PLUGIN_NAME_097 "Touch (ESP32) - internal"
#define PLUGIN_VALUENAME1_097 "Touch"


# ifdef ESP32
  # define P097_MAX_ADC_VALUE 4095
# endif
# ifdef ESP8266
  # define P097_MAX_ADC_VALUE 1023
# endif


#define P097_SEND_TOUCH_EVENT PCONFIG(0)
#define P097_SEND_RELEASE_EVENT PCONFIG(1)
#define P097_SEND_DURATION_EVENT PCONFIG(2)
#define P097_TOUCH_THRESHOLD PCONFIG(3)


DRAM_ATTR uint32_t p097_pinTouched = 0;
DRAM_ATTR uint32_t p097_pinTouchedPrev = 0;
DRAM_ATTR uint32_t p097_timestamp[LAST_TOUCH_INPUT_INDEX] = { 0 };

boolean Plugin_097(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_097;
      Device[deviceCount].Type = DEVICE_TYPE_ANALOG;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].DecimalsOnly = false;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_097);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_097));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P097_SEND_TOUCH_EVENT = 1;
      P097_SEND_DURATION_EVENT = 1;
      P097_TOUCH_THRESHOLD = 20;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addRowLabel(F("Analog Pin"));
      addADC_PinSelect(AdcPinSelectPurpose::TouchOnly, F("taskdevicepin1"), CONFIG_PIN1);

      addFormSubHeader(F("Touch Settings"));

      addFormCheckBox(F("Send Touch Event"), F("sendtouch"), P097_SEND_TOUCH_EVENT);
      addFormCheckBox(F("Send Release Event"), F("sendrelease"), P097_SEND_RELEASE_EVENT);
      addFormCheckBox(F("Send Duration Event"), F("sendduration"), P097_SEND_DURATION_EVENT);
      addFormNumericBox(F("Touch Threshold"), F("threshold"), P097_TOUCH_THRESHOLD, 0, P097_MAX_ADC_VALUE);


      addRowLabel(F("Current Pressure"));
      addHtml(String(touchRead(CONFIG_PIN1)));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P097_SEND_TOUCH_EVENT = isFormItemChecked(F("sendtouch"));
      P097_SEND_RELEASE_EVENT = isFormItemChecked(F("sendrelease"));
      P097_SEND_DURATION_EVENT = isFormItemChecked(F("sendduration"));
      P097_TOUCH_THRESHOLD = getFormItemInt(F("threshold"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      P097_setEventParams(CONFIG_PIN1, P097_TOUCH_THRESHOLD);
      success = true;
      break;
    }
    case PLUGIN_TEN_PER_SECOND:
    {
      if ((p097_pinTouched != 0) || (p097_pinTouchedPrev != 0)) {


        int adc, ch, t;

        if (getADC_gpio_info(CONFIG_PIN1, adc, ch, t)) {
          const bool touched = bitRead(p097_pinTouched, t);
          const bool touched_prev = bitRead(p097_pinTouchedPrev, t);

          if (touched) {
            bitClear(p097_pinTouched, t);
          }

          if (touched != touched_prev) {

            UserVar.setFloat(event->TaskIndex, 0, touchRead(CONFIG_PIN1));

            if (touched) {
              if (P097_SEND_TOUCH_EVENT) {

                Scheduler.schedule_task_device_timer(event->TaskIndex, millis());
              }
              bitSet(p097_pinTouchedPrev, t);
            } else {
              if (P097_SEND_RELEASE_EVENT) {

                Scheduler.schedule_task_device_timer(event->TaskIndex, millis());
              }

              if (P097_SEND_DURATION_EVENT) {
                if (Settings.UseRules) {
                  eventQueue.add(event->TaskIndex, F("Duration"), timePassedSince(p097_timestamp[t]));
                }
              }
              bitClear(p097_pinTouchedPrev, t);
              p097_timestamp[t] = 0;
            }
          }
        }
      }
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      int raw_value = touchRead(CONFIG_PIN1);
      UserVar.setFloat(event->TaskIndex, 0, raw_value);

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log = F("Touch : ");
        log += formatGpioName_ADC(CONFIG_PIN1);
        log += F(": ");
        log += raw_value;
        addLogMove(LOG_LEVEL_INFO, log);
      }
      success = true;
      break;
    }
  }
  return success;
}




void P097_setEventParams(int pin, uint16_t threshold) {
  int adc, ch, t;

  if (getADC_gpio_info(pin, adc, ch, t)) {
    switch (t) {
#if HAS_T0_INPUT
      case 0: touchAttachInterrupt(T0, P097_got_T0, threshold); break;
#endif
      case 1: touchAttachInterrupt(T1, P097_got_T1, threshold); break;
      case 2: touchAttachInterrupt(T2, P097_got_T2, threshold); break;
      case 3: touchAttachInterrupt(T3, P097_got_T3, threshold); break;
      case 4: touchAttachInterrupt(T4, P097_got_T4, threshold); break;
      case 5: touchAttachInterrupt(T5, P097_got_T5, threshold); break;
      case 6: touchAttachInterrupt(T6, P097_got_T6, threshold); break;
      case 7: touchAttachInterrupt(T7, P097_got_T7, threshold); break;
      case 8: touchAttachInterrupt(T8, P097_got_T8, threshold); break;
      case 9: touchAttachInterrupt(T9, P097_got_T9, threshold); break;
#if HAS_T10_TO_T14







#endif
    }
  }
}

#if HAS_T0_INPUT
void P097_got_T0() IRAM_ATTR;
#endif
void P097_got_T1() IRAM_ATTR;
void P097_got_T2() IRAM_ATTR;
void P097_got_T3() IRAM_ATTR;
void P097_got_T4() IRAM_ATTR;
void P097_got_T5() IRAM_ATTR;
void P097_got_T6() IRAM_ATTR;
void P097_got_T7() IRAM_ATTR;
void P097_got_T8() IRAM_ATTR;
void P097_got_T9() IRAM_ATTR;
#if HAS_T10_TO_T14
void P097_got_T10() IRAM_ATTR;
void P097_got_T11() IRAM_ATTR;
void P097_got_T12() IRAM_ATTR;
void P097_got_T13() IRAM_ATTR;
void P097_got_T14() IRAM_ATTR;
#endif

#if HAS_T0_INPUT
void P097_got_T0() {
  bitSet(p097_pinTouched, 0);

  if (p097_timestamp[0] == 0) { p097_timestamp[0] = millis(); }
}
#endif

void P097_got_T1() {
  bitSet(p097_pinTouched, 1);

  if (p097_timestamp[1] == 0) { p097_timestamp[1] = millis(); }
}

void P097_got_T2() {
  bitSet(p097_pinTouched, 2);

  if (p097_timestamp[2] == 0) { p097_timestamp[2] = millis(); }
}

void P097_got_T3() {
  bitSet(p097_pinTouched, 3);

  if (p097_timestamp[3] == 0) { p097_timestamp[3] = millis(); }
}

void P097_got_T4() {
  bitSet(p097_pinTouched, 4);

  if (p097_timestamp[4] == 0) { p097_timestamp[4] = millis(); }
}

void P097_got_T5() {
  bitSet(p097_pinTouched, 5);

  if (p097_timestamp[5] == 0) { p097_timestamp[5] = millis(); }
}

void P097_got_T6() {
  bitSet(p097_pinTouched, 6);

  if (p097_timestamp[6] == 0) { p097_timestamp[6] = millis(); }
}

void P097_got_T7() {
  bitSet(p097_pinTouched, 7);

  if (p097_timestamp[7] == 0) { p097_timestamp[7] = millis(); }
}

void P097_got_T8() {
  bitSet(p097_pinTouched, 8);

  if (p097_timestamp[8] == 0) { p097_timestamp[8] = millis(); }
}

void P097_got_T9() {
  bitSet(p097_pinTouched, 9);

  if (p097_timestamp[9] == 0) { p097_timestamp[9] = millis(); }
}

#if HAS_T10_TO_T14
void P097_got_T10() {
  bitSet(p097_pinTouched, 10);

  if (p097_timestamp[10] == 0) { p097_timestamp[10] = millis(); }
}

void P097_got_T11() {
  bitSet(p097_pinTouched, 11);

  if (p097_timestamp[11] == 0) { p097_timestamp[11] = millis(); }
}

void P097_got_T12() {
  bitSet(p097_pinTouched, 12);

  if (p097_timestamp[12] == 0) { p097_timestamp[12] = millis(); }
}

void P097_got_T13() {
  bitSet(p097_pinTouched, 13);

  if (p097_timestamp[13] == 0) { p097_timestamp[13] = millis(); }
}

void P097_got_T14() {
  bitSet(p097_pinTouched, 14);

  if (p097_timestamp[14] == 0) { p097_timestamp[14] = millis(); }
}

#endif

#endif


#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P098_PWM_motor.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P098






# include "src/PluginStructs/P098_data_struct.h"

#define PLUGIN_098 
#define PLUGIN_ID_098 98
#define PLUGIN_NAME_098 "Motor - PWM Motor"
#define PLUGIN_VALUENAME1_098 "Position"
#define PLUGIN_VALUENAME2_098 "LimitA"
#define PLUGIN_VALUENAME3_098 "LimitB"
#define PLUGIN_VALUENAME4_098 "LimitApos"


#define P098_PWM_FREQ PCONFIG_LONG(0)
#define P098_FLAGS PCONFIG_LONG(1)
#define P098_LIMIT_SWA_GPIO PCONFIG(0)
#define P098_LIMIT_SWB_GPIO PCONFIG(1)
#define P098_MOTOR_CONTROL PCONFIG(2)
# ifdef ESP32
#define P098_ANALOG_GPIO PCONFIG(3)
# endif
#define P098_LIMIT_SWA_DEBOUNCE PCONFIG(4)
#define P098_LIMIT_SWB_DEBOUNCE PCONFIG(5)
#define P098_ENC_TIMEOUT PCONFIG(6)
#define P098_PWM_DUTY PCONFIG(7)
#define P098_VIRTUAL_SPEED PCONFIG_LONG(2)
#define P098_POS_0_SUPPLEMENT PCONFIG_LONG(3)


#define P098_FLAGBIT_LIM_A_PULLUP 0
#define P098_FLAGBIT_LIM_B_PULLUP 1
#define P098_FLAGBIT_ENC_IN_PULLUP 2
#define P098_FLAGBIT_LIM_A_INVERTED 3
#define P098_FLAGBIT_LIM_B_INVERTED 4
#define P098_FLAGBIT_MOTOR_FWD_INVERTED 5
#define P098_FLAGBIT_MOTOR_REV_INVERTED 6
#define P098_FLAGBIT_PWM_SOFT_STARTSTOP 7


boolean Plugin_098(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_098;
      Device[deviceCount].Type = DEVICE_TYPE_CUSTOM0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_098);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_098));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_098));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_098));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_098));
      break;
    }

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      const __FlashStringHelper *labels[] = {
        F("M Fwd"),
        F("M Rev"),
        F("Enc"),
        # ifdef ESP32
        F("Analog"),
        # endif
        F("Lim A"),
        F("Lim B")
      };
      int values[] = {
        CONFIG_PIN1,
        CONFIG_PIN2,
        CONFIG_PIN3,
        # ifdef ESP32
        P098_ANALOG_GPIO,
        # endif
        P098_LIMIT_SWA_GPIO,
        P098_LIMIT_SWB_GPIO
      };
      constexpr size_t nrElements = sizeof(values) / sizeof(values[0]);

      for (size_t i = 0; i < nrElements; ++i) {
        if (i != 0) { addHtml(event->String1); }
        addHtml(labels[i]);
        addHtml(F(":&nbsp;"));
        addHtml(formatGpioLabel(values[i], true));
      }

      success = true;
      break;
    }
# 137 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P098_PWM_motor.ino"
    case PLUGIN_SET_DEFAULTS:
    {
      P098_FLAGS = 0;
      P098_LIMIT_SWA_GPIO = -1;
      P098_LIMIT_SWB_GPIO = -1;
      P098_LIMIT_SWA_DEBOUNCE = 100;
      P098_LIMIT_SWB_DEBOUNCE = 100;
      P098_ENC_TIMEOUT = 100;
      P098_VIRTUAL_SPEED = 0;
      P098_POS_0_SUPPLEMENT = 0;
      P098_MOTOR_CONTROL = 0;
      P098_PWM_FREQ = 1000;
      P098_PWM_DUTY = 1023;
      # ifdef ESP32
      P098_ANALOG_GPIO = -1;
      # endif

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Motor Control"));


      addFormPinSelect(PinSelectPurpose::Generic_output,
                       formatGpioName_output(F("Motor Fwd")),
                       F("taskdevicepin1"),
                       CONFIG_PIN1);
      addFormCheckBox(F("Motor Fwd Inverted"), F("fwd_inv"), bitRead(P098_FLAGS, P098_FLAGBIT_MOTOR_FWD_INVERTED));

      addFormSeparator(2);

      addFormPinSelect(PinSelectPurpose::Generic_output,
                       formatGpioName_output(F("Motor Rev")),
                       F("taskdevicepin2"),
                       CONFIG_PIN2);
      addFormCheckBox(F("Motor Rev Inverted"), F("rev_inv"), bitRead(P098_FLAGS, P098_FLAGBIT_MOTOR_REV_INVERTED));

      addFormSeparator(2);

      {
        # define P098_PWM_MODE_TYPES static_cast<int>(P098_config_struct::PWM_mode_type::MAX_TYPE)
        const __FlashStringHelper *options[P098_PWM_MODE_TYPES];
        int optionValues[P098_PWM_MODE_TYPES];

        for (int i = 0; i < P098_PWM_MODE_TYPES; ++i) {
          options[i] = P098_config_struct::toString(static_cast<P098_config_struct::PWM_mode_type>(i));
          optionValues[i] = i;
        }
        addFormSelector(F("Motor Control"), F("motor_contr"), P098_PWM_MODE_TYPES, options, optionValues, P098_MOTOR_CONTROL);
      }
      addFormNumericBox(F("PWM Frequency"), F("pwm_freq"), P098_PWM_FREQ, 50, 100000);
      addUnit(F("Hz"));
      addFormNumericBox(F("PWM Duty Cycle"), F("pwm_duty"), P098_PWM_DUTY, 0, 1023);
      addFormCheckBox(F("PWM Soft Start/Stop"), F("pwm_soft_st"), bitRead(P098_FLAGS, P098_FLAGBIT_PWM_SOFT_STARTSTOP));


      addFormSubHeader(F("Feedback"));

      addFormPinSelect(PinSelectPurpose::Generic_input,
                       formatGpioName_input_optional(F("Encoder")),
                       F("taskdevicepin3"),
                       CONFIG_PIN3);
      addFormCheckBox(F("Encoder Pull-Up"), F("enc_pu"), bitRead(P098_FLAGS, P098_FLAGBIT_ENC_IN_PULLUP));
      addFormNumericBox(F("Encoder Timeout"), F("enc_timeout"), P098_ENC_TIMEOUT, 0, 1000);
      addUnit(F("ms"));

      addFormNumericBox(F("Virtual speed"), F("virtual_speed"), P098_VIRTUAL_SPEED, 0, 2147483647);
      addUnit(F("steps/ms"));

      addFormNumericBox(F("Position 0 Supplement"), F("pos0_supplement"), P098_POS_0_SUPPLEMENT, -2147483648, 2147483647);
      addUnit(F("steps"));


      # ifdef ESP32
      {
        addRowLabel(formatGpioName_input_optional(F("Analog Feedback")));
        addADC_PinSelect(AdcPinSelectPurpose::ADC_Touch_Optional, F("analogpin"), P098_ANALOG_GPIO);
      }
      # endif

      addFormSubHeader(F("Limit Switches"));

      addFormPinSelect(PinSelectPurpose::Generic_input,
                       formatGpioName_input_optional(F("Limit A")),
                       F("limit_a"),
                       P098_LIMIT_SWA_GPIO);
      addFormCheckBox(F("Limit A Pull-Up"), F("limit_a_pu"), bitRead(P098_FLAGS, P098_FLAGBIT_LIM_A_PULLUP));
      addFormCheckBox(F("Limit A Inverted"), F("limit_a_inv"), bitRead(P098_FLAGS, P098_FLAGBIT_LIM_A_INVERTED));
      addFormNumericBox(F("Limit A Debounce"), F("limit_a_debounce"), P098_LIMIT_SWA_DEBOUNCE, 0, 1000);
      addUnit(F("ms"));

      addFormSeparator(2);

      addFormPinSelect(PinSelectPurpose::Generic_input,
                       formatGpioName_input_optional(F("Limit B")),
                       F("limit_b"),
                       P098_LIMIT_SWB_GPIO);
      addFormCheckBox(F("Limit B Pull-Up"), F("limit_b_pu"), bitRead(P098_FLAGS, P098_FLAGBIT_LIM_B_PULLUP));
      addFormCheckBox(F("Limit B Inverted"), F("limit_b_inv"), bitRead(P098_FLAGS, P098_FLAGBIT_LIM_B_INVERTED));
      addFormNumericBox(F("Limit B Debounce"), F("limit_b_debounce"), P098_LIMIT_SWB_DEBOUNCE, 0, 1000);
      addUnit(F("ms"));


      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {

      CONFIG_PIN1 = getFormItemInt(F("taskdevicepin1"));
      CONFIG_PIN2 = getFormItemInt(F("taskdevicepin2"));
      CONFIG_PIN3 = getFormItemInt(F("taskdevicepin3"));

      P098_ENC_TIMEOUT = getFormItemInt(F("enc_timeout"));
      P098_VIRTUAL_SPEED = getFormItemInt(F("virtual_speed"));
      P098_POS_0_SUPPLEMENT = getFormItemInt(F("pos0_supplement"));

      P098_LIMIT_SWA_GPIO = getFormItemInt(F("limit_a"));
      P098_LIMIT_SWB_GPIO = getFormItemInt(F("limit_b"));
      P098_LIMIT_SWA_DEBOUNCE = getFormItemInt(F("limit_a_debounce"));
      P098_LIMIT_SWB_DEBOUNCE = getFormItemInt(F("limit_b_debounce"));

      P098_MOTOR_CONTROL = getFormItemInt(F("motor_contr"));
      P098_PWM_FREQ = getFormItemInt(F("pwm_freq"));
      P098_PWM_DUTY = getFormItemInt(F("pwm_duty"));
      # ifdef ESP32
      P098_ANALOG_GPIO = getFormItemInt(F("analogpin"));
      # endif

      P098_FLAGS = 0;

      if (isFormItemChecked(F("fwd_inv"))) { bitSet(P098_FLAGS, P098_FLAGBIT_MOTOR_FWD_INVERTED); }

      if (isFormItemChecked(F("rev_inv"))) { bitSet(P098_FLAGS, P098_FLAGBIT_MOTOR_REV_INVERTED); }

      if (isFormItemChecked(F("pwm_soft_st"))) { bitSet(P098_FLAGS, P098_FLAGBIT_PWM_SOFT_STARTSTOP); }

      if (isFormItemChecked(F("enc_pu"))) { bitSet(P098_FLAGS, P098_FLAGBIT_ENC_IN_PULLUP); }

      if (isFormItemChecked(F("limit_a_pu"))) { bitSet(P098_FLAGS, P098_FLAGBIT_LIM_A_PULLUP); }

      if (isFormItemChecked(F("limit_b_pu"))) { bitSet(P098_FLAGS, P098_FLAGBIT_LIM_B_PULLUP); }

      if (isFormItemChecked(F("limit_a_inv"))) { bitSet(P098_FLAGS, P098_FLAGBIT_LIM_A_INVERTED); }

      if (isFormItemChecked(F("limit_b_inv"))) { bitSet(P098_FLAGS, P098_FLAGBIT_LIM_B_INVERTED); }

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      P098_config_struct config;
      config.motorFwd.gpio = CONFIG_PIN1;
      config.motorRev.gpio = CONFIG_PIN2;
      config.encoder.gpio = CONFIG_PIN3;
      config.encoder.timer_us = P098_ENC_TIMEOUT * 1000;
      config.virtualSpeed = P098_VIRTUAL_SPEED;
      config.pos0supplement = P098_POS_0_SUPPLEMENT;
      config.limitA.gpio = P098_LIMIT_SWA_GPIO;
      config.limitB.gpio = P098_LIMIT_SWB_GPIO;
      config.limitA.timer_us = P098_LIMIT_SWA_DEBOUNCE * 1000;
      config.limitB.timer_us = P098_LIMIT_SWB_DEBOUNCE * 1000;
      # ifdef ESP32
      config.gpio_analogIn = P098_ANALOG_GPIO;
      # endif
      config.motorFwd.inverted = bitRead(P098_FLAGS, P098_FLAGBIT_MOTOR_FWD_INVERTED);
      config.motorRev.inverted = bitRead(P098_FLAGS, P098_FLAGBIT_MOTOR_REV_INVERTED);
      config.limitA.inverted = bitRead(P098_FLAGS, P098_FLAGBIT_LIM_A_INVERTED);
      config.limitB.inverted = bitRead(P098_FLAGS, P098_FLAGBIT_LIM_B_INVERTED);
      config.limitA.pullUp = bitRead(P098_FLAGS, P098_FLAGBIT_LIM_A_PULLUP);
      config.limitB.pullUp = bitRead(P098_FLAGS, P098_FLAGBIT_LIM_B_PULLUP);
      config.encoder.pullUp = bitRead(P098_FLAGS, P098_FLAGBIT_ENC_IN_PULLUP);

      config.PWM_mode = static_cast<P098_config_struct::PWM_mode_type>(P098_MOTOR_CONTROL);
      config.pwm_soft_startstop = bitRead(P098_FLAGS, P098_FLAGBIT_PWM_SOFT_STARTSTOP);
      config.pwm_duty_cycle = P098_PWM_DUTY;

      initPluginTaskData(event->TaskIndex, new (std::nothrow) P098_data_struct(config));
      P098_data_struct *P098_data =
        static_cast<P098_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P098_data) {

        P098_data->begin(
          UserVar[event->BaseVarIndex + 0],
          UserVar[event->BaseVarIndex + 3],
          0);
        success = true;
      }
      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P098_data_struct *P098_data =
        static_cast<P098_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P098_data) {
        bool limitA_triggered, limitB_triggered = false;
        P098_data->getLimitSwitchStates(limitA_triggered, limitB_triggered);

        P098_data->loop();

        switch (P098_data->state) {
          case P098_data_struct::State::Idle:
          case P098_data_struct::State::RunFwd:
          case P098_data_struct::State::RunRev:
            break;
          case P098_data_struct::State::StopLimitSw:
          case P098_data_struct::State::StopPosReached:
          case P098_data_struct::State::StopEncoderTimeout:
          {
            if (Settings.UseRules) {
              String RuleEvent = getTaskDeviceName(event->TaskIndex);
              RuleEvent += '#';

              if (limitA_triggered) {
                eventQueue.addMove(concat(RuleEvent, F("limitA")));
              }

              if (limitB_triggered) {
                eventQueue.addMove(concat(RuleEvent, F("limitB")));
              }

              if (P098_data->state == P098_data_struct::State::StopPosReached) {
                eventQueue.addMove(concat(RuleEvent, F("positionReached")));
              }

              if (P098_data->state == P098_data_struct::State::StopEncoderTimeout) {
                eventQueue.addMove(concat(RuleEvent, F("encoderTimeout")));
              }
            }
            P098_data->state = P098_data_struct::State::Idle;
            break;
          }
        }


        int limitApos, limitBpos;
        P098_data->getLimitSwitchPositions(limitApos, limitBpos);
        UserVar.setFloat(event->TaskIndex, 0, P098_data->getPosition());
        UserVar.setFloat(event->TaskIndex, 1, limitA_triggered ? 1 : 0);
        UserVar.setFloat(event->TaskIndex, 2, limitB_triggered ? 1 : 0);
        UserVar.setFloat(event->TaskIndex, 3, limitApos);

        success = true;
      }
      break;
    }

    case PLUGIN_READ:
    {
      P098_data_struct *P098_data =
        static_cast<P098_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P098_data) {
        bool limitA_triggered, limitB_triggered = false;
        P098_data->getLimitSwitchStates(limitA_triggered, limitB_triggered);

        int limitApos, limitBpos;
        P098_data->getLimitSwitchPositions(limitApos, limitBpos);

        UserVar.setFloat(event->TaskIndex, 0, P098_data->getPosition());
        UserVar.setFloat(event->TaskIndex, 1, limitA_triggered ? 1 : 0);
        UserVar.setFloat(event->TaskIndex, 2, limitB_triggered ? 1 : 0);
        UserVar.setFloat(event->TaskIndex, 3, limitApos);

        success = true;
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P098_data_struct *P098_data =
        static_cast<P098_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P098_data) {
        const String command = parseString(string, 1);

        if (command.startsWith(F("pwmmotor"))) {
          if (equals(command, F("pwmmotorhome"))) {

            P098_data->findHome();
            success = true;
          } else if (equals(command, F("pwmmotorend"))) {

            P098_data->moveForward(-1);
            success = true;
          } else if (equals(command, F("pwmmotorforward"))) {


            P098_data->moveForward(event->Par1);
            success = true;
          } else if (equals(command, F("pwmmotorreverse"))) {

            P098_data->moveReverse(event->Par1);
            success = true;
          } else if (equals(command, F("pwmmotorstop"))) {

            P098_data->stop();
            success = true;
          } else if (equals(command, F("pwmmotormovetopos"))) {


            if (!P098_data->moveToPos(event->Par1)) {
              if (!P098_data->homePosSet()) {
                addLog(LOG_LEVEL_ERROR, F("PWM motor: Home position unknown"));
              } else {
                addLog(LOG_LEVEL_ERROR, F("PWM motor: Cannot move to position"));
              }
            }
            success = true;
          }
        }
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P099_XPT2046Touch.ino"
#ifdef USES_P099
# 34 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P099_XPT2046Touch.ino"
#define PLUGIN_099 
#define PLUGIN_ID_099 99
#define PLUGIN_NAME_099 "Touch - XPT2046 on a TFT display"
#define PLUGIN_VALUENAME1_099 "X"
#define PLUGIN_VALUENAME2_099 "Y"
#define PLUGIN_VALUENAME3_099 "Z"

#include "_Plugin_Helper.h"
#include "src/PluginStructs/P099_data_struct.h"


boolean Plugin_099(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_099;
      Device[deviceCount].Type = DEVICE_TYPE_SPI;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = false;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_099);
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_099));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_099));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_099));
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("TS CS"));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {

      if (P099_CONFIG_STATE != 1) {
        P099_CONFIG_CS_PIN = P099_TS_CS;
        P099_CONFIG_TRESHOLD = P099_TS_TRESHOLD;
        P099_CONFIG_ROTATION = P099_TS_ROTATION;
        P099_CONFIG_X_RES = P099_TS_X_RES;
        P099_CONFIG_Y_RES = P099_TS_Y_RES;
        P099_CONFIG_OBJECTCOUNT = P099_INIT_OBJECTCOUNT;
        P099_CONFIG_DEBOUNCE_MS = P099_DEBOUNCE_MILLIS;

        constexpr uint32_t lSettings = 0
                                       + (P099_TS_SEND_XY ? (1 << P099_FLAGS_SEND_XY) : 0)
                                       + (P099_TS_SEND_Z ? (1 << P099_FLAGS_SEND_Z) : 0)
                                       + (P099_TS_SEND_OBJECTNAME ? (1 << P099_FLAGS_SEND_OBJECTNAME) : 0)
                                       + (P099_TS_USE_CALIBRATION ? (1 << P099_FLAGS_USE_CALIBRATION) : 0)
                                       + (P099_TS_LOG_CALIBRATION ? (1 << P099_FLAGS_LOG_CALIBRATION) : 0)
                                       + (P099_TS_ROTATION_FLIPPED ? (1 << P099_FLAGS_ROTATION_FLIPPED) : 0);
        P099_CONFIG_FLAGS = lSettings;
      }
      success = true;
      break;
    }
    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Screen"));

      uint16_t width_ = P099_CONFIG_X_RES;

      if (width_ == 0) {
        width_ = P099_TS_X_RES;
      }
      addFormNumericBox(F("Screen Width (px) (x)"), F("pwidth"), width_, 1, 65535);

      uint16_t height_ = P099_CONFIG_Y_RES;

      if (height_ == 0) {
        height_ = P099_TS_Y_RES;
      }
      addFormNumericBox(F("Screen Height (px) (y)"), F("pheight"), height_, 1, 65535);

      {
        uint8_t choice2 = P099_CONFIG_ROTATION;
        const __FlashStringHelper *options2[4] = { F("Normal"), F("+90&deg;"), F("+180&deg;"), F("+270&deg;") };
        int optionValues2[4] = { 0, 1, 2, 3 };

        addFormSelector(F("Rotation"), F("protate"), 4, options2, optionValues2, choice2);
      }

      bool bRotationFlipped = bitRead(P099_CONFIG_FLAGS, P099_FLAGS_ROTATION_FLIPPED);
      addFormCheckBox(F("Flip rotation 180&deg;"), F("protation_flipped"), bRotationFlipped);
      addFormNote(F("Some touchscreens are mounted 180&deg; rotated on the display."));

      addFormSubHeader(F("Touch configuration"));

      uint8_t treshold = P099_CONFIG_TRESHOLD;
      addFormNumericBox(F("Touch minimum pressure"), F("ptreshold"), treshold, 0, 255);

      #define P099_EVENTS_OPTIONS 6
      uint8_t choice3 = 0;
      bitWrite(choice3, P099_FLAGS_SEND_XY, bitRead(P099_CONFIG_FLAGS, P099_FLAGS_SEND_XY));
      bitWrite(choice3, P099_FLAGS_SEND_Z, bitRead(P099_CONFIG_FLAGS, P099_FLAGS_SEND_Z));
      bitWrite(choice3, P099_FLAGS_SEND_OBJECTNAME, bitRead(P099_CONFIG_FLAGS, P099_FLAGS_SEND_OBJECTNAME));
      {
        const __FlashStringHelper *options3[P099_EVENTS_OPTIONS] =
        { F("None"),
          F("X and Y"),
          F("X, Y and Z"),
          F("Objectnames only"),
          F("Objectnames, X and Y"),
          F("Objectnames, X, Y and Z") };
        int optionValues3[P099_EVENTS_OPTIONS] = { 0, 1, 3, 4, 5, 7 };
        addFormSelector(F("Events"), F("pevents"), P099_EVENTS_OPTIONS, options3, optionValues3, choice3);
      }

      if (!Settings.UseRules) {
        addFormNote(F("Tools / Advanced / Rules must be enabled for events to be fired."));
      }

      {
        P099_data_struct *P099_data = new (std::nothrow) P099_data_struct();

        if (nullptr == P099_data) {
          return success;
        }
        P099_data->loadTouchObjects(event->TaskIndex);

        addFormSubHeader(F("Calibration"));

        bool tbUseCalibration = bitRead(P099_CONFIG_FLAGS, P099_FLAGS_USE_CALIBRATION);
        addFormSelector_YesNo(F("Calibrate to screen resolution"), F("puse_calibration"), tbUseCalibration ? 1 : 0, true);

        if (tbUseCalibration) {
          addRowLabel(F("Calibration"));
          html_table(EMPTY_STRING, false);
          html_table_header(F(""), 100);
          html_table_header(F("x"), 70);
          html_table_header(F("y"), 70);
          html_table_header(F(""), 100);
          html_table_header(F("x"), 70);
          html_table_header(F("y"), 70);

          html_TR_TD();
          addHtml(F("Top-left"));
          html_TD();
          addNumericBox(F("pcal_tl_x"), P099_data->StoredSettings.Calibration.top_left.x, 0, 65535);
          html_TD();
          addNumericBox(F("pcal_tl_y"), P099_data->StoredSettings.Calibration.top_left.y, 0, 65535);
          html_TD();
          addHtml(F("Bottom-right"));
          html_TD();
          addNumericBox(F("pcal_br_x"), P099_data->StoredSettings.Calibration.bottom_right.x, 0, 65535);
          html_TD();
          addNumericBox(F("pcal_br_y"), P099_data->StoredSettings.Calibration.bottom_right.y, 0, 65535);

          html_end_table();
          addFormNote(F("All x/y values must be <> 0 to enable calibration."));
        }
        bool bEnableCalibrationLog = bitRead(P099_CONFIG_FLAGS, P099_FLAGS_LOG_CALIBRATION);
        addFormCheckBox(F("Enable logging for calibration"), F("plog_calibration"), bEnableCalibrationLog);

        addFormSubHeader(F("Touch objects"));

        {
          if (P099_CONFIG_OBJECTCOUNT > P099_MaxObjectCount) { P099_CONFIG_OBJECTCOUNT = P099_MaxObjectCount; }
          uint8_t choice5 = P099_CONFIG_OBJECTCOUNT;

          if (choice5 == 0) {
            choice5 = P099_CONFIG_OBJECTCOUNT = P099_INIT_OBJECTCOUNT;
          }
          #define P099_OBJECTCOUNT_OPTIONS 6
          {
            const __FlashStringHelper *options5[P099_OBJECTCOUNT_OPTIONS] = { F("None"), F("8"), F("16"), F("24"), F("32"), F("40") };
            int optionValues5[P099_OBJECTCOUNT_OPTIONS] = { -1, 8, 16, 24, 32, 40 };
            addFormSelector(F("# of objects"), F("pobjectcount"), P099_OBJECTCOUNT_OPTIONS, options5, optionValues5, choice5, true);
          }
        }

        if (P099_CONFIG_OBJECTCOUNT > -1) {
          addRowLabel(F("Object"));
          html_table(EMPTY_STRING, false);
          html_table_header(F("&nbsp;#&nbsp;"), 30);
          html_table_header(F("Objectname"), 200);
          html_table_header(F("Top-left x"), 120);
          html_table_header(F("Top-left y"), 120);
          html_table_header(F("Bottom-right x"), 150);
          html_table_header(F("Bottom-right y"), 150);
          html_table_header(F("On/Off button"), 150);
          html_table_header(F("Inverted"), 120);

          for (int objectNr = 0; objectNr < P099_CONFIG_OBJECTCOUNT; objectNr++) {
            html_TR_TD();
            addHtml(F("&nbsp;"));
            addHtmlInt(objectNr + 1);
            html_TD();
            addTextBox(getPluginCustomArgName(objectNr),
                       String(P099_data->StoredSettings.TouchObjects[objectNr].objectname),
                       P099_MaxObjectNameLength - 1,
                       false, false, EMPTY_STRING, F(""));
            html_TD();
            addNumericBox(getPluginCustomArgName(objectNr + 100), P099_data->StoredSettings.TouchObjects[objectNr].top_left.x, 0, 65535);
            html_TD();
            addNumericBox(getPluginCustomArgName(objectNr + 200), P099_data->StoredSettings.TouchObjects[objectNr].top_left.y, 0, 65535);
            html_TD();
            addNumericBox(getPluginCustomArgName(objectNr + 300), P099_data->StoredSettings.TouchObjects[objectNr].bottom_right.x, 0, 65535);
            html_TD();
            addNumericBox(getPluginCustomArgName(objectNr + 400), P099_data->StoredSettings.TouchObjects[objectNr].bottom_right.y, 0, 65535);
            html_TD();
            addCheckBox(getPluginCustomArgName(objectNr + 500),
                        bitRead(P099_data->StoredSettings.TouchObjects[objectNr].flags, P099_FLAGS_ON_OFF_BUTTON), false);
            html_TD();
            addCheckBox(getPluginCustomArgName(objectNr + 600),
                        bitRead(P099_data->StoredSettings.TouchObjects[objectNr].flags, P099_FLAGS_INVERT_BUTTON), false);
          }
          html_end_table();
          addFormNote(F("Start objectname with '_' to ignore/disable the object (temporarily)."));

          uint8_t debounce = P099_CONFIG_DEBOUNCE_MS;
          addFormNumericBox(F("Debounce delay for On/Off buttons"), F("pdebounce"), debounce, 0, 255);
          addUnit(F("0-255 msec."));
        }
        delete P099_data;
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P099_CONFIG_STATE = 1;
      P099_CONFIG_TRESHOLD = getFormItemInt(F("ptreshold"));
      P099_CONFIG_ROTATION = getFormItemInt(F("protate"));
      P099_CONFIG_X_RES = getFormItemInt(F("pwidth"));
      P099_CONFIG_Y_RES = getFormItemInt(F("pheight"));
      P099_CONFIG_OBJECTCOUNT = getFormItemInt(F("pobjectcount"));

      if (P099_CONFIG_OBJECTCOUNT > P099_MaxObjectCount) { P099_CONFIG_OBJECTCOUNT = P099_MaxObjectCount; }

      uint32_t lSettings = 0;
      bitWrite(lSettings, P099_FLAGS_SEND_XY, bitRead(getFormItemInt(F("pevents")), P099_FLAGS_SEND_XY));
      bitWrite(lSettings, P099_FLAGS_SEND_Z, bitRead(getFormItemInt(F("pevents")), P099_FLAGS_SEND_Z));
      bitWrite(lSettings, P099_FLAGS_SEND_OBJECTNAME, bitRead(getFormItemInt(F("pevents")), P099_FLAGS_SEND_OBJECTNAME));
      bitWrite(lSettings, P099_FLAGS_USE_CALIBRATION, getFormItemInt(F("puse_calibration")) == 1);
      bitWrite(lSettings, P099_FLAGS_LOG_CALIBRATION, isFormItemChecked(F("plog_calibration")));
      bitWrite(lSettings, P099_FLAGS_ROTATION_FLIPPED, isFormItemChecked(F("protation_flipped")));
      P099_CONFIG_FLAGS = lSettings;

      P099_data_struct *P099_data = new (std::nothrow) P099_data_struct();

      if (nullptr == P099_data) {
        return success;
      }
      P099_data->StoredSettings.Calibration.top_left.x = getFormItemInt(F("pcal_tl_x"));
      P099_data->StoredSettings.Calibration.top_left.y = getFormItemInt(F("pcal_tl_y"));
      P099_data->StoredSettings.Calibration.bottom_right.x = getFormItemInt(F("pcal_br_x"));
      P099_data->StoredSettings.Calibration.bottom_right.y = getFormItemInt(F("pcal_br_y"));

      String error;

      for (int objectNr = 0; objectNr < P099_CONFIG_OBJECTCOUNT; objectNr++) {
        if (!safe_strncpy(P099_data->StoredSettings.TouchObjects[objectNr].objectname, webArg(getPluginCustomArgName(objectNr)),
                          P099_MaxObjectNameLength)) {
          error += getCustomTaskSettingsError(objectNr);
        }
        P099_data->StoredSettings.TouchObjects[objectNr].objectname[P099_MaxObjectNameLength - 1] = 0;




        if (!ExtraTaskSettings.checkInvalidCharInNames(&P099_data->StoredSettings.TouchObjects[objectNr].objectname[0])) {



          error += concat(F("Invalid character in objectname #"), objectNr + 1);
          error += F(". Do not use ',-+/*=^%!#[]{}()' or space.\n");
        }
        P099_data->StoredSettings.TouchObjects[objectNr].top_left.x = getFormItemIntCustomArgName(objectNr + 100);
        P099_data->StoredSettings.TouchObjects[objectNr].top_left.y = getFormItemIntCustomArgName(objectNr + 200);
        P099_data->StoredSettings.TouchObjects[objectNr].bottom_right.x = getFormItemIntCustomArgName(objectNr + 300);
        P099_data->StoredSettings.TouchObjects[objectNr].bottom_right.y = getFormItemIntCustomArgName(objectNr + 400);

        uint8_t flags = 0;
        bitWrite(flags, P099_FLAGS_ON_OFF_BUTTON, isFormItemChecked(getPluginCustomArgName(objectNr + 500)));
        bitWrite(flags, P099_FLAGS_INVERT_BUTTON, isFormItemChecked(getPluginCustomArgName(objectNr + 600)));
        P099_data->StoredSettings.TouchObjects[objectNr].flags = flags;
      }

      if (P099_CONFIG_OBJECTCOUNT > 0) {
        P099_CONFIG_DEBOUNCE_MS = getFormItemInt(F("pdebounce"));
      }

      if (error.length() > 0) {
        addHtmlError(error);
      }
      #ifdef PLUGIN_099_DEBUG

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        addLogMove(LOG_LEVEL_INFO, concat(F("P099 data save size: "), sizeof(P099_data->StoredSettings)));
      }
      #endif
      SaveCustomTaskSettings(event->TaskIndex, reinterpret_cast<const uint8_t *>(&(P099_data->StoredSettings)),
                             sizeof(P099_data->StoredSettings));
      delete P099_data;

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P099_data_struct());
      P099_data_struct *P099_data = static_cast<P099_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P099_data) && P099_data->init(event->TaskIndex,
                                                          P099_CONFIG_CS_PIN,
                                                          P099_CONFIG_ROTATION,
                                                          bitRead(P099_CONFIG_FLAGS, P099_FLAGS_ROTATION_FLIPPED),
                                                          P099_CONFIG_TRESHOLD,
                                                          bitRead(P099_CONFIG_FLAGS, P099_FLAGS_SEND_XY),
                                                          bitRead(P099_CONFIG_FLAGS, P099_FLAGS_SEND_Z),
                                                          bitRead(P099_CONFIG_FLAGS, P099_FLAGS_USE_CALIBRATION),
                                                          P099_CONFIG_X_RES,
                                                          P099_CONFIG_Y_RES);

      break;
    }

    case PLUGIN_EXIT:
    {
      success = true;
      break;
    }



    case PLUGIN_WRITE:
    {
      P099_data_struct *P099_data = static_cast<P099_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P099_data) {
        success = P099_data->plugin_write(event, string);
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P099_data_struct *P099_data = static_cast<P099_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P099_data) {
        return success;
      }

      if (P099_data->isInitialized()) {
        if (P099_data->touched()) {
          uint16_t x, y, rx, ry;
          uint8_t z;
          P099_data->readData(&x, &y, &z);

          if (!((x >= P099_TOUCH_X_INVALID) || (y >= P099_TOUCH_Y_INVALID) || (z == P099_TOUCH_Z_INVALID) || (z <= P099_CONFIG_TRESHOLD))) {
            rx = x;
            ry = y;
            P099_data->scaleRawToCalibrated(x, y);

            P099_SET_VALUE_X(x);
            P099_SET_VALUE_Y(y);
            P099_SET_VALUE_Z(z);

            bool bEnableCalibrationLog = bitRead(P099_CONFIG_FLAGS, P099_FLAGS_LOG_CALIBRATION);

            if (bEnableCalibrationLog && loglevelActiveFor(LOG_LEVEL_INFO)) {



              addLogMove(LOG_LEVEL_INFO, strformat(
                           F("Touch calibration rx= %u, ry= %u; z= %u, x= %u, y= %u"),
                           rx,
                           ry,
                           z,
                           x,
                           y));
            }

            if (Settings.UseRules) {

              if (bitRead(P099_CONFIG_FLAGS, P099_FLAGS_SEND_XY)) {
                const deviceIndex_t DeviceIndex = getDeviceIndex_from_TaskIndex(event->TaskIndex);

                if (!bitRead(P099_CONFIG_FLAGS, P099_FLAGS_SEND_Z) && validDeviceIndex(DeviceIndex)) {


                  #ifdef ESP8266
                  Device[DeviceIndex].VType = Sensor_VType::SENSOR_TYPE_DUAL;
                  Device[DeviceIndex].ValueCount = 2;
                  #else
                  Device.getDeviceStructForEdit(DeviceIndex).VType = Sensor_VType::SENSOR_TYPE_DUAL;
                  Device.getDeviceStructForEdit(DeviceIndex).ValueCount = 2;
                  #endif
                }
                sendData(event);

                if (!bitRead(P099_CONFIG_FLAGS, P099_FLAGS_SEND_Z) && validDeviceIndex(DeviceIndex)) {

                  #ifdef ESP8266
                  Device[DeviceIndex].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
                  Device[DeviceIndex].ValueCount = 3;
                  #else
                  Device.getDeviceStructForEdit(DeviceIndex).VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
                  Device.getDeviceStructForEdit(DeviceIndex).ValueCount = 3;
                  #endif
                }
              }

              if (bitRead(P099_CONFIG_FLAGS, P099_FLAGS_SEND_OBJECTNAME)) {
                String selectedObjectName;
                int selectedObjectIndex = -1;

                if (P099_data->isValidAndTouchedTouchObject(x, y, selectedObjectName, selectedObjectIndex, P099_CONFIG_OBJECTCOUNT)) {
                  if ((selectedObjectIndex > -1) &&
                      bitRead(P099_data->StoredSettings.TouchObjects[selectedObjectIndex].flags, P099_FLAGS_ON_OFF_BUTTON)) {
                    if ((P099_data->TouchTimers[selectedObjectIndex] == 0) ||
                        (P099_data->TouchTimers[selectedObjectIndex] < millis() - (2 * P099_CONFIG_DEBOUNCE_MS))) {

                      P099_data->TouchTimers[selectedObjectIndex] = millis() + P099_CONFIG_DEBOUNCE_MS;

                    } else {
                      if (P099_data->TouchTimers[selectedObjectIndex] <= millis()) {

                        P099_data->TouchStates[selectedObjectIndex] = !P099_data->TouchStates[selectedObjectIndex];
                        P099_data->TouchTimers[selectedObjectIndex] = 0;

                        bool eventValue = P099_data->TouchStates[selectedObjectIndex];

                        if (bitRead(P099_data->StoredSettings.TouchObjects[selectedObjectIndex].flags, P099_FLAGS_INVERT_BUTTON)) {
                          eventValue = !eventValue;
                        }
                        eventQueue.add(event->TaskIndex, selectedObjectName, eventValue);
                      }
                    }
                  } else {

                    eventQueue.add(
                      event->TaskIndex,
                      selectedObjectName,
                      strformat(F("%u,%u,%u"), x, y, z));
                  }
                }
              }
            }
            success = true;
          }
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P100_DS2423_counter.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P100







# include "src/Helpers/Dallas1WireHelper.h"

#define PLUGIN_100 
#define PLUGIN_ID_100 100
#define PLUGIN_NAME_100 "Pulse Counter - DS2423"
#define PLUGIN_VALUENAME1_100 "CountDelta"

boolean Plugin_100(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_100;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_100);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_100));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_bidirectional(F("1-Wire"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNote(F("External pull up resistor is needed, see docs!"));


      int8_t Plugin_100_DallasPin = CONFIG_PIN1;

      if (validGpio(Plugin_100_DallasPin)) {
        Dallas_addr_selector_webform_load(event->TaskIndex, Plugin_100_DallasPin, Plugin_100_DallasPin);


        const __FlashStringHelper * resultsOptions[2] = { F("A"), F("B") };
        int resultsOptionValues[2] = { 0, 1 };
        addFormSelector(F("Counter"), F("counter"), 2, resultsOptions, resultsOptionValues, PCONFIG(0));
        addFormNote(F("Counter value is incremental"));
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {

      PCONFIG(0) = getFormItemInt(F("counter"));


      Dallas_addr_selector_webform_save(event->TaskIndex, CONFIG_PIN1, CONFIG_PIN1);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      uint8_t addr[8];
      Dallas_plugin_get_addr(addr, event->TaskIndex);
      string = Dallas_format_address(addr);
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      UserVar.setFloat(event->TaskIndex, 0, 0);
      UserVar.setFloat(event->TaskIndex, 1, 0);
      UserVar.setFloat(event->TaskIndex, 2, 0);

      if (validGpio(CONFIG_PIN1)) {


        pinMode(CONFIG_PIN1, INPUT);
      }

      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      uint8_t addr[8];
      Dallas_plugin_get_addr(addr, event->TaskIndex);

      if (addr[0] != 0) {
        if (validGpio(CONFIG_PIN1)) {
          float value = 0;

          if (Dallas_readCounter(addr, &value, CONFIG_PIN1, CONFIG_PIN1, PCONFIG(0)))
          {
            UserVar.setFloat(event->TaskIndex, 0, UserVar[event->BaseVarIndex + 2] != 0
              ? value - UserVar[event->BaseVarIndex + 1]
              : 0);
            UserVar.setFloat(event->TaskIndex, 2, 1);
            UserVar.setFloat(event->TaskIndex, 1, value);
            success = true;
          }
          else
          {
            UserVar.setFloat(event->TaskIndex, 0, NAN);
          }

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            String log = F("[P100]DS   : Counter ");
            log += PCONFIG(0) == 0 ? F("A") : F("B");
            log += F(": ");

            if (success) {
              log += formatUserVarNoCheck(event->TaskIndex, 0);
            } else {
              log += F("Error!");
            }
            log += F(" (");
            log += Dallas_format_address(addr);
            log += ')';
            addLogMove(LOG_LEVEL_INFO, log);
          }
        }
      }
      break;
    }
  }
  return success;
}


#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P101_WakeOnLan.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P101
# 53 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P101_WakeOnLan.ino"
#include <WakeOnLan.h>


#define PLUGIN_101 
#define PLUGIN_ID_101 101
#define PLUGIN_NAME_101 "Communication - Wake On LAN"


#define CUSTOMTASK_STR_SIZE_P101 20
#define DEF_TASK_NAME_P101 "WAKE_ON_LAN"
#define SET_UDP_PORT_P101 ExtraTaskSettings.TaskDevicePluginConfigLong[1]
#define GET_UDP_PORT_P101 Cache.getTaskDevicePluginConfigLong(event->TaskIndex, 1)
#define FORM_PORT_P101 "pport"


#define CMD_NAME_P101 "WAKEONLAN"


#define MAC_ADDR_SIZE_P101 17
#define MAC_BUFF_SIZE_P101 18
#define MAC_SEP_CHAR_P101 ':'
#define MAC_SEP_CNT_P101 5
#define MAC_STR_DEF_P101 "00:00:00:00:00:00"
#define MAC_STR_EXP_P101 "5d:89:22:56:9c:60"


#define IP_ADDR_SIZE_P101 15
#define IP_BUFF_SIZE_P101 16
#define IP_MIN_SIZE_P101 7
#define IP_SEP_CHAR_P101 '.'
#define IP_SEP_CNT_P101 3
#define IP_STR_DEF_P101 "255.255.255.255"


#define PORT_DEF_P101 9
#define PORT_MAX_P101 65535


#define LOG_NAME_P101 "WAKE ON LAN: "
#define NAME_MISSING 0
#define NAME_SAFE 1
#define NAME_UNSAFE 2



WiFiUDP udp;
WakeOnLan WOL(udp);



uint8_t safeName(taskIndex_t index);
bool validateIp(const String& ipStr);
bool validateMac(const String& macStr);
bool validatePort(const String& portStr);



boolean Plugin_101(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_101;
      Device[deviceCount].Type = DEVICE_TYPE_DUMMY;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_101);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      SET_UDP_PORT_P101 = PORT_DEF_P101;
      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
      char ipString[IP_BUFF_SIZE_P101] = {0};
      char macString[MAC_BUFF_SIZE_P101] = {0};
      addFormSubHeader("");
      addFormHeader(F("Default Settings"));

      String strings[2];
      LoadCustomTaskSettings(event->TaskIndex, strings, 2, CUSTOMTASK_STR_SIZE_P101);

      safe_strncpy(macString, strings[1], MAC_BUFF_SIZE_P101);
      addFormTextBox(F("MAC Address"), getPluginCustomArgName(1), macString, MAC_ADDR_SIZE_P101);
      addFormNote(F("Format Example, " MAC_STR_EXP_P101));
      addFormSubHeader("");

      safe_strncpy(ipString, strings[0], IP_BUFF_SIZE_P101);
      addFormTextBox(F("IPv4 Address"), getPluginCustomArgName(0), ipString, IP_ADDR_SIZE_P101);
      addFormNumericBox(F("UDP Port"), F(FORM_PORT_P101), GET_UDP_PORT_P101, 0, PORT_MAX_P101);
      addFormNote(
        concat(F("Typical Installations use IP Address "), F(IP_STR_DEF_P101)) +
        concat(F(", Port "), PORT_DEF_P101));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      char ipString[IP_BUFF_SIZE_P101] {0};
      char macString[MAC_BUFF_SIZE_P101] {0};
      char deviceTemplate[2][CUSTOMTASK_STR_SIZE_P101] {};
      String errorStr;
      String msgStr;
      const String wolStr = F(LOG_NAME_P101);


      uint8_t nameCode = safeName(event->TaskIndex);

      if ((nameCode == NAME_MISSING) || (nameCode == NAME_UNSAFE)) {
        strcpy(ExtraTaskSettings.TaskDeviceName, String(F(DEF_TASK_NAME_P101)).c_str());

        if (nameCode == NAME_UNSAFE) {
          errorStr = F("ALERT, Renamed Unsafe Task Name. ");
        }
      }


      if (!safe_strncpy(ipString, webArg(getPluginCustomArgName(0)), IP_BUFF_SIZE_P101)) {




      }

      if (strlen(ipString) == 0) {
        strcpy_P(ipString, String(F(IP_STR_DEF_P101)).c_str());

        msgStr = wolStr;
        msgStr += F("Loaded Default IP = ");
        msgStr += F(IP_STR_DEF_P101);
        addLogMove(LOG_LEVEL_INFO, msgStr);
      }
      else if (strlen(ipString) < IP_MIN_SIZE_P101) {
        strcpy_P(ipString, String(F(IP_STR_DEF_P101)).c_str());

        errorStr += F("Provided IP Invalid (Using Default). ");
        msgStr = concat(wolStr, F("Provided IP Invalid (Using Default). "));
        msgStr += '[';
        msgStr += F(IP_STR_DEF_P101);
        msgStr += ']';
        addLogMove(LOG_LEVEL_INFO, msgStr);
      }
      else if (!validateIp(ipString)) {
        errorStr += F("WARNING, Please Review IP Address. ");
        msgStr = concat(wolStr, F("WARNING, Please Review IP Address. "));
        msgStr += '[';
        msgStr += ipString;
        msgStr += ']';
        addLogMove(LOG_LEVEL_INFO, msgStr);
      }


      if (!safe_strncpy(macString, webArg(getPluginCustomArgName(1)), MAC_BUFF_SIZE_P101)) {




      }

      if (strlen(macString) == 0) {
        strcpy_P(macString, String(F(MAC_STR_DEF_P101)).c_str());

        errorStr += F("MAC Address Not Provided, Populated with Zero Values. ");
        addLogMove(LOG_LEVEL_INFO, concat(wolStr, F("MAC Address Not Provided, Populated with Zero Values. ")));
      }
      else if (!validateMac(macString)) {
        errorStr += F("ERROR, MAC Address Invalid. ");
        msgStr = concat(wolStr, F("ERROR, MAC Address Invalid. "));
        msgStr += '[';
        msgStr += macString;
        msgStr += ']';
        addLogMove(LOG_LEVEL_INFO, msgStr);
      }


      safe_strncpy(deviceTemplate[0], ipString, IP_BUFF_SIZE_P101);
      safe_strncpy(deviceTemplate[1], macString, MAC_BUFF_SIZE_P101);

      if (errorStr.length() > 0) {
        addHtmlError(errorStr);
      }


      SaveCustomTaskSettings(event->TaskIndex, reinterpret_cast<const uint8_t *>(&deviceTemplate), sizeof(deviceTemplate));
      SET_UDP_PORT_P101 = getFormItemInt(F(FORM_PORT_P101));
      success = true;
      break;
    }

    case PLUGIN_INIT: {
      success = true;
      break;
    }

    case PLUGIN_READ: {
      success = false;
      break;
    }

    case PLUGIN_WRITE: {
      char ipString[IP_BUFF_SIZE_P101] = {0};
      char macString[MAC_BUFF_SIZE_P101] = {0};
      uint8_t parse_error = false;
      String msgStr;
      String strings[2];
      String tmpString = string;
      const String wolStr = F(LOG_NAME_P101);



      String cmd = parseString(tmpString, 1);




      if (validTaskIndex(event->TaskIndex) &&
          (cmd.equalsIgnoreCase(F(CMD_NAME_P101)) ||
           cmd.equalsIgnoreCase(getTaskDeviceName(event->TaskIndex)))) {


        if (!Settings.TaskDeviceEnabled[event->TaskIndex]) {



          break;
        }

        success = true;

        LoadCustomTaskSettings(event->TaskIndex, strings, 2, CUSTOMTASK_STR_SIZE_P101);
        safe_strncpy(ipString, strings[0], IP_BUFF_SIZE_P101);
        safe_strncpy(macString, strings[1], MAC_BUFF_SIZE_P101);

        String paramMac = parseString(tmpString, 2);
        String paramIp = parseString(tmpString, 3);
        String paramPort = parseString(tmpString, 4);


        if (paramMac.isEmpty()) {
          paramMac = macString;
        }

        if (paramIp.isEmpty()) {
          paramIp = ipString;
        }

        if (paramPort.isEmpty()) {
          LoadTaskSettings(event->TaskIndex);
          paramPort = GET_UDP_PORT_P101;
        }


        if (!validateMac(paramMac)) {
          parse_error = true;
          msgStr = concat(wolStr, F("Error, MAC Addr Invalid ["));
          msgStr += paramMac;
          msgStr += ']';
          addLogMove(LOG_LEVEL_INFO, msgStr);
        }


        if (!validateIp(paramIp)) {
          parse_error = true;
          msgStr = concat(wolStr, F("Error, IP Addr Invalid ["));
          msgStr += paramIp;
          msgStr += ']';
          addLogMove(LOG_LEVEL_INFO, msgStr);
        }


        if (!validatePort(paramPort)) {
          parse_error = true;
          msgStr = concat(wolStr, F("Error, Port Invalid ["));
          msgStr += paramPort;
          msgStr += ']';
          addLogMove(LOG_LEVEL_INFO, msgStr);
        }


        if (parse_error == true) {
          msgStr = F("CMD Syntax Error");
          addLogMove(LOG_LEVEL_INFO, concat(wolStr, msgStr));
          msgStr += F(" <br>");
          SendStatus(event, msgStr);
        }
        else {
          addLogMove(LOG_LEVEL_INFO, strformat(
            F("%sMAC= %s, IP= %s, Port= %s"),
            wolStr.c_str(),
            paramMac.c_str(),
            paramIp.c_str(),
            paramPort.c_str()));


          if (WiFi.status() == WL_CONNECTED) {
            IPAddress local_IP;
            local_IP.fromString(paramIp);
            WOL.setBroadcastAddress(local_IP);



            if (!WOL.sendMagicPacket(paramMac, paramPort.toInt())) {
              addLogMove(LOG_LEVEL_INFO, concat(wolStr, F("Error, Magic Packet Failed (check parameters)")));
            }
          }
          else {
            addLogMove(LOG_LEVEL_INFO, concat(wolStr, F("Error, WiFi Off-Line")));
          }
        }
      }
      break;
    }
  }
  return success;
}





uint8_t safeName(taskIndex_t index) {
  String devName = getTaskDeviceName(index);

  if (devName.isEmpty()) {
    return NAME_MISSING;
  }
  devName.toLowerCase();

  if (equals(devName, F("reboot")) ||
      equals(devName, F("reset"))) {
    return NAME_UNSAFE;
  }

  return NAME_SAFE;
}





bool validateIp(const String& ipStr) {
  IPAddress ip;
  unsigned int length = ipStr.length();

  if ((length < IP_MIN_SIZE_P101) || (length > IP_ADDR_SIZE_P101)) {
    return false;
  }
  else if (ip.fromString(ipStr) == false) {
    return false;
  }

  return true;
}





bool validateMac(const String& macStr) {
  uint8_t pos = 0;
  char hexChar;

  if (macStr.length() != MAC_ADDR_SIZE_P101) {
    return false;
  }

  for (uint8_t strPos = 0; strPos < MAC_ADDR_SIZE_P101; strPos++) {
    uint8_t mod = strPos % 3;

    if (mod == 2) {
      if (macStr[strPos] == MAC_SEP_CHAR_P101) {
        pos++;
      }
      else {
        return false;
      }
    }
    else {
      hexChar = macStr[strPos];

      if (!isHexadecimalDigit(hexChar)) {
        return false;
      }
    }
  }
  return true;
}





bool validatePort(const String& portStr) {
  bool pass = true;
  long portNumber;

  portNumber = portStr.toInt();

  if ((portNumber < 0) || (portNumber > PORT_MAX_P101)) {
    pass = false;
  }
  else if (!isDigit(portStr.charAt(0))) {
    pass = false;
  }

  return pass;
}



#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P102_PZEM004Tv3.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P102







# include <ESPeasySerial.h>
# include <PZEM004Tv30.h>

# include "src/DataStructs/ESPEasy_packed_raw_data.h"


#define PLUGIN_102 
#define PLUGIN_ID_102 102
#define PLUGIN_102_DEBUG true
#define PLUGIN_NAME_102 "Energy (AC) - PZEM-004Tv30-Multiple"

#define P102_PZEM_mode PCONFIG(1)
#define P102_PZEM_ADDR PCONFIG(2)

#define P102_QUERY1 PCONFIG(3)
#define P102_QUERY2 PCONFIG(4)
#define P102_QUERY3 PCONFIG(5)
#define P102_QUERY4 PCONFIG(6)
#define P102_PZEM_FIRST PCONFIG(7)
#define P102_PZEM_ATTEMPT PCONFIG_LONG(1)

#define P102_PZEM_mode_DFLT 0
#define P102_QUERY1_DFLT 0
#define P102_QUERY2_DFLT 1
#define P102_QUERY3_DFLT 2
#define P102_QUERY4_DFLT 3
#define P102_NR_OUTPUT_VALUES 4
#define P102_NR_OUTPUT_OPTIONS 6
#define P102_QUERY1_CONFIG_POS 3

#define P102_PZEM_MAX_ATTEMPT 3

PZEM004Tv30 * P102_PZEM_sensor = nullptr;

boolean Plugin_102_init = false;
uint8_t P102_PZEM_ADDR_SET = 0;



const __FlashStringHelper* p102_getQueryString(uint8_t query);


boolean Plugin_102(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_102;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_102);
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < P102_NR_OUTPUT_VALUES) {
          uint8_t choice = PCONFIG(i + P102_QUERY1_CONFIG_POS);
          ExtraTaskSettings.setTaskDeviceValueName(i, p102_getQueryString(choice));
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {

      P102_PZEM_mode = P102_PZEM_mode_DFLT;
      P102_QUERY1 = P102_QUERY1_DFLT;
      P102_QUERY2 = P102_QUERY2_DFLT;
      P102_QUERY3 = P102_QUERY3_DFLT;
      P102_QUERY4 = P102_QUERY4_DFLT;

      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      serialHelper_getGpioNames(event);


      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {

      const __FlashStringHelper *options[P102_NR_OUTPUT_OPTIONS];

      for (uint8_t i = 0; i < P102_NR_OUTPUT_OPTIONS; ++i) {
        options[i] = p102_getQueryString(i);
      }

      for (uint8_t i = 0; i < P102_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P102_QUERY1_CONFIG_POS;
        sensorTypeHelper_loadOutputSelector(event, pconfigIndex, i, P102_NR_OUTPUT_OPTIONS, options);
      }

      success = true;

      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
      if (P102_PZEM_sensor == nullptr) { P102_PZEM_FIRST = event->TaskIndex;
      }

      if (P102_PZEM_FIRST == event->TaskIndex)
      {
        addHtml(F("<br><B>This PZEM is the first. Its configuration of serial Pins will affect next PZEM. </B>"));
        addHtml(F(
                  "<span style=\"color:red\"> <br><B>If several PZEMs foreseen, don't use HW serial (or invert Tx and Rx to configure as SW serial).</B></span>"));
        addFormSubHeader(F("PZEM actions"));
        {
          const __FlashStringHelper *options_model[3] = { F("Read_value"), F("Reset_Energy"), F("Program_adress") };
          addFormSelector(F("PZEM Mode"), F("PZEM_mode"), 3, options_model, nullptr, P102_PZEM_mode);
        }

        if (P102_PZEM_mode == 2)
        {
          addHtml(F(
                    "<span style=\"color:red\"> <br>When programming an address, only one PZEMv30 must be connected. Otherwise, all connected PZEMv30s will get the same address, which would cause a conflict during reading.</span>"));
          {
            const __FlashStringHelper *options_confirm[2] = { F("NO"), F("YES") };
            addFormSelector(F("Confirm address programming ?"), F("PZEM_addr_set"), 2, options_confirm, nullptr, P102_PZEM_ADDR_SET);
          }
          addFormNumericBox(F("Address of PZEM"), F("PZEM_addr"), (P102_PZEM_ADDR < 1) ? 1 : P102_PZEM_ADDR, 1, 247);
          addHtml(F("Select the address to set PZEM. Programming address 0 is forbidden."));
        }
        else
        {
          addFormNumericBox(F("Address of PZEM"), F("PZEM_addr"), P102_PZEM_ADDR, 0, 247);
          addHtml(F("  Address 0 allows to communicate with any <B>single</B> PZEMv30 whatever its address"));
        }

        if (P102_PZEM_ADDR_SET == 3)
        {
          addHtml(F("<span style=\"color:green\"> <br><B>Address programming done ! </B></span>"));
          P102_PZEM_ADDR_SET = 0;
        }
      }
      else
      {
        addFormSubHeader(F("PZEM actions"));
        {
          const __FlashStringHelper *options_model[2] = { F("Read_value"), F("Reset_Energy") };
          addFormSelector(F("PZEM Mode"), F("PZEM_mode"), 2, options_model, nullptr, P102_PZEM_mode);
        }
        addHtml(F(" Tx/Rx Pins config disabled: Configuration is available in the first PZEM plugin.<br>"));
        addFormNumericBox(F("Address of PZEM"), F("PZEM_addr"), P102_PZEM_ADDR, 1, 247);
      }

      addHtml(F("<br><br> Reset energy can be done also by: http://*espeasyip*/control?cmd=resetenergy,*PZEM address*"));

      if (P102_PZEM_ADDR_SET == 4)
      {
        addHtml(F("<span style=\"color:blue\"> <br><B>Energy reset on current PZEM ! </B></span>"));
        P102_PZEM_ADDR_SET = 0;
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      serialHelper_webformSave(event);


      for (uint8_t i = 0; i < P102_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P102_QUERY1_CONFIG_POS;
        const uint8_t choice = PCONFIG(pconfigIndex);
        sensorTypeHelper_saveOutputSelector(event, pconfigIndex, i, p102_getQueryString(choice));
      }
      P102_PZEM_mode = getFormItemInt(F("PZEM_mode"));
      P102_PZEM_ADDR = getFormItemInt(F("PZEM_addr"));
      P102_PZEM_ADDR_SET = getFormItemInt(F("PZEM_addr_set"));
      Plugin_102_init = false;
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {

      if (P102_PZEM_FIRST == event->TaskIndex)
      {
        int rxPin = CONFIG_PIN1;
        int txPin = CONFIG_PIN2;
        const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);

        if (P102_PZEM_sensor != nullptr) {

          delete P102_PZEM_sensor;
          P102_PZEM_sensor = nullptr;
        }


        P102_PZEM_sensor = new (std::nothrow) PZEM004Tv30(port, rxPin, txPin);


        if ((P102_PZEM_ADDR_SET == 1) && (P102_PZEM_sensor != nullptr))
        {
          P102_PZEM_sensor->setAddress(P102_PZEM_ADDR);
          P102_PZEM_mode = 0;
          P102_PZEM_ADDR_SET = 3;
        }
      }

      if (P102_PZEM_sensor != nullptr) {
        P102_PZEM_sensor->init(P102_PZEM_ADDR);


        if (P102_PZEM_mode == 1)
        {
          P102_PZEM_sensor->resetEnergy();
          P102_PZEM_mode = 0;
          P102_PZEM_ADDR_SET = 4;
        }

        Plugin_102_init = true;
        success = true;
      }
      break;
    }

    case PLUGIN_EXIT:
    {
      if (P102_PZEM_FIRST == event->TaskIndex)
      {
        if (P102_PZEM_sensor)
        {
          delete P102_PZEM_sensor;
          P102_PZEM_sensor = nullptr;
        }
      }
      break;
    }

    case PLUGIN_READ:
    {
      if (Plugin_102_init && (P102_PZEM_mode == 0))
      {

        P102_PZEM_sensor->init(P102_PZEM_ADDR);

        float PZEM[6];
        PZEM[0] = P102_PZEM_sensor->voltage();
        PZEM[1] = P102_PZEM_sensor->current();
        PZEM[2] = P102_PZEM_sensor->power();
        PZEM[3] = P102_PZEM_sensor->energy();
        PZEM[4] = P102_PZEM_sensor->pf();
        PZEM[5] = P102_PZEM_sensor->frequency();

        for (uint8_t i = 0; i < 6; i++)
        {
          if (PZEM[i] != PZEM[i])
          {
            P102_PZEM_ATTEMPT == P102_PZEM_MAX_ATTEMPT ? P102_PZEM_ATTEMPT = 0 : P102_PZEM_ATTEMPT++;
            break;
          }
          P102_PZEM_ATTEMPT = 0;
        }

        if (P102_PZEM_ATTEMPT == 0)
        {
          UserVar.setFloat(event->TaskIndex, 0, PZEM[P102_QUERY1]);
          UserVar.setFloat(event->TaskIndex, 1, PZEM[P102_QUERY2]);
          UserVar.setFloat(event->TaskIndex, 2, PZEM[P102_QUERY3]);
          UserVar.setFloat(event->TaskIndex, 3, PZEM[P102_QUERY4]);


        }
        success = true;
      }
      break;
    }

# if FEATURE_PACKED_RAW_DATA
    case PLUGIN_GET_PACKED_RAW_DATA:
    {
# 334 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P102_PZEM004Tv3.ino"
      string += LoRa_addFloat(P102_PZEM_sensor->voltage(), PackedData_int16_1e1);
      string += LoRa_addFloat(P102_PZEM_sensor->current(), PackedData_int32_1e3);
      string += LoRa_addFloat(P102_PZEM_sensor->power(), PackedData_int32_1e1);
      string += LoRa_addFloat(P102_PZEM_sensor->energy(), PackedData_int32_1e1);
      string += LoRa_addFloat(P102_PZEM_sensor->pf(), PackedData_uint16_1e2);
      string += LoRa_addFloat(P102_PZEM_sensor->frequency() - 40, PackedData_uint8_1e1);
      event->Par1 = 6;

      success = true;
      break;
    }
# endif


    case PLUGIN_WRITE:
    {
      if (Plugin_102_init)
      {
        String command = parseString(string, 1);

        if ((equals(command, F("resetenergy"))) && (P102_PZEM_FIRST == event->TaskIndex))
        {
          if ((event->Par1 >= 0) && (event->Par1 <= 247))
          {
            P102_PZEM_sensor->init(event->Par1);
            P102_PZEM_sensor->resetEnergy();
            success = true;
          }
        }
      }

      break;
    }
  }
  return success;
}

const __FlashStringHelper* p102_getQueryString(uint8_t query) {
  switch (query)
  {
    case 0: return F("Voltage_V");
    case 1: return F("Current_A");
    case 2: return F("Power_W");
    case 3: return F("Energy_WH");
    case 4: return F("Power_Factor_cosphi");
    case 5: return F("Frequency Hz");
  }
  return F("");
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P103_Atlas_EZO_pH_ORP_EC_DO.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P103
# 23 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P103_Atlas_EZO_pH_ORP_EC_DO.ino"
#define PLUGIN_103 
#define PLUGIN_ID_103 103
#define PLUGIN_NAME_103 "Environment - Atlas EZO pH ORP EC DO"
#define PLUGIN_VALUENAME1_103 "SensorData"
#define PLUGIN_VALUENAME2_103 "Voltage"

# include "src/PluginStructs/P103_data_struct.h"

boolean Plugin_103(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  AtlasEZO_Sensors_e board_type = AtlasEZO_Sensors_e::UNKNOWN;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_103;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_103);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_103));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_103));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x61, 0x62, 0x63, 0x64 };



      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c"), P103_ATLASEZO_I2C_NB_OPTIONS, i2cAddressValues, P103_I2C_ADDRESS);
        addFormNote(F("pH: 0x63, ORP: 0x62, EC: 0x64, DO: 0x61. The plugin is able to detect the type of device automatically."));
      } else {
        success = intArrayContains(P103_ATLASEZO_I2C_NB_OPTIONS, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P103_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Board"));

      P103_addDisabler();

      char boarddata[ATLAS_EZO_RETURN_ARRAY_SIZE] = { 0 };

      if (P103_send_I2C_command(P103_I2C_ADDRESS, F("i"), boarddata))
      {
        String boardInfo(boarddata);
        addRowLabel(F("Board type"));

        String board = boardInfo.substring(boardInfo.indexOf(',') + 1, boardInfo.lastIndexOf(','));
        String version = boardInfo.substring(boardInfo.lastIndexOf(',') + 1);
        addHtml(board);

        String boardTypes = F("pH  ORP EC  D.O.");
        AtlasEZO_Sensors_e boardIDs[] = {
          AtlasEZO_Sensors_e::PH,
          AtlasEZO_Sensors_e::ORP,
          AtlasEZO_Sensors_e::EC,
          AtlasEZO_Sensors_e::DO,
        };
        int bType = boardTypes.indexOf(board);

        if (bType > -1) {
          board_type = boardIDs[bType / 4];
        }

        P103_BOARD_TYPE = static_cast<uint8_t>(board_type);

        if (board_type == AtlasEZO_Sensors_e::UNKNOWN)
        {
          P103_html_red(F("  WARNING : Board type should be 'pH', 'ORP', 'EC' or 'DO', check your i2c address? "));
        }
        addRowLabel(F("Board version"));
        addHtml(version);

        addHtml(F("<input type='hidden' name='sensorVersion' value='"));
        addHtml(version);
        addHtml('\'', '>');
      }
      else
      {
        P103_html_red(F("Unable to send command to device"));

        if (board_type == AtlasEZO_Sensors_e::UNKNOWN)
        {
          P103_html_red(F("  WARNING : Board type should be 'pH', 'ORP', 'EC' or 'DO', check your i2c address? "));
        }
        success = false;
        break;
      }

      memset(boarddata, 0, ATLAS_EZO_RETURN_ARRAY_SIZE);

      if (P103_send_I2C_command(P103_I2C_ADDRESS, F("Status"), boarddata))
      {
        String boardStatus(boarddata);

        addRowLabel(F("Board restart code"));

      # ifndef BUILD_NO_DEBUG
        addLog(LOG_LEVEL_DEBUG, boardStatus);
      # endif

        char *statuschar = strchr(boarddata, ',');

        if (statuschar != nullptr)
        {
          switch (boarddata[statuschar - boarddata + 1])
          {
            case 'P':
            {
              addHtml(F("powered off"));
              break;
            }
            case 'S':
            {
              addHtml(F("software reset"));
              break;
            }
            case 'B':
            {
              addHtml(F("brown out"));
              break;
            }
            case 'W':
            {
              addHtml(F("watch dog"));
              break;
            }
            case 'U':
            default:
            {
              addHtml(F("unknown"));
              break;
            }
          }
        }

        addRowLabel(F("Board voltage"));
        addHtml(boardStatus.substring(boardStatus.lastIndexOf(',') + 1));
        addUnit('V');

        addRowLabel(F("Sensor Data"));
        addHtmlFloat(UserVar[event->BaseVarIndex]);

        switch (board_type)
        {
          case AtlasEZO_Sensors_e::PH:
          {
            addUnit(F("pH"));
            break;
          }
          case AtlasEZO_Sensors_e::ORP:
          {
            addUnit(F("mV"));
            break;
          }
          case AtlasEZO_Sensors_e::EC:
          {
            addUnit(F("&micro;S"));
            break;
          }
          case AtlasEZO_Sensors_e::DO:
          {
            addUnit(F("mg/L"));
            break;
          }
          case AtlasEZO_Sensors_e::UNKNOWN:
            break;
        }
      }
      else
      {
        P103_html_red(F("Unable to send status command to device"));
        success = false;
        break;
      }


      addFormCheckBox(F("Status LED"), F("status_led"), P103_STATUS_LED);


      if (board_type == AtlasEZO_Sensors_e::EC)
      {
        memset(boarddata, 0, ATLAS_EZO_RETURN_ARRAY_SIZE);

        if (P103_send_I2C_command(P103_I2C_ADDRESS, F("K,?"), boarddata))
        {
          String ecProbeType(boarddata);

          addFormTextBox(F("EC Probe Type"), F("ec_probe_type"), ecProbeType.substring(ecProbeType.lastIndexOf(',') + 1), 32);
          addFormCheckBox(F("Set Probe Type"), F("en_set_probe_type"), false);
        }
      }


      switch (board_type)
      {
        case AtlasEZO_Sensors_e::PH:
        {
          addFormSubHeader(F("pH Calibration"));
          addFormNote(F(
                        "Calibration for pH-Probe could be 1 (single), 2 (single, low) or 3 point (single, low, high). The sequence is important."));
          const int nb_calibration_points = P103_addCreate3PointCalibration(board_type, event, P103_I2C_ADDRESS, F("pH"), 0.0, 14.0, 2, 0.01);

          if (nb_calibration_points > 1)
          {
            memset(boarddata, 0, ATLAS_EZO_RETURN_ARRAY_SIZE);

            if (P103_send_I2C_command(P103_I2C_ADDRESS, F("Slope,?"), boarddata))
            {
              addFormNote(concat(F("Answer to 'Slope' command : "), String(boarddata)));
            }
          }
          break;
        }

        case AtlasEZO_Sensors_e::ORP:
        {
          addFormSubHeader(F("ORP Calibration"));
          P103_addCreateSinglePointCalibration(board_type, event, P103_I2C_ADDRESS, F("mV"), 0.0, 1500.0, 0, 1.0);
          break;
        }

        case AtlasEZO_Sensors_e::EC:
        {
          addFormSubHeader(F("EC Calibration"));
          P103_addCreateDryCalibration();
          P103_addCreate3PointCalibration(board_type, event, P103_I2C_ADDRESS, F("&micro;S"), 0.0, 500000.0, 0, 1.0);
          break;
        }

        case AtlasEZO_Sensors_e::DO:
        {
          addFormSubHeader(F("DO Calibration"));
          P103_addDOCalibration(P103_I2C_ADDRESS);
          break;
        }
        case AtlasEZO_Sensors_e::UNKNOWN:
          break;
      }


      P103_addClearCalibration();


      if ((board_type == AtlasEZO_Sensors_e::PH) ||
          (board_type == AtlasEZO_Sensors_e::EC) ||
          (board_type == AtlasEZO_Sensors_e::DO))
      {
        ESPEASY_RULES_FLOAT_TYPE value{};

        addFormSubHeader(F("Temperature compensation"));
        char deviceTemperatureTemplate[40] = { 0 };
        LoadCustomTaskSettings(event->TaskIndex, reinterpret_cast<uint8_t *>(&deviceTemperatureTemplate), sizeof(deviceTemperatureTemplate));
        ZERO_TERMINATE(deviceTemperatureTemplate);
        addFormTextBox(F("Temperature "), F("_template"), deviceTemperatureTemplate, sizeof(deviceTemperatureTemplate));
        addFormNote(F("You can use a formula and idealy refer to a temp sensor (directly, via ESPEasyP2P or MQTT import),"
                      " e.g. '[Pool#Temperature]'. If you don't have a sensor, you could type a fixed value like '25' or '25.5'."));

        String deviceTemperatureTemplateString(deviceTemperatureTemplate);
        String pooltempString(parseTemplate(deviceTemperatureTemplateString, 40));

        if (Calculate(pooltempString, value) != CalculateReturnCode::OK)
        {
          addFormNote(F("Formula parse error. Using fixed value!"));
          value = P103_FIXED_TEMP_VALUE;
        }

        addFormNote(strformat(F("Actual value: %.2f"), value));
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      board_type = static_cast<AtlasEZO_Sensors_e>(P103_BOARD_TYPE);

      P103_I2C_ADDRESS = getFormItemInt(F("i2c"));

      P103_SENSOR_VERSION = getFormItemFloat(F("sensorVersion"));

      char boarddata[ATLAS_EZO_RETURN_ARRAY_SIZE] = { 0 };

      if (isFormItemChecked(F("status_led")))
      {
        P103_send_I2C_command(P103_I2C_ADDRESS, F("L,1"), boarddata);
      }
      else
      {
        P103_send_I2C_command(P103_I2C_ADDRESS, F("L,0"), boarddata);
      }
      P103_STATUS_LED = isFormItemChecked(F("status_led"));

      if ((board_type == AtlasEZO_Sensors_e::EC) && isFormItemChecked(F("en_set_probe_type")))
      {
        # ifndef BUILD_NO_DEBUG
        addLog(LOG_LEVEL_DEBUG, F("isFormItemChecked"));
        # endif
        String probeType(F("K,"));
        probeType += webArg(F("ec_probe_type"));
        memset(boarddata, 0, ATLAS_EZO_RETURN_ARRAY_SIZE);
        P103_send_I2C_command(P103_I2C_ADDRESS, probeType, boarddata);
      }

      String cmd(F("Cal,"));
      bool triggerCalibrate = false;

      P103_CALIBRATION_SINGLE = getFormItemFloat(F("ref_cal_single"));
      P103_CALIBRATION_LOW = getFormItemFloat(F("ref_cal_L"));
      P103_CALIBRATION_HIGH = getFormItemFloat(F("ref_cal_H"));

      if (isFormItemChecked(F("en_cal_clear")))
      {
        cmd += F("clear");
        triggerCalibrate = true;
      }
      else if (isFormItemChecked(F("en_cal_dry")))
      {
        cmd += F("dry");
        triggerCalibrate = true;
      }
      else if (isFormItemChecked(F("en_cal_single")))
      {
        if (board_type == AtlasEZO_Sensors_e::PH)
        {
          cmd += F("mid,");
        }
        cmd += P103_CALIBRATION_SINGLE;
        triggerCalibrate = true;
      }
      else if (isFormItemChecked(F("en_cal_L")))
      {
        cmd += F("low,");
        cmd += P103_CALIBRATION_LOW;
        triggerCalibrate = true;
      }
      else if (isFormItemChecked(F("en_cal_H")))
      {
        cmd += F("high,");
        cmd += P103_CALIBRATION_HIGH;
        triggerCalibrate = true;
      }
      else if (isFormItemChecked(F("en_cal_atm")))
      {
        triggerCalibrate = true;
      }
      else if (isFormItemChecked(F("en_cal_0")))
      {
        cmd += '0';
        triggerCalibrate = true;
      }


      if (triggerCalibrate)
      {
        memset(boarddata, 0, ATLAS_EZO_RETURN_ARRAY_SIZE);
        P103_send_I2C_command(P103_I2C_ADDRESS, cmd, boarddata);
      }

      if ((board_type == AtlasEZO_Sensors_e::PH) ||
          (board_type == AtlasEZO_Sensors_e::EC) ||
          (board_type == AtlasEZO_Sensors_e::DO))
      {
        char deviceTemperatureTemplate[40] = { 0 };
        String tmpString = webArg(F("_template"));
        safe_strncpy(deviceTemperatureTemplate, tmpString.c_str(), sizeof(deviceTemperatureTemplate) - 1);
        ZERO_TERMINATE(deviceTemperatureTemplate);

        addHtmlError(SaveCustomTaskSettings(event->TaskIndex, reinterpret_cast<const uint8_t *>(&deviceTemperatureTemplate),
                                            sizeof(deviceTemperatureTemplate)));
      }

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      board_type = static_cast<AtlasEZO_Sensors_e>(P103_BOARD_TYPE);

      String readCommand;

      if ((board_type == AtlasEZO_Sensors_e::PH) ||
          (board_type == AtlasEZO_Sensors_e::EC) ||
          (board_type == AtlasEZO_Sensors_e::DO))
      {

        char deviceTemperatureTemplate[40] = { 0 };
        LoadCustomTaskSettings(event->TaskIndex, reinterpret_cast<uint8_t *>(&deviceTemperatureTemplate), sizeof(deviceTemperatureTemplate));
        ZERO_TERMINATE(deviceTemperatureTemplate);

        String deviceTemperatureTemplateString(deviceTemperatureTemplate);
        String temperatureString(parseTemplate(deviceTemperatureTemplateString, 40));

        readCommand = F("RT,");
        ESPEASY_RULES_FLOAT_TYPE temperatureReading{};

        if (Calculate(temperatureString, temperatureReading) != CalculateReturnCode::OK)
        {
          temperatureReading = P103_FIXED_TEMP_VALUE;
        }

        readCommand += temperatureReading;
      }
      else if (board_type == AtlasEZO_Sensors_e::ORP)
      {
        readCommand = F("R,");
      }


      char boarddata[ATLAS_EZO_RETURN_ARRAY_SIZE] = { 0 };
      UserVar.setFloat(event->TaskIndex, 0, -1);

      if (P103_send_I2C_command(P103_I2C_ADDRESS, readCommand, boarddata))
      {
        String sensorString(boarddata);
        float sensor_f{};
        string2float(sensorString, sensor_f);
        UserVar.setFloat(event->TaskIndex, 0, sensor_f);
      }


      memset(boarddata, 0, ATLAS_EZO_RETURN_ARRAY_SIZE);
      UserVar.setFloat(event->TaskIndex, 1, -1);

      if (P103_send_I2C_command(P103_I2C_ADDRESS, F("Status"), boarddata))
      {
        String voltage(boarddata);
        float volt_f{};
        string2float(voltage.substring(voltage.lastIndexOf(',') + 1), volt_f);
        UserVar.setFloat(event->TaskIndex, 1, volt_f);
      }

      success = true;
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P104_max7219_Dotmatrix.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P104
# 117 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P104_max7219_Dotmatrix.ino"
#define PLUGIN_104 
#define PLUGIN_ID_104 104
#define PLUGIN_NAME_104 "Display - MAX7219 dot matrix"

#define PLUGIN_104_DEBUG true


# include "src/PluginStructs/P104_data_struct.h"


boolean Plugin_104(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_104;
      Device[deviceCount].Type = DEVICE_TYPE_SPI;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].TimerOptional = false;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].ExitTaskBeforeSave = false;
      break;
    }

    case PLUGIN_SET_DEFAULTS: {
      CONFIG_PORT = -1;
      P104_CONFIG_HARDWARETYPE = static_cast<int>(MD_MAX72XX::moduleType_t::FC16_HW);
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_104);
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES: {
      event->String1 = formatGpioName_output(F("CS"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
      int8_t spi_pins[3];
      Settings.getSPI_pins(spi_pins);
      int pinnr = -1;
      bool input, output, warning;
      String note;
      note.reserve(72);
      note = F("SPI->MAX7219: MOSI");

      if (spi_pins[2] != -1) {
        getGpioInfo(spi_pins[2], pinnr, input, output, warning);
        note += wrap_braces(createGPIO_label(spi_pins[2], pinnr, true, true, false));
      }
      note += F("->DIN, CLK");

      if (spi_pins[0] != -1) {
        getGpioInfo(spi_pins[0], pinnr, input, output, warning);
        note += wrap_braces(createGPIO_label(spi_pins[0], pinnr, true, true, false));
      }
      note += F("->CLK");
      addFormNote(note);

      P104_data_struct *P104_data = static_cast<P104_data_struct *>(getPluginTaskData(event->TaskIndex));

      bool createdWhileActive = false;

      if (nullptr == P104_data) {
        P104_data = new (std::nothrow) P104_data_struct(static_cast<MD_MAX72XX::moduleType_t>(P104_CONFIG_HARDWARETYPE),
                                                        event->TaskIndex,
                                                        CONFIG_PIN1,
                                                        -1,
                                                        P104_CONFIG_ZONE_COUNT);
        createdWhileActive = true;
      }

      if (nullptr == P104_data) {
        addFormNote(F("Memory allocation error, re-open task to load."));
        return success;
      }

      if (createdWhileActive) {
        P104_data->loadSettings();
      }
      success = P104_data->webform_load(event);

      if (createdWhileActive) {
        delete P104_data;
      }
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {
      P104_data_struct *P104_data = static_cast<P104_data_struct *>(getPluginTaskData(event->TaskIndex));

      P104_CONFIG_ZONE_COUNT = getFormItemInt(F("zonecount"));
      bool createdWhileActive = false;

      if (nullptr == P104_data) {
        P104_data = new (std::nothrow) P104_data_struct(static_cast<MD_MAX72XX::moduleType_t>(P104_CONFIG_HARDWARETYPE),
                                                        event->TaskIndex,
                                                        CONFIG_PIN1,
                                                        -1,
                                                        P104_CONFIG_ZONE_COUNT);
        createdWhileActive = true;
      }

      if (nullptr != P104_data) {
        P104_data->setZones(P104_CONFIG_ZONE_COUNT);
        success = P104_data->webform_save(event);

        if (!success) {
          addHtmlError(P104_data->getError());
        }

        if (createdWhileActive) {
          delete P104_data;
        }
      }

      break;
    }

    case PLUGIN_INIT: {
      uint8_t numDevices = P104_CONFIG_TOTAL_UNITS;

      if (numDevices == 0) {
        numDevices++;
      }
      # ifdef P104_DEBUG

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        addLogMove(LOG_LEVEL_INFO, concat(F("dotmatrix: PLUGIN_INIT numDevices: "), numDevices));
      }
      # endif

      initPluginTaskData(event->TaskIndex,
                         new (std::nothrow) P104_data_struct(static_cast<MD_MAX72XX::moduleType_t>(P104_CONFIG_HARDWARETYPE),
                                                             event->TaskIndex,
                                                             CONFIG_PIN1,
                                                             numDevices,
                                                             P104_CONFIG_ZONE_COUNT));

      P104_data_struct *P104_data =
        static_cast<P104_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P104_data) {
        return success;
      }

      P104_data->logAllText = bitRead(P104_CONFIG_FLAGS, P104_CONFIG_FLAG_LOG_ALL_TEXT);


      if (P104_data->begin()) {

        P104_data->configureZones();

        success = true;
      }
      break;
    }

    case PLUGIN_EXIT: {
      P104_data_struct *P104_data = static_cast<P104_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr == P104_data) || (nullptr == P104_data->P)) {
        return success;
      }

      if (bitRead(P104_CONFIG_FLAGS, P104_CONFIG_FLAG_CLEAR_DISABLE)) {
        P104_data->P->displayClear();
      }
      success = true;

      break;
    }

    case PLUGIN_WRITE: {
      P104_data_struct *P104_data = static_cast<P104_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P104_data) {
        success = P104_data->handlePluginWrite(event->TaskIndex, string);
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND: {
      P104_data_struct *P104_data = static_cast<P104_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P104_data) && (nullptr != P104_data->P)) {
        P104_data->P->displayAnimate();
        success = true;
      }

      break;
    }

    case PLUGIN_ONCE_A_SECOND: {
      P104_data_struct *P104_data = static_cast<P104_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P104_data) && (nullptr != P104_data->P)) {
        if (P104_data->P->displayAnimate()) {
          for (uint8_t z = 0; z < P104_CONFIG_ZONE_COUNT; z++) {
            if (P104_data->P->getZoneStatus(z)) {
              P104_data->checkRepeatTimer(z);
            }
          }

          P104_data->handlePluginOncePerSecond(event);
        }
        success = true;
      }
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P105_AHT.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P105
# 36 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P105_AHT.ino"
# include "src/PluginStructs/P105_data_struct.h"

#define PLUGIN_105 
#define PLUGIN_ID_105 105
#define PLUGIN_NAME_105 "Environment - AHT10/AHT2x"
#define PLUGIN_VALUENAME1_105 "Temperature"
#define PLUGIN_VALUENAME2_105 "Humidity"


boolean Plugin_105(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_105;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_HUM;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_105);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_105));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_105));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[2] = { 0x38, 0x39 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, PCONFIG(0));
        addFormNote(F("SDO Low=0x38, High=0x39. NB: Only available on AHT10 sensors."));
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }

      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      if (static_cast<AHTx_device_type>(PCONFIG(1)) == AHTx_device_type::AHT10_DEVICE) {
        bool hasOtherI2CDevices = false;

        for (taskIndex_t x = 0; validTaskIndex(x) && !hasOtherI2CDevices; x++) {
          const deviceIndex_t DeviceIndex = getDeviceIndex_from_TaskIndex(x);

          if (validDeviceIndex(DeviceIndex)
              && (Settings.TaskDeviceDataFeed[x] == 0)
              && ((Device[DeviceIndex].Type == DEVICE_TYPE_I2C)
                # ifdef PLUGIN_USES_SERIAL
                  || (Device[DeviceIndex].Type == DEVICE_TYPE_SERIAL)
                  || (Device[DeviceIndex].Type == DEVICE_TYPE_SERIAL_PLUS1)
                # endif
                  )
              ) {
            hasOtherI2CDevices = true;
          }
        }

        if (hasOtherI2CDevices) {
          addRowLabel(EMPTY_STRING, EMPTY_STRING);
          addHtmlDiv(F("note warning"),
                     F("Attention: Sensor model AHT10 may cause I2C issues when combined with other I2C devices on the same bus!"));
        }
      }
      {
        const __FlashStringHelper *options[] = { F("AHT10"), F("AHT20"), F("AHT21") };
        const int indices[] = { static_cast<int>(AHTx_device_type::AHT10_DEVICE),
                                                 static_cast<int>(AHTx_device_type::AHT20_DEVICE),
                                                 static_cast<int>(AHTx_device_type::AHT21_DEVICE) };
        addFormSelector(F("Sensor model"), F("ahttype"), 3, options, indices, PCONFIG(1), true);
        addFormNote(F("Changing Sensor model will reload the page."));
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(1) = getFormItemInt(F("ahttype"));

      if (static_cast<AHTx_device_type>(PCONFIG(1)) != AHTx_device_type::AHT10_DEVICE) {
        PCONFIG(0) = 0x38;
      } else {
        PCONFIG(0) = getFormItemInt(F("i2c_addr"));
      }
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(
        event->TaskIndex,
        new (std::nothrow) P105_data_struct(PCONFIG(0), static_cast<AHTx_device_type>(PCONFIG(1))));
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P105_data_struct *P105_data =
        static_cast<P105_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P105_data) {
        if (P105_data->updateMeasurements(event->TaskIndex)) {

          Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 10);
        }
      }
      break;
    }

    case PLUGIN_READ:
    {
      P105_data_struct *P105_data =
        static_cast<P105_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P105_data) {
        if (P105_data->state != AHTx_state::AHTx_New_values) {
          break;
        }
        P105_data->state = AHTx_state::AHTx_Values_read;

        UserVar.setFloat(event->TaskIndex, 0, P105_data->getTemperature());
        UserVar.setFloat(event->TaskIndex, 1, P105_data->getHumidity());

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log;
          log.reserve(60);
          log = P105_data->getDeviceName();
          log += F(" : Addr: 0x");
          log += String(PCONFIG(0), HEX);
          addLogMove(LOG_LEVEL_INFO, log);
          log = P105_data->getDeviceName();
          log += F(" : Temperature: ");
          log += formatUserVarNoCheck(event->TaskIndex, 0);
          log += F(" : Humidity: ");
          log += formatUserVarNoCheck(event->TaskIndex, 1);
          addLogMove(LOG_LEVEL_INFO, log);
        }
        success = true;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P106_BME680.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P106
# 27 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P106_BME680.ino"
# include "src/PluginStructs/P106_data_struct.h"


#define PLUGIN_106 
#define PLUGIN_ID_106 106
#define PLUGIN_NAME_106 "Environment - BME68x"
#define PLUGIN_VALUENAME1_106 "Temperature"
#define PLUGIN_VALUENAME2_106 "Humidity"
#define PLUGIN_VALUENAME3_106 "Pressure"
#define PLUGIN_VALUENAME4_106 "Gas"


boolean Plugin_106(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_106;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_106);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_106));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_106));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_106));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_106));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x77, 0x76 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, P106_I2C_ADDRESS);
        addFormNote(F("SDO Low=0x76, High=0x77"));
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P106_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Altitude"), F("elev"), P106_ALTITUDE);
      addUnit('m');

      addFormCheckBox(F("Present `Gas` in Ohm (not kOhm)"), F("gas"), P106_GET_OPT_GAS_OHM);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P106_I2C_ADDRESS = getFormItemInt(F("i2c_addr"));
      P106_ALTITUDE = getFormItemInt(F("elev"));
      P106_SET_OPT_GAS_OHM(isFormItemChecked(F("gas")));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P106_data_struct());
      P106_data_struct *P106_data =
        static_cast<P106_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P106_data) {
        P106_data->initialized = false;
        success = P106_data->begin(P106_I2C_ADDRESS);
      }
      break;
    }

    case PLUGIN_READ:
    {
      P106_data_struct *P106_data =
        static_cast<P106_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P106_data)
      {
        P106_data->begin(P106_I2C_ADDRESS);

        if (!P106_data->initialized) {
          break;
        }

        if (!P106_data->performReading()) {
          P106_data->initialized = false;
          addLog(LOG_LEVEL_ERROR, F("BME68x : Failed to perform reading!"));
          break;
        }

        UserVar.setFloat(event->TaskIndex, 0, P106_data->getTemperature());
        UserVar.setFloat(event->TaskIndex, 1, P106_data->getHumidity());
        UserVar.setFloat(event->TaskIndex, 3, P106_GET_OPT_GAS_OHM ? P106_data->getGasResistance() : P106_data->getGasResistance() / 1000.0f);

        const int elev = P106_ALTITUDE;

        if (elev != 0)
        {
          UserVar.setFloat(event->TaskIndex, 2, pressureElevation(P106_data->getPressure(), elev));
        } else {
          UserVar.setFloat(event->TaskIndex, 2, P106_data->getPressure());
        }
      }

      success = true;
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P107_SI1145.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P107





# include "src/PluginStructs/P107_data_struct.h"

#define PLUGIN_107 
#define PLUGIN_ID_107 107
#define PLUGIN_NAME_107 "UV - SI1145"
#define PLUGIN_VALUENAME1_107 "Visible"
#define PLUGIN_VALUENAME2_107 "Infra"
#define PLUGIN_VALUENAME3_107 "UV"

boolean Plugin_107(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_107;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_107);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_107));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_107));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_107));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x60);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x60;
      success = true;
      break;
    }
    # endif

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P107_data_struct());
      P107_data_struct *P107_data =
        static_cast<P107_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P107_data && P107_data->begin());
      break;
    }

    case PLUGIN_READ:
    {
      P107_data_struct *P107_data =
        static_cast<P107_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P107_data) {
        break;
      }

      if (!P107_data->begin()) {
        break;
      }
      delay(8);

      UserVar.setFloat(event->TaskIndex, 0, P107_data->uv.readVisible());
      UserVar.setFloat(event->TaskIndex, 1, P107_data->uv.readIR());
      UserVar.setFloat(event->TaskIndex, 2, P107_data->uv.readUV() / 100.0f);

      P107_data->uv.reset();

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log = F("SI1145: Visible: ");
        log += formatUserVarNoCheck(event->TaskIndex, 0);
        addLogMove(LOG_LEVEL_INFO, log);
        log = F("SI1145: Infrared: ");
        log += formatUserVarNoCheck(event->TaskIndex, 1);
        addLogMove(LOG_LEVEL_INFO, log);
        log = F("SI1145: UV index: ");
        log += formatUserVarNoCheck(event->TaskIndex, 2);
        addLogMove(LOG_LEVEL_INFO, log);
      }
      success = true;
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P108_DDS238.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P108

# include "src/PluginStructs/P108_data_struct.h"
# 29 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P108_DDS238.ino"
#define PLUGIN_108 
#define PLUGIN_ID_108 108
#define PLUGIN_NAME_108 "Energy (AC) - DDS238-x ZN"
#define PLUGIN_VALUENAME1_108 ""


boolean Plugin_108(uint8_t function, struct EventStruct *event, String& string) {
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD: {
      Device[++deviceCount].Number = PLUGIN_ID_108;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL_PLUS1;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = P108_NR_OUTPUT_VALUES;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME: {
      string = F(PLUGIN_NAME_108);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < P108_NR_OUTPUT_VALUES) {
          const uint8_t pconfigIndex = i + P108_QUERY1_CONFIG_POS;
          uint8_t choice = PCONFIG(pconfigIndex);
          ExtraTaskSettings.setTaskDeviceValueName(i, Plugin_108_valuename(choice, false));
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES: {
      serialHelper_getGpioNames(event);
      event->String3 = formatGpioName_output_optional(F("DE"));
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS: {
      P108_DEV_ID = P108_DEV_ID_DFLT;
      P108_MODEL = P108_MODEL_DFLT;
      P108_BAUDRATE = P108_BAUDRATE_DFLT;
      P108_QUERY1 = P108_QUERY1_DFLT;
      P108_QUERY2 = P108_QUERY2_DFLT;
      P108_QUERY3 = P108_QUERY3_DFLT;
      P108_QUERY4 = P108_QUERY4_DFLT;

      success = true;
      break;
    }

    case PLUGIN_WRITE: {
      break;
    }

    case PLUGIN_WEBFORM_SHOW_SERIAL_PARAMS:
    {
      String options_baudrate[4];

      for (int i = 0; i < 4; ++i) {
        options_baudrate[i] = String(p108_storageValueToBaudrate(i));
      }
      addFormSelector(F("Baud Rate"), P108_BAUDRATE_LABEL, 4, options_baudrate, nullptr, P108_BAUDRATE);
      addUnit(F("baud"));
      addFormNumericBox(F("Modbus Address"), P108_DEV_ID_LABEL, P108_DEV_ID, 1, 247);
      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      const __FlashStringHelper *options[P108_NR_OUTPUT_OPTIONS];

      for (int i = 0; i < P108_NR_OUTPUT_OPTIONS; ++i) {
        options[i] = Plugin_108_valuename(i, true);
      }

      for (uint8_t i = 0; i < P108_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P108_QUERY1_CONFIG_POS;
        sensorTypeHelper_loadOutputSelector(event, pconfigIndex, i, P108_NR_OUTPUT_OPTIONS, options);
      }
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD: {
      P108_data_struct *P108_data =
        static_cast<P108_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P108_data) && P108_data->isInitialized()) {
        addFormNote(P108_data->modbus.detected_device_description);
        addRowLabel(F("Checksum (pass/fail/nodata)"));
        uint32_t reads_pass, reads_crc_failed, reads_nodata;
        P108_data->modbus.getStatistics(reads_pass, reads_crc_failed, reads_nodata);
        String chksumStats;
        chksumStats = reads_pass;
        chksumStats += '/';
        chksumStats += reads_crc_failed;
        chksumStats += '/';
        chksumStats += reads_nodata;
        addHtml(chksumStats);

        addFormSubHeader(F("Logged Values"));
        p108_showValueLoadPage(P108_QUERY_Wh_imp, event);
        p108_showValueLoadPage(P108_QUERY_Wh_exp, event);
        p108_showValueLoadPage(P108_QUERY_Wh_tot, event);
        p108_showValueLoadPage(P108_QUERY_V, event);
        p108_showValueLoadPage(P108_QUERY_A, event);
        p108_showValueLoadPage(P108_QUERY_W, event);
        p108_showValueLoadPage(P108_QUERY_VA, event);
        p108_showValueLoadPage(P108_QUERY_PF, event);
        p108_showValueLoadPage(P108_QUERY_F, event);







      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE: {



      for (int i = 0; i < P108_QUERY1_CONFIG_POS; ++i) {
        pconfig_webformSave(event, i);
      }


      for (uint8_t i = 0; i < P108_NR_OUTPUT_VALUES; ++i) {
        const uint8_t pconfigIndex = i + P108_QUERY1_CONFIG_POS;
        const uint8_t choice = PCONFIG(pconfigIndex);
        sensorTypeHelper_saveOutputSelector(event, pconfigIndex, i, Plugin_108_valuename(choice, false));
      }
# 208 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P108_DDS238.ino"
      success = true;
      break;
    }

    case PLUGIN_INIT: {
      const int16_t serial_rx = CONFIG_PIN1;
      const int16_t serial_tx = CONFIG_PIN2;
      const ESPEasySerialPort port = static_cast<ESPEasySerialPort>(CONFIG_PORT);
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P108_data_struct());
      P108_data_struct *P108_data =
        static_cast<P108_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P108_data) {
        return success;
      }

      if (P108_data->init(port, serial_rx, serial_tx, P108_DEPIN,
                          p108_storageValueToBaudrate(P108_BAUDRATE),
                          P108_DEV_ID)) {
        serialHelper_log_GpioDescription(port, serial_rx, serial_tx);
        success = true;
      } else {
        clearPluginTaskData(event->TaskIndex);
      }
      break;
    }

    case PLUGIN_EXIT: {
      success = true;
      break;
    }

    case PLUGIN_READ: {
      P108_data_struct *P108_data =
        static_cast<P108_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P108_data) && P108_data->isInitialized()) {
        for (int i = 0; i < P108_NR_OUTPUT_VALUES; ++i) {
          UserVar.setFloat(event->TaskIndex, i, p108_readValue(PCONFIG(i + P108_QUERY1_CONFIG_POS), event));
          delay(1);
        }

        success = true;
      }
      break;
    }

# if FEATURE_PACKED_RAW_DATA
    case PLUGIN_GET_PACKED_RAW_DATA:
    {

      P108_data_struct *P108_data =
        static_cast<P108_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P108_data) && P108_data->isInitialized()) {



        for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
          const uint8_t pconfigIndex = i + P108_QUERY1_CONFIG_POS;
          const uint8_t choice = PCONFIG(pconfigIndex);
          string += LoRa_addInt(choice, PackedData_uint8);
          string += LoRa_addFloat(UserVar[event->BaseVarIndex + i], PackedData_int32_1e4);
        }
        event->Par1 = 8;

        success = true;
      }
      break;
    }
# endif
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P109_ThermOLED.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P109

# include "src/PluginStructs/P109_data_struct.h"
# 71 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P109_ThermOLED.ino"
#define PLUGIN_109 
#define PLUGIN_ID_109 109
#define PLUGIN_NAME_109 "Display - OLED SSD1306/SH1106 Thermo"
#define PLUGIN_VALUENAME1_109 "setpoint"
#define PLUGIN_VALUENAME2_109 "heating"
#define PLUGIN_VALUENAME3_109 "mode"
#define PLUGIN_VALUENAME4_109 "timeout"


boolean Plugin_109(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_109;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_109);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_109));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_109));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_109));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_109));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P109_CONFIG_RELAYPIN = -1;
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      success = OLedI2CAddressCheck(function, event->Par1, F("pi2caddr"), P109_CONFIG_I2CADDRESS);

      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P109_CONFIG_I2CADDRESS;
      success = true;
      break;
    }
    # endif

    # ifndef LIMIT_BUILD_SIZE
    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      const char* separator = event->String1.c_str();
      string = strformat(
        F("Btn L: %s%sBtn R: %s%sBtn M: %s%sRelay: %s"),
       formatGpioLabel(CONFIG_PIN1, false).c_str(),
       separator,
       formatGpioLabel(CONFIG_PIN2, false).c_str(),
       separator,
       formatGpioLabel(CONFIG_PIN3, false).c_str(),
       separator,
       formatGpioLabel(P109_CONFIG_RELAYPIN, false).c_str());
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      OLedFormController(F("controller"), nullptr, P109_CONFIG_DISPLAYTYPE);

      OLedFormRotation(F("rotate"), P109_CONFIG_ROTATION);

      OLedFormContrast(F("contrast"), P109_CONFIG_CONTRAST);

      {
        P109_data_struct *P109_data = new (std::nothrow) P109_data_struct();

        if (nullptr != P109_data) {
          success = P109_data->plugin_webform_load(event);
          delete P109_data;
        }
      }

      addFormPinSelect(PinSelectPurpose::Generic_input, F("Button left/down"), F("taskdevicepin1"), CONFIG_PIN1);
      addFormPinSelect(PinSelectPurpose::Generic_input, F("Button right/up"), F("taskdevicepin2"), CONFIG_PIN2);
      addFormPinSelect(PinSelectPurpose::Generic_input, F("Button mode"), F("taskdevicepin3"), CONFIG_PIN3);

      addFormPinSelect(PinSelectPurpose::Generic_output, F("Relay"), F("heatrelay"), P109_CONFIG_RELAYPIN);

      addFormCheckBox(F("Invert relay-state (0=on, 1=off)"), F("invertrelay"), P109_GET_RELAY_INVERT);

      {
        const __FlashStringHelper *options4[] = { F("0.2"), F("0.5"), F("1") };
        const int optionValues4[] = { 2, 5, 10 };
        addFormSelector(F("Hysteresis"), F("hyst"), 3, options4, optionValues4, static_cast<int>(P109_CONFIG_HYSTERESIS * 10.0f));
      }

      {
        addFormCheckBox(F("Alternate Sysname/SSID in title"), F("palt"), P109_GET_ALTERNATE_HEADER == 0);

        addFormCheckBox(F("Use Taskname instead of Sysname"), F("ptask"), P109_GET_TASKNAME_IN_TITLE == 1);
      }

      {
        if (P109_CONFIG_SETPOINT_DELAY == 0) { P109_CONFIG_SETPOINT_DELAY = P109_DEFAULT_SETPOINT_DELAY + P109_SETPOINT_OFFSET; }
        addFormNumericBox(F("Delay on setpoint change"), F("setpdelay"), P109_CONFIG_SETPOINT_DELAY - P109_SETPOINT_OFFSET, 1, 10);
        addUnit('s');
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P109_CONFIG_I2CADDRESS = getFormItemInt(F("pi2caddr"));
      P109_CONFIG_ROTATION = getFormItemInt(F("rotate"));
      P109_CONFIG_DISPLAYTYPE = getFormItemInt(F("controller"));
      P109_CONFIG_CONTRAST = getFormItemInt(F("contrast"));
      P109_CONFIG_RELAYPIN = getFormItemInt(F("heatrelay"));
      P109_CONFIG_HYSTERESIS = (getFormItemInt(F("hyst")) / 10.0f);
      P109_CONFIG_SETPOINT_DELAY = getFormItemInt(F("setpdelay")) + P109_SETPOINT_OFFSET;
      uint32_t lSettings = 0u;
      bitWrite(lSettings, P109_FLAG_TASKNAME_IN_TITLE, isFormItemChecked(F("ptask")));
      bitWrite(lSettings, P109_FLAG_ALTERNATE_HEADER, !isFormItemChecked(F("palt")));
      bitWrite(lSettings, P109_FLAG_RELAY_INVERT, isFormItemChecked(F("invertrelay")));
      P109_FLAGS = lSettings;

      {
        P109_data_struct *P109_data = new (std::nothrow) P109_data_struct();

        if (nullptr != P109_data) {
          success = P109_data->plugin_webform_save(event);
          delete P109_data;
        }
      }

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P109_data_struct());
      P109_data_struct *P109_data = static_cast<P109_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P109_data) {
        if (P109_CONFIG_SETPOINT_DELAY == 0) { P109_CONFIG_SETPOINT_DELAY = P109_DEFAULT_SETPOINT_DELAY + P109_SETPOINT_OFFSET; }
        success = P109_data->plugin_init(event);
      }

      break;
    }

    case PLUGIN_EXIT:
    {
      P109_data_struct *P109_data = static_cast<P109_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P109_data) {
        success = P109_data->plugin_exit(event);
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P109_data_struct *P109_data = static_cast<P109_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P109_data) {
        success = P109_data->plugin_ten_per_second(event);
      }

      break;
    }


    case PLUGIN_ONCE_A_SECOND:
    {
      P109_data_struct *P109_data = static_cast<P109_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P109_data) {
        success = P109_data->plugin_once_a_second(event);
      }

      break;
    }

    case PLUGIN_READ:
    {
      P109_data_struct *P109_data = static_cast<P109_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P109_data) {
        success = P109_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_WRITE:
    {
      P109_data_struct *P109_data = static_cast<P109_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P109_data) {
        success = P109_data->plugin_write(event, string);
      }

      break;
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P110_VL53L0X.ino"
#ifdef USES_P110
# 18 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P110_VL53L0X.ino"
#include "src/PluginStructs/P110_data_struct.h"

#define PLUGIN_110 
#define PLUGIN_ID_110 110
#define PLUGIN_NAME_110 "Distance - VL53L0X (200cm)"
#define PLUGIN_VALUENAME1_110 "Distance"






boolean Plugin_110(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_110;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_110);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_110));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x29, 0x30 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2cAddr"), 2, i2cAddressValues, P110_I2C_ADDRESS);
        #ifndef BUILD_NO_DEBUG
        addFormNote(F("SDO Low=0x29, High=0x30"));
        #endif
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P110_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *optionsMode2[3] = {
          F("Normal"),
          F("Fast"),
          F("Accurate") };
        const int optionValuesMode2[3] = { 80, 20, 320 };
        addFormSelector(F("Timing"), F("ptiming"), 3, optionsMode2, optionValuesMode2, P110_TIMING);
      }

      {
        const __FlashStringHelper *optionsMode3[2] = {
          F("Normal"),
          F("Long") };
        const int optionValuesMode3[2] = { 0, 1 };
        addFormSelector(F("Range"), F("prange"), 2, optionsMode3, optionValuesMode3, P110_RANGE);
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P110_I2C_ADDRESS = getFormItemInt(F("i2cAddr"));
      P110_TIMING = getFormItemInt(F("ptiming"));
      P110_RANGE = getFormItemInt(F("prange"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P110_data_struct(P110_I2C_ADDRESS, P110_TIMING, P110_RANGE == 1));
      P110_data_struct *P110_data = static_cast<P110_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P110_data) && P110_data->begin();
      break;
    }
    case PLUGIN_READ:
    {
      P110_data_struct *P110_data = static_cast<P110_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P110_data) {
        long dist = P110_data->readDistance();

        success = P110_data->isReadSuccessful();

        if (success) {
          UserVar.setFloat(event->TaskIndex, 0, dist);
        }
      }
      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P110_data_struct *P110_data = static_cast<P110_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P110_data) {
        success = P110_data->plugin_fifty_per_second();
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P111_RC522_RFID.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P111
# 22 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P111_RC522_RFID.ino"
#define PLUGIN_111 
#define PLUGIN_ID_111 111
#define PLUGIN_NAME_111 "RFID - RC522"
#define PLUGIN_VALUENAME1_111 "Tag"

# include "src/PluginStructs/P111_data_struct.h"

boolean Plugin_111(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_111;
      Device[deviceCount].Type = DEVICE_TYPE_SPI2;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_ULONG;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_111);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_111));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("CS PIN"));
      event->String2 = formatGpioName_output_optional(F("RST PIN "));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P111_REMOVALTIMEOUT = 500;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Options"));

      {
        # ifdef P111_USE_REMOVAL
        # define P111_removaltypes 3
        # else
        # define P111_removaltypes 2
        # endif
        const __FlashStringHelper *removaltype[P111_removaltypes] = {
          F("None"),
          F("Autoremove after Time-out"),
          # ifdef P111_USE_REMOVAL
          F("Tag removal detection + Time-out")
          # endif
        };
        const int removalopts[P111_removaltypes] = {
          1, 0,
          # ifdef P111_USE_REMOVAL
          2
          # endif
        };
        addFormSelector(F("Tag removal mode"), F("autotagremoval"), P111_removaltypes, removaltype, removalopts, P111_TAG_AUTOREMOVAL);
      }

      addFormNumericBox(F("Tag removal Time-out"), F("removaltimeout"), P111_REMOVALTIMEOUT, 0, 60000);
      addUnit(F("mSec. (0..60000)"));

      addFormNumericBox(F("Value to set on Tag removal"), F("removalvalue"), P111_REMOVALVALUE, 0, 2147483647);


      addFormCheckBox(F("Event on Tag removal"), F("sendreset"), P111_SENDRESET == 1);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P111_TAG_AUTOREMOVAL = getFormItemInt(F("autotagremoval"));
      P111_SENDRESET = isFormItemChecked(F("sendreset")) ? 1 : 0;
      P111_REMOVALVALUE = getFormItemInt(F("removalvalue"));
      P111_REMOVALTIMEOUT = getFormItemInt(F("removaltimeout"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P111_data_struct(P111_CS_PIN, P111_RST_PIN));
      P111_data_struct *P111_data = static_cast<P111_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P111_data) {
        P111_data->init();

        success = true;
      }

      break;
    }

    case PLUGIN_TASKTIMER_IN:
    {

      if (P111_TAG_AUTOREMOVAL == 0
          # ifdef P111_USE_REMOVAL
          || P111_TAG_AUTOREMOVAL == 2
          # endif
          ) {
        UserVar.setSensorTypeLong(event->TaskIndex, P111_REMOVALVALUE);
        addLog(LOG_LEVEL_INFO, F("MFRC522: Removed Tag"));

        if (P111_SENDRESET == 1) {
          sendData(event);
        }
        success = true;
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P111_data_struct *P111_data = static_cast<P111_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P111_data) {
        success = P111_data->plugin_ten_per_second(event);
      }

      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P111_data_struct *P111_data = static_cast<P111_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P111_data) {
        success = P111_data->plugin_fifty_per_second();
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P112_AS7265x.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P112
# 17 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P112_AS7265x.ino"
# include "src/PluginStructs/P112_data_struct.h"

#define PLUGIN_112 
#define PLUGIN_ID_112 112
#define PLUGIN_NAME_112 "Color - AS7265X"
#define PLUGIN_VALUENAME1_112 "TempMaster"
#define PLUGIN_VALUENAME2_112 "TempAverage"
#define PLUGIN_VALUENAME3_112 "State"
#define AS7265X_ADDR 0x49

boolean Plugin_112(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_112;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].DecimalsOnly = true;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::All;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_112);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_112));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_112));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_112));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[1] = { AS7265X_ADDR };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 1, i2cAddressValues, AS7265X_ADDR);
      } else {
        success = (event->Par1 == AS7265X_ADDR);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = AS7265X_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG_LONG(0) = AS7265X_GAIN_37X;
      PCONFIG_LONG(1) = 254;
      PCONFIG(0) = 0;
      PCONFIG(1) = AS7265X_INDICATOR_CURRENT_LIMIT_8MA;
      PCONFIG(2) = AS7265X_LED_CURRENT_LIMIT_12_5MA;
      PCONFIG(3) = AS7265X_LED_CURRENT_LIMIT_12_5MA;
      PCONFIG(4) = AS7265X_LED_CURRENT_LIMIT_12_5MA;
      PCONFIG(5) = 0;
      PCONFIG(6) = 1;

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      {




        const __FlashStringHelper *optionsMode[] = {
          F("1x"),
          F("3.7x (default)"),
          F("16x"),
          F("64x"),
        };
        const int optionValuesMode[] = {
          AS7265X_GAIN_1X,
          AS7265X_GAIN_37X,
          AS7265X_GAIN_16X,
          AS7265X_GAIN_64X,
        };
        addFormSelector(F("Gain"), F("Gain"), 4, optionsMode, optionValuesMode, PCONFIG_LONG(0));
      }
      {



        const __FlashStringHelper *optionsMode2[] = {
          F("2.8 ms"),
          F("28 ms"),
          F("56 ms"),
          F("140 ms"),
          F("280 ms"),
          F("711 ms (default)"),
        };
        const int optionValuesMode2[] = {
          0,
          9,
          19,
          49,
          99,
          254,
        };
        addFormSelector(F("Integration Time"), F("IntegrationTime"), 6, optionsMode2, optionValuesMode2, PCONFIG_LONG(1));
      }
      addFormNote(F("Raw Readings shall not reach the upper limit of 65535 (Sensor Saturation)."));

      addFormSubHeader(F("LED settings"));
      addFormCheckBox(F("Blue"), PCONFIG_LABEL(0), PCONFIG(0));
      addHtml(F(" Status LED On"));
      {




        const __FlashStringHelper *optionsMode3[] = {
          F("1 mA"),
          F("2 mA"),
          F("4 mA"),
          F("8 mA (default)"),
        };
        const int optionValuesMode3[] = {
          AS7265X_INDICATOR_CURRENT_LIMIT_1MA,
          AS7265X_INDICATOR_CURRENT_LIMIT_2MA,
          AS7265X_INDICATOR_CURRENT_LIMIT_4MA,
          AS7265X_INDICATOR_CURRENT_LIMIT_8MA,
        };
        addFormSelector(EMPTY_STRING, PCONFIG_LABEL(1), 4, optionsMode3, optionValuesMode3, PCONFIG(1));
      }
      addHtml(F(" Current Limit"));
      addFormNote(F("Activate Status LEDs only for debugging purpose."));

      {





        const __FlashStringHelper *optionsMode4[] = {
          F("12.5 mA (default)"),
          F("25 mA"),
          F("50 mA"),
          F("100 mA"),
        };
        const int optionValuesMode4[] = {
          AS7265X_LED_CURRENT_LIMIT_12_5MA,
          AS7265X_LED_CURRENT_LIMIT_25MA,
          AS7265X_LED_CURRENT_LIMIT_50MA,
          AS7265X_LED_CURRENT_LIMIT_100MA,
        };
        addFormSelector(F("White"), PCONFIG_LABEL(2), 4, optionsMode4, optionValuesMode4, PCONFIG(2));
      }
      addHtml(F(" Current Limit"));

      {





        const __FlashStringHelper *optionsMode5[] = {
          F("12.5 mA (default)"),
          F("25 mA"),
          F("50 mA"),
        };
        const int optionValuesMode5[] = {
          AS7265X_LED_CURRENT_LIMIT_12_5MA,
          AS7265X_LED_CURRENT_LIMIT_25MA,
          AS7265X_LED_CURRENT_LIMIT_50MA,
        };
        addFormSelector(F("IR"), PCONFIG_LABEL(3), 3, optionsMode5, optionValuesMode5, PCONFIG(3));
      }

      {





        const __FlashStringHelper *optionsMode6[] = { F("12.5 mA (default)") };
        const int optionValuesMode6[] = { AS7265X_LED_CURRENT_LIMIT_12_5MA };
        addFormSelector(F("UV"), PCONFIG_LABEL(4), 1, optionsMode6, optionValuesMode6, PCONFIG(4));
      }
      addFormNote(F("Control Gain and Integration Time after any change to avoid Sensor Saturation!"));

      addFormSubHeader(F("Measurement settings"));
      addFormCheckBox(F("LEDs"), PCONFIG_LABEL(5), PCONFIG(5));
      addHtml(F(" White, IR and UV On"));
      addFormCheckBox(F("Calibrated Readings"), PCONFIG_LABEL(6), PCONFIG(6));
      addFormNote(F("Unchecked (Raw Readings): Use only for the adjustment of Device and LED settings"));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG_LONG(0) = getFormItemInt(F("Gain"));
      PCONFIG_LONG(1) = getFormItemInt(F("IntegrationTime"));
      PCONFIG(0) = isFormItemChecked(PCONFIG_LABEL(0));
      for (int i = 1; i <= 4; ++i) {
        PCONFIG(i) = getFormItemInt(PCONFIG_LABEL(i));
      }
      PCONFIG(5) = isFormItemChecked(PCONFIG_LABEL(5));
      PCONFIG(6) = isFormItemChecked(PCONFIG_LABEL(6));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P112_data_struct());
      P112_data_struct *P112_data =
        static_cast<P112_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P112_data) {
        P112_data->initialized = false;

        if (P112_data->begin()) {
          addLog(LOG_LEVEL_INFO, F("AS7265X: Found sensor"));

          success = P112_data->initialized;
          P112_data->sensor.setGain(PCONFIG_LONG(0));
          P112_data->sensor.setIntegrationCycles(PCONFIG_LONG(1));

          if (PCONFIG(0))
          {
            P112_data->sensor.enableIndicator();
          } else {
            P112_data->sensor.disableIndicator();
          }
          P112_data->sensor.setIndicatorCurrent(PCONFIG(1));

          P112_data->sensor.disableBulb(AS7265x_LED_WHITE);
          P112_data->sensor.disableBulb(AS7265x_LED_IR);
          P112_data->sensor.disableBulb(AS7265x_LED_UV);
          P112_data->sensor.setBulbCurrent(PCONFIG(2), AS7265x_LED_WHITE);
          P112_data->sensor.setBulbCurrent(PCONFIG(3), AS7265x_LED_IR);
          P112_data->sensor.setBulbCurrent(PCONFIG(4), AS7265x_LED_UV);

          if (loglevelActiveFor(LOG_LEVEL_INFO)) {
            addLogMove(LOG_LEVEL_INFO, strformat(
              F("AS7265X: AMS Device Type: 0x%X HW ver: 0x%X FW ver: %X.%X.%X"),
              P112_data->sensor.getDeviceType(),
              P112_data->sensor.getHardwareVersion(),
              P112_data->sensor.getMajorFirmwareVersion(),
              P112_data->sensor.getPatchFirmwareVersion(),
              P112_data->sensor.getBuildFirmwareVersion()));
          }

          success = true;
        } else {
          addLog(LOG_LEVEL_INFO, F("AS7265X: No sensor found"));
          success = false;
        }
      }
      break;
    }
    case PLUGIN_TEN_PER_SECOND:
    {
      P112_data_struct *P112_data =
        static_cast<P112_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P112_data) {
        if ((P112_data->sensor.dataAvailable()) or (P112_data->MeasurementStatus >= 1)) {
          P112_data->MeasurementStatus = P112_data->MeasurementStatus + 1;





          switch (P112_data->MeasurementStatus) {
            case 1:
              P112_data->sensor.disableBulb(AS7265x_LED_WHITE);
              P112_data->sensor.disableBulb(AS7265x_LED_IR);
              P112_data->sensor.disableBulb(AS7265x_LED_UV);

              queueEvent(event->TaskIndex, 410, PCONFIG(6) ? P112_data->sensor.getCalibratedA() : P112_data->sensor.getA());
              break;
            case 2:
              queueEvent(event->TaskIndex, 435, PCONFIG(6) ? P112_data->sensor.getCalibratedB() : P112_data->sensor.getB());
              break;
            case 3:
              queueEvent(event->TaskIndex, 460, PCONFIG(6) ? P112_data->sensor.getCalibratedC() : P112_data->sensor.getC());
              break;
            case 4:
              queueEvent(event->TaskIndex, 485, PCONFIG(6) ? P112_data->sensor.getCalibratedD() : P112_data->sensor.getD());
              break;
            case 5:
              queueEvent(event->TaskIndex, 510, PCONFIG(6) ? P112_data->sensor.getCalibratedE() : P112_data->sensor.getE());
              break;
            case 6:
              queueEvent(event->TaskIndex, 535, PCONFIG(6) ? P112_data->sensor.getCalibratedF() : P112_data->sensor.getF());
              break;
            case 7:
              queueEvent(event->TaskIndex, 560, PCONFIG(6) ? P112_data->sensor.getCalibratedG() : P112_data->sensor.getG());
              break;
            case 8:
              queueEvent(event->TaskIndex, 585, PCONFIG(6) ? P112_data->sensor.getCalibratedH() : P112_data->sensor.getH());
              break;
            case 9:
              queueEvent(event->TaskIndex, 610, PCONFIG(6) ? P112_data->sensor.getCalibratedR() : P112_data->sensor.getR());
              break;
            case 10:
              queueEvent(event->TaskIndex, 645, PCONFIG(6) ? P112_data->sensor.getCalibratedI() : P112_data->sensor.getI());
              break;
            case 11:
              queueEvent(event->TaskIndex, 680, PCONFIG(6) ? P112_data->sensor.getCalibratedS() : P112_data->sensor.getS());
              break;
            case 12:
              queueEvent(event->TaskIndex, 705, PCONFIG(6) ? P112_data->sensor.getCalibratedJ() : P112_data->sensor.getJ());
              break;
            case 13:
              queueEvent(event->TaskIndex, 730, PCONFIG(6) ? P112_data->sensor.getCalibratedT() : P112_data->sensor.getT());
              break;
            case 14:
              queueEvent(event->TaskIndex, 760, PCONFIG(6) ? P112_data->sensor.getCalibratedU() : P112_data->sensor.getU());
              break;
            case 15:
              queueEvent(event->TaskIndex, 810, PCONFIG(6) ? P112_data->sensor.getCalibratedV() : P112_data->sensor.getV());
              break;
            case 16:
              queueEvent(event->TaskIndex, 860, PCONFIG(6) ? P112_data->sensor.getCalibratedW() : P112_data->sensor.getW());
              break;
            case 17:
              queueEvent(event->TaskIndex, 900, PCONFIG(6) ? P112_data->sensor.getCalibratedK() : P112_data->sensor.getK());
              break;
            case 18:
              queueEvent(event->TaskIndex, 940, PCONFIG(6) ? P112_data->sensor.getCalibratedL() : P112_data->sensor.getL());

              P112_data->MeasurementStatus = 0;
              UserVar.setFloat(event->TaskIndex, 2, 0);

              if (PCONFIG(0))
              {
                P112_data->sensor.enableIndicator();
              }
              break;
          }
        }
      }
      break;
    }
    case PLUGIN_READ:
    {
      P112_data_struct *P112_data =
        static_cast<P112_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (P112_data->MeasurementStatus == 0) {
        if (P112_data->begin()) {
          UserVar.setFloat(event->TaskIndex, 2, 1);

          P112_data->sensor.disableIndicator();

          if (PCONFIG(5))
          {
            P112_data->sensor.enableBulb(AS7265x_LED_WHITE);
            P112_data->sensor.enableBulb(AS7265x_LED_IR);
            P112_data->sensor.enableBulb(AS7265x_LED_UV);
          }
# 410 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P112_AS7265x.ino"
          P112_data->sensor.setMeasurementMode(AS7265X_MEASUREMENT_MODE_6CHAN_ONE_SHOT);

          UserVar.setFloat(event->TaskIndex, 0, P112_data->sensor.getTemperature());
          UserVar.setFloat(event->TaskIndex, 1, P112_data->sensor.getTemperatureAverage());
        }
      }
      success = true;
      break;
    }
  }
  return success;
}

void queueEvent(taskIndex_t TaskIndex, int wavelength, float value) {
  eventQueue.add(TaskIndex, String(wavelength), toString(value, 2));
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P113_VL53L1X.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P113
# 19 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P113_VL53L1X.ino"
# include "src/PluginStructs/P113_data_struct.h"

#define PLUGIN_113 
#define PLUGIN_ID_113 113
#define PLUGIN_NAME_113 "Distance - VL53L1X (400cm)"
#define PLUGIN_VALUENAME1_113 "Distance"
#define PLUGIN_VALUENAME2_113 "Ambient"


boolean Plugin_113(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_113;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_113);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_113));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_113));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      # define P113_ACTIVE_I2C_ADDRESSES 1
      const uint8_t i2cAddressValues[] = { 0x29, 0x30 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c"), P113_ACTIVE_I2C_ADDRESSES, i2cAddressValues, PCONFIG(0));
      } else {
        success = intArrayContains(P113_ACTIVE_I2C_ADDRESSES, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *optionsMode2[] = {
          F("100ms (Normal)"),
          F("20ms (Fastest)"),
          F("33ms (Fast)"),
          F("50ms"),
          F("200ms (Accurate)"),
          F("500ms"),
        };
        const int optionValuesMode2[] = { 100, 20, 33, 50, 200, 500 };
        addFormSelector(F("Timing"), F("timing"), 6, optionsMode2, optionValuesMode2, PCONFIG(1));
      }

      {
        const __FlashStringHelper *optionsMode3[] = {
          F("Normal (~130cm)"),
          F("Long (~400cm)"),
        };
        const int optionValuesMode3[2] = { 0, 1 };
        addFormSelector(F("Range"), F("range"), 2, optionsMode3, optionValuesMode3, PCONFIG(2));
      }
      addFormCheckBox(F("Send event when value unchanged"), F("notchanged"), PCONFIG(3) == 1);
      addFormNote(F("When checked, 'Trigger delta' setting is ignored!"));

      addFormNumericBox(F("Trigger delta"), F("delta"), PCONFIG(4), 0, 100);
      addUnit(F("0-100mm"));
      addFormNote(F("Minimal change in Distance to trigger an event."));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("i2c"));
      PCONFIG(1) = getFormItemInt(F("timing"));
      PCONFIG(2) = getFormItemInt(F("range"));
      PCONFIG(3) = isFormItemChecked(F("notchanged")) ? 1 : 0;
      PCONFIG(4) = getFormItemInt(F("delta"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P113_data_struct(PCONFIG(0), PCONFIG(1), PCONFIG(2) == 1));
      P113_data_struct *P113_data = static_cast<P113_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P113_data) && P113_data->begin();
      break;
    }

    case PLUGIN_EXIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      P113_data_struct *P113_data = static_cast<P113_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P113_data) {
        uint16_t dist = P113_data->readDistance();
        uint16_t ambient = P113_data->readAmbient();
        bool triggered = (dist > UserVar[event->BaseVarIndex] + PCONFIG(4)) || (dist < UserVar[event->BaseVarIndex] - PCONFIG(4));

        if (P113_data->isReadSuccessful() && (triggered || (PCONFIG(3) == 1)) && (dist != 0xFFFF)) {
          UserVar.setFloat(event->TaskIndex, 0, dist);
          UserVar.setFloat(event->TaskIndex, 1, ambient);
          success = true;
        }
      }
      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P113_data_struct *P113_data = static_cast<P113_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P113_data) {
        if (P113_data->startRead()) {
          if (P113_data->readAvailable() && (Settings.TaskDeviceTimer[event->TaskIndex] == 0)) {

            Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 10);
          }
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P114_VEML6075.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P114
# 12 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P114_VEML6075.ino"
#define PLUGIN_114 
#define PLUGIN_ID_114 114
#define PLUGIN_NAME_114 "UV - VEML6075 UVA/UVB Sensor"
#define PLUGIN_VALUENAME1_114 "UVA"
#define PLUGIN_VALUENAME2_114 "UVB"
#define PLUGIN_VALUENAME3_114 "UVIndex"

# include "./src/PluginStructs/P114_data_struct.h"


boolean Plugin_114(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_114;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_114);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_114));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_114));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_114));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[2] = { 0x10, 0x11 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c"), 2, i2cAddressValues, PCONFIG(0));
        addFormNote(F("SDO Low=0x10, High=0x11"));
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = PCONFIG(0);
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *optionsMode2[] = {
          F("50 ms"),
          F("100 ms"),
          F("200 ms"),
          F("400 ms"),
          F("800 ms"),
        };
        const int optionValuesMode2[] = {
          P114_IT_50,
          P114_IT_100,
          P114_IT_200,
          P114_IT_400,
          P114_IT_800,
        };
        addFormSelector(F("Integration Time"), F("it"), 5, optionsMode2, optionValuesMode2, PCONFIG(1));
      }

      {
        const __FlashStringHelper *optionsMode3[2];
        optionsMode3[0] = F("Normal Dynamic");
        optionsMode3[1] = F("High Dynamic");
        int optionValuesMode3[2];
        optionValuesMode3[0] = 0;
        optionValuesMode3[1] = 1;
        addFormSelector(F("Dynamic Setting"), F("hd"), 2, optionsMode3, optionValuesMode3, PCONFIG(2));
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG(0) = getFormItemInt(F("i2c"));
      PCONFIG(1) = getFormItemInt(F("it"));
      PCONFIG(2) = getFormItemInt(F("hd"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P114_data_struct(PCONFIG(0), PCONFIG(1), PCONFIG(2) == 1));
      break;
    }

    case PLUGIN_READ:
    {
      P114_data_struct *P114_data =
        static_cast<P114_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P114_data) {
        return success;
      }

      float UVA = 0.0f;
      float UVB = 0.0f;
      float UVIndex = 0.0f;

      if (P114_data->read_sensor(UVA, UVB, UVIndex)) {
        UserVar.setFloat(event->TaskIndex, 0, UVA);
        UserVar.setFloat(event->TaskIndex, 1, UVB);
        UserVar.setFloat(event->TaskIndex, 2, UVIndex);

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log;

          if (log.reserve(130)) {
            String log = F("VEML6075: Address: 0x");
            log += String(PCONFIG(0), HEX);
            log += F(" / Integration Time: ");
            log += PCONFIG(1);
            log += F(" / Dynamic Mode: ");
            log += PCONFIG(2);
            log += F(" / divisor: ");
            log += String(1 << (PCONFIG(1) - 1));
            log += F(" / UVA: ");
            log += UserVar[event->BaseVarIndex];
            log += F(" / UVB: ");
            log += UserVar[event->BaseVarIndex + 1];
            log += F(" / UVIndex: ");
            log += UserVar[event->BaseVarIndex + 2];
            addLogMove(LOG_LEVEL_INFO, log);
          }
        }

        success = true;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P115_MAX1704x_v2.ino"
# 12 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P115_MAX1704x_v2.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P115


# include "src/PluginStructs/P115_data_struct.h"

#define PLUGIN_115 
#define PLUGIN_ID_115 115
#define PLUGIN_NAME_115 "Energy - Fuel Gauge MAX1704x"
#define PLUGIN_VALUENAME1_115 "Voltage"
#define PLUGIN_VALUENAME2_115 "SOC"
#define PLUGIN_VALUENAME3_115 "Alert"
#define PLUGIN_VALUENAME4_115 "Rate"
#define PLUGIN_xxx_DEBUG false

#define P115_I2CADDR PCONFIG(0)
#define P115_THRESHOLD PCONFIG(1)
#define P115_ALERTEVENT PCONFIG(2)
#define P115_DEVICESELECTOR PCONFIG(3)

boolean Plugin_115(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_115;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].DecimalsOnly = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_115);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_115));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_115));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_115));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_115));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x36);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x36;
      success = true;
      break;
    }
    # endif

    case PLUGIN_INIT:
    {
      const sfe_max1704x_devices_e device = static_cast<sfe_max1704x_devices_e>(P115_DEVICESELECTOR);
      const int threshold = P115_THRESHOLD;
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P115_data_struct(device, threshold));
      P115_data_struct *P115_data = static_cast<P115_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P115_data) && P115_data->begin();
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        unsigned int choice = P115_DEVICESELECTOR;
        const __FlashStringHelper *options[4] = {
          F("MAX17043"),
          F("MAX17044 (2S)"),
          F("MAX17048"),
          F("MAX17049 (2S)")
        };
        const int optionValues[4] = {
          MAX1704X_MAX17043,
          MAX1704X_MAX17044,
          MAX1704X_MAX17048,
          MAX1704X_MAX17049 };
        addFormSelector(F("Device"), F("device"), 4, options, optionValues, choice);
      }

      addFormNumericBox(F("Alert threshold"), F("threshold"), P115_THRESHOLD, 1, 32);
      addUnit('%');
      addFormCheckBox(F("Send Event on Alert"), F("alertevent"), P115_ALERTEVENT);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P115_THRESHOLD = getFormItemInt(F("threshold"));
      P115_ALERTEVENT = isFormItemChecked(F("alertevent"));
      P115_DEVICESELECTOR = getFormItemInt(F("device"));

      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      P115_data_struct *P115_data = static_cast<P115_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P115_data) && P115_data->initialized) {
        UserVar.setFloat(event->TaskIndex, 0, P115_data->voltage);
        UserVar.setFloat(event->TaskIndex, 1, P115_data->soc);
        UserVar.setFloat(event->TaskIndex, 2, P115_data->alert);
        UserVar.setFloat(event->TaskIndex, 3, P115_data->changeRate);

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          String log;
          log.reserve(64);
          log = F("MAX1704x : Voltage: ");
          log += P115_data->voltage;
          log += F(" SoC: ");
          log += P115_data->soc;
          log += F(" Alert: ");
          log += P115_data->alert;
          log += F(" Rate: ");
          log += P115_data->changeRate;
          addLogMove(LOG_LEVEL_INFO, log);
        }
        success = true;
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P115_data_struct *P115_data = static_cast<P115_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P115_data) && P115_data->initialized) {
        const String command = parseString(string, 1);

        if ((equals(command, F("max1704xclearalert"))))
        {
          P115_data->clearAlert();
          success = true;
        }
      }

      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P115_data_struct *P115_data = static_cast<P115_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P115_data) && P115_data->initialized) {
        if (P115_data->read(false)) {
          if (!P115_data->alert) {
            P115_data->alert = true;

            if (P115_ALERTEVENT) {

              if (Settings.UseRules) {
                const deviceIndex_t DeviceIndex = getDeviceIndex_from_TaskIndex(event->TaskIndex);

                if (validDeviceIndex(DeviceIndex)) {
                  String eventvalues = formatUserVarNoCheck(event, 0);
                  eventvalues += ',';
                  eventvalues += formatUserVarNoCheck(event, 1);
                  eventQueue.add(event->TaskIndex, F("AlertTriggered"), eventvalues);
                }
              }
            }
          }
        }
        success = true;
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P116_ST77xx.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P116
# 30 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P116_ST77xx.ino"
#define PLUGIN_116 
#define PLUGIN_ID_116 116
#define PLUGIN_NAME_116 "Display - ST77xx TFT"
#define PLUGIN_VALUENAME1_116 "CursorX"
#define PLUGIN_VALUENAME2_116 "CursorY"

# include "src/PluginStructs/P116_data_struct.h"

boolean Plugin_116(uint8_t function, struct EventStruct *event, String& string)
{
  bool success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_116;
      Device[deviceCount].Type = DEVICE_TYPE_SPI3;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_116);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_116));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_116));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output_optional(F("CS "));
      event->String2 = formatGpioName_output(F("DC"));
      event->String3 = formatGpioName_output_optional(F("RES "));
      break;
    }

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      const char* separator = event->String1.c_str();
      string = strformat(
        F("CS: %s%sDC: %s%s RES: %s%sBtn: %s%sBckl: : %s"),
        formatGpioLabel(PIN(0), false).c_str(),
        separator,
        formatGpioLabel(PIN(1), false).c_str(),
        separator,
        formatGpioLabel(PIN(2), false).c_str(),
        separator,
        formatGpioLabel(P116_CONFIG_BUTTON_PIN, false).c_str(),
        separator,
        formatGpioLabel(P116_CONFIG_BACKLIGHT_PIN, false).c_str());
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      # ifdef ESP32

      if (Settings.InitSPI == 2) {
        PIN(0) = P116_TFT_CS_HSPI;
      } else {
        PIN(0) = P116_TFT_CS;
      }
      # else
      PIN(0) = P116_TFT_CS;
      # endif
      PIN(1) = P116_TFT_DC;
      PIN(2) = P116_TFT_RST;
      P116_CONFIG_BUTTON_PIN = -1;
      P116_CONFIG_BACKLIGHT_PIN = P116_BACKLIGHT_PIN;
      P116_CONFIG_BACKLIGHT_PERCENT = 100;

      uint32_t lSettings = 0;


      set4BitToUL(lSettings, P116_CONFIG_FLAG_MODE, static_cast<int>(AdaGFXTextPrintMode::TruncateExceedingMessage));
      set4BitToUL(lSettings, P116_CONFIG_FLAG_FONTSCALE, 1);
      set4BitToUL(lSettings, P116_CONFIG_FLAG_CMD_TRIGGER, 1);
      P116_CONFIG_FLAGS = lSettings;

      P116_CONFIG_COLORS = ADAGFX_WHITE | (ADAGFX_BLACK << 16);

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      AdaGFXFormBacklight(F("backlight"), P116_CONFIG_BACKLIGHT_PIN,
                          F("backpercentage"), P116_CONFIG_BACKLIGHT_PERCENT);

      AdaGFXFormDisplayButton(F("button"), P116_CONFIG_BUTTON_PIN,
                              F("buttonInverse"), bitRead(P116_CONFIG_FLAGS, P116_CONFIG_FLAG_INVERT_BUTTON),
                              F("timer"), P116_CONFIG_DISPLAY_TIMEOUT);

      {
        const __FlashStringHelper *options4[] = {
          ST77xx_type_toString(ST77xx_type_e::ST7735s_128x128),
          ST77xx_type_toString(ST77xx_type_e::ST7735s_128x160),
          ST77xx_type_toString(ST77xx_type_e::ST7735s_80x160),
          ST77xx_type_toString(ST77xx_type_e::ST7735s_80x160_M5),
          ST77xx_type_toString(ST77xx_type_e::ST7789vw_240x320),
          ST77xx_type_toString(ST77xx_type_e::ST7789vw_240x240),
          ST77xx_type_toString(ST77xx_type_e::ST7789vw_240x280),
          ST77xx_type_toString(ST77xx_type_e::ST7789vw_135x240),
          ST77xx_type_toString(ST77xx_type_e::ST7796s_320x480)
        };
        const int optionValues4[] = {
          static_cast<int>(ST77xx_type_e::ST7735s_128x128),
          static_cast<int>(ST77xx_type_e::ST7735s_128x160),
          static_cast<int>(ST77xx_type_e::ST7735s_80x160),
          static_cast<int>(ST77xx_type_e::ST7735s_80x160_M5),
          static_cast<int>(ST77xx_type_e::ST7789vw_240x320),
          static_cast<int>(ST77xx_type_e::ST7789vw_240x240),
          static_cast<int>(ST77xx_type_e::ST7789vw_240x280),
          static_cast<int>(ST77xx_type_e::ST7789vw_135x240),
          static_cast<int>(ST77xx_type_e::ST7796s_320x480)
        };
        constexpr int optCount4 = sizeof(optionValues4) / sizeof(optionValues4[0]);
        addFormSelector(F("TFT display model"),
                        F("type"),
                        optCount4,
                        options4,
                        optionValues4,
                        P116_CONFIG_FLAG_GET_TYPE);
      }

      addFormSubHeader(F("Layout"));

      AdaGFXFormRotation(F("rotate"), P116_CONFIG_FLAG_GET_ROTATION);

      AdaGFXFormTextPrintMode(F("mode"), P116_CONFIG_FLAG_GET_MODE);

      AdaGFXFormFontScaling(F("fontscale"), P116_CONFIG_FLAG_GET_FONTSCALE);

      addFormCheckBox(F("Clear display on exit"), F("clearOnExit"), bitRead(P116_CONFIG_FLAGS, P116_CONFIG_FLAG_CLEAR_ON_EXIT));

      {
        const __FlashStringHelper *commandTriggers[] = {
          P116_CommandTrigger_toString(P116_CommandTrigger::tft),
          P116_CommandTrigger_toString(P116_CommandTrigger::st77xx),
          P116_CommandTrigger_toString(P116_CommandTrigger::st7735),
          P116_CommandTrigger_toString(P116_CommandTrigger::st7789),
          P116_CommandTrigger_toString(P116_CommandTrigger::st7796)
        };
        const int commandTriggerOptions[] = {
          static_cast<int>(P116_CommandTrigger::tft),
          static_cast<int>(P116_CommandTrigger::st77xx),
          static_cast<int>(P116_CommandTrigger::st7735),
          static_cast<int>(P116_CommandTrigger::st7789),
          static_cast<int>(P116_CommandTrigger::st7796)
        };
        constexpr int cmdCount = sizeof(commandTriggerOptions) / sizeof(commandTriggerOptions[0]);
        addFormSelector(F("Write Command trigger"),
                        F("commandtrigger"),
                        cmdCount,
                        commandTriggers,
                        commandTriggerOptions,
                        P116_CONFIG_FLAG_GET_CMD_TRIGGER);
        # ifndef LIMIT_BUILD_SIZE
        addFormNote(F("Select the command that is used to handle commands for this display."));
        # endif
      }


      addFormCheckBox(F("Wake display on receiving text"), F("NoDisplay"), !bitRead(P116_CONFIG_FLAGS, P116_CONFIG_FLAG_NO_WAKE));
      # ifndef LIMIT_BUILD_SIZE
      addFormNote(F("When checked, the display wakes up at receiving remote updates."));
      # endif

      AdaGFXFormTextColRowMode(F("colrow"), bitRead(P116_CONFIG_FLAGS, P116_CONFIG_FLAG_USE_COL_ROW) == 1);

      AdaGFXFormTextBackgroundFill(F("backfill"), bitRead(P116_CONFIG_FLAGS, P116_CONFIG_FLAG_BACK_FILL) == 0);

      addFormSubHeader(F("Content"));

      AdaGFXFormForeAndBackColors(F("foregroundcolor"),
                                  P116_CONFIG_GET_COLOR_FOREGROUND,
                                  F("backgroundcolor"),
                                  P116_CONFIG_GET_COLOR_BACKGROUND);
      {
        String strings[P116_Nlines];
        LoadCustomTaskSettings(event->TaskIndex, strings, P116_Nlines, 0);

        uint16_t remain = DAT_TASKS_CUSTOM_SIZE;

        for (uint8_t varNr = 0; varNr < P116_Nlines; varNr++) {
          addFormTextBox(concat(F("Line "), varNr + 1), getPluginCustomArgName(varNr), strings[varNr], P116_Nchars);
          remain -= (strings[varNr].length() + 1);
        }
        addUnit(concat(F("Remaining: "), remain));
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P116_CONFIG_BUTTON_PIN = getFormItemInt(F("button"));
      P116_CONFIG_DISPLAY_TIMEOUT = getFormItemInt(F("timer"));
      P116_CONFIG_BACKLIGHT_PIN = getFormItemInt(F("backlight"));
      P116_CONFIG_BACKLIGHT_PERCENT = getFormItemInt(F("backpercentage"));

      uint32_t lSettings = 0;
      bitWrite(lSettings, P116_CONFIG_FLAG_NO_WAKE, !isFormItemChecked(F("NoDisplay")));

      bitWrite(lSettings, P116_CONFIG_FLAG_INVERT_BUTTON, isFormItemChecked(F("buttonInverse")));
      bitWrite(lSettings, P116_CONFIG_FLAG_CLEAR_ON_EXIT, isFormItemChecked(F("clearOnExit")));
      bitWrite(lSettings, P116_CONFIG_FLAG_USE_COL_ROW, isFormItemChecked(F("colrow")));

      set4BitToUL(lSettings, P116_CONFIG_FLAG_MODE, getFormItemInt(F("mode")));
      set4BitToUL(lSettings, P116_CONFIG_FLAG_ROTATION, getFormItemInt(F("rotate")));
      set4BitToUL(lSettings, P116_CONFIG_FLAG_FONTSCALE, getFormItemInt(F("fontscale")));
      set4BitToUL(lSettings, P116_CONFIG_FLAG_TYPE, getFormItemInt(F("type")));
      set4BitToUL(lSettings, P116_CONFIG_FLAG_CMD_TRIGGER, getFormItemInt(F("commandtrigger")));

      bitWrite(lSettings, P116_CONFIG_FLAG_BACK_FILL, !isFormItemChecked(F("backfill")));
      P116_CONFIG_FLAGS = lSettings;

      String color = webArg(F("foregroundcolor"));
      uint16_t fgcolor = ADAGFX_WHITE;

      if (!color.isEmpty()) {
        fgcolor = AdaGFXparseColor(color);
      }
      color = webArg(F("backgroundcolor"));
      uint16_t bgcolor = AdaGFXparseColor(color);

      P116_CONFIG_COLORS = fgcolor | (bgcolor << 16);
      {
        String strings[P116_Nlines];

        for (uint8_t varNr = 0; varNr < P116_Nlines; varNr++) {
          strings[varNr] = webArg(getPluginCustomArgName(varNr));
        }

        const String error = SaveCustomTaskSettings(event->TaskIndex, strings, P116_Nlines, 0);

        if (!error.isEmpty()) {
          addHtmlError(error);
        }
      }

      success = true;
      break;
    }

    case PLUGIN_GET_DISPLAY_PARAMETERS:
    {
      uint16_t x, y;
      ST77xx_type_toResolution(static_cast<ST77xx_type_e>(P116_CONFIG_FLAG_GET_TYPE), x, y);

      event->Par1 = x;
      event->Par2 = y;
      event->Par3 = P116_CONFIG_FLAG_GET_ROTATION;
      event->Par4 = static_cast<int>(AdaGFXColorDepth::FullColor);

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      if (Settings.InitSPI != 0) {
        initPluginTaskData(event->TaskIndex,
                           new (std::nothrow) P116_data_struct(static_cast<ST77xx_type_e>(P116_CONFIG_FLAG_GET_TYPE),
                                                               P116_CONFIG_FLAG_GET_ROTATION,
                                                               P116_CONFIG_FLAG_GET_FONTSCALE,
                                                               static_cast<AdaGFXTextPrintMode>(P116_CONFIG_FLAG_GET_MODE),
                                                               P116_CONFIG_BACKLIGHT_PIN,
                                                               P116_CONFIG_BACKLIGHT_PERCENT,
                                                               P116_CONFIG_DISPLAY_TIMEOUT,
                                                               P116_CommandTrigger_toString(static_cast<P116_CommandTrigger>(
                                                                                              P116_CONFIG_FLAG_GET_CMD_TRIGGER)),
                                                               P116_CONFIG_GET_COLOR_FOREGROUND,
                                                               P116_CONFIG_GET_COLOR_BACKGROUND,
                                                               bitRead(P116_CONFIG_FLAGS, P116_CONFIG_FLAG_BACK_FILL) == 0));
        P116_data_struct *P116_data = static_cast<P116_data_struct *>(getPluginTaskData(event->TaskIndex));

        success = (nullptr != P116_data) && P116_data->plugin_init(event);
      } else {
        addLog(LOG_LEVEL_ERROR, F("ST77xx: SPI not enabled, init cancelled."));
      }
      break;
    }

    case PLUGIN_EXIT:
    {
      P116_data_struct *P116_data = static_cast<P116_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P116_data) {
        success = P116_data->plugin_exit(event);
      }
      break;
    }


    case PLUGIN_FIFTY_PER_SECOND:
    {
      if (P116_CONFIG_BUTTON_PIN != -1) {
        P116_data_struct *P116_data = static_cast<P116_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P116_data) {
          P116_data->registerButtonState(digitalRead(P116_CONFIG_BUTTON_PIN), bitRead(P116_CONFIG_FLAGS, P116_CONFIG_FLAG_INVERT_BUTTON));
          success = true;
        }
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P116_data_struct *P116_data = static_cast<P116_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P116_data) {
        success = P116_data->plugin_ten_per_second(event);
      }
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P116_data_struct *P116_data = static_cast<P116_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P116_data) {
        success = P116_data->plugin_once_a_second(event);
      }
      break;
    }

    case PLUGIN_READ:
    {
      P116_data_struct *P116_data = static_cast<P116_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P116_data) {
        success = P116_data->plugin_read(event);
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P116_data_struct *P116_data = static_cast<P116_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P116_data) {
        success = P116_data->plugin_write(event, string);
      }
      break;
    }

    # if ADAGFX_ENABLE_GET_CONFIG_VALUE
    case PLUGIN_GET_CONFIG_VALUE:
    {
      P116_data_struct *P116_data = static_cast<P116_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P116_data) {
        success = P116_data->plugin_get_config_value(event, string);

      }
      break;
    }
    # endif
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P117_SCD30.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P117
# 30 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P117_SCD30.ino"
#define PLUGIN_117 
#define PLUGIN_ID_117 117
#define PLUGIN_NAME_117 "Gases - CO2 SCD30"
#define PLUGIN_VALUENAME1_117 "CO2"
#define PLUGIN_VALUENAME2_117 "Humidity"
#define PLUGIN_VALUENAME3_117 "Temperature"
#define PLUGIN_VALUENAME4_117 "CO2raw"

# include "./src/PluginStructs/P117_data_struct.h"

boolean Plugin_117(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_117;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].I2CMax100kHz = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_117);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_117));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_117));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_117));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_117));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = event->Par1 == 0x61;
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x61;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      P117_MEASURE_INTERVAL = 2;
      ExtraTaskSettings.TaskDeviceValueDecimals[0] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[3] = 0;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      html_TR_TD();
      html_TD();
      addHtml(F("<span style=\"color:red\">Tools->Advanced->I2C ClockStretchLimit should be set in range 20 to 150 msec.</span>"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Altitude"), F("alt"), P117_SENSOR_ALTITUDE, 0, 2000);
      addUnit(F("0..2000 m"));

      addFormTextBox(F("Temp offset"), F("tmp"), toString(P117_TEMPERATURE_OFFSET, 2), 5);
      addUnit(F("&deg;C"));

      addFormNumericBox(F("Measurement Interval"), F("pinterval"), P117_MEASURE_INTERVAL, 2, 1800);
      addUnit(F("2..1800 sec."));

      addFormCheckBox(F("Automatic Self Calibration"), F("abc"), P117_AUTO_CALIBRATION == 1);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      uint16_t alt = getFormItemInt(F("alt"));

      if (alt > 2000) { alt = 2000; }
      P117_SENSOR_ALTITUDE = alt;
      P117_TEMPERATURE_OFFSET = getFormItemFloat(F("tmp"));
      P117_AUTO_CALIBRATION = isFormItemChecked(F("abc")) ? 1 : 0;
      uint16_t interval = getFormItemInt(F("pinterval"));

      if (interval < 2) { interval = 2; }

      if (interval > 1800) { interval = 1800; }
      P117_MEASURE_INTERVAL = interval;
      success = true;
      break;
    }
    case PLUGIN_INIT:
    {
      uint16_t interval = P117_MEASURE_INTERVAL;

      if (interval < 2) { interval = 2; }

      if (interval > 1800) { interval = 1800; }
      P117_MEASURE_INTERVAL = interval;
      initPluginTaskData(event->TaskIndex,
                         new (std::nothrow) P117_data_struct(P117_SENSOR_ALTITUDE, P117_TEMPERATURE_OFFSET, P117_AUTO_CALIBRATION == 1,
                                                             P117_MEASURE_INTERVAL));
      P117_data_struct *P117_data = static_cast<P117_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P117_data);

      break;
    }
    case PLUGIN_READ:
    {
      P117_data_struct *P117_data = static_cast<P117_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P117_data) {
        return success;
      }

      uint16_t scd30_CO2 = 0u;
      uint16_t scd30_CO2EAvg = 0u;
      float scd30_Humid = 0.0f;
      float scd30_Temp = 0.0f;

      switch (P117_data->read_sensor(&scd30_CO2, &scd30_CO2EAvg, &scd30_Temp, &scd30_Humid))
      {
        case ERROR_SCD30_NO_ERROR:
          UserVar.setFloat(event->TaskIndex, 0, scd30_CO2EAvg);
          UserVar.setFloat(event->TaskIndex, 1, scd30_Humid);
          UserVar.setFloat(event->TaskIndex, 2, scd30_Temp);
          UserVar.setFloat(event->TaskIndex, 3, scd30_CO2);

          if (scd30_CO2EAvg > 5000) {
            addLog(LOG_LEVEL_INFO, F("SCD30: Sensor saturated! > 5000 ppm"));
          }
          break;
        case ERROR_SCD30_NO_DATA:
        case ERROR_SCD30_CRC_ERROR:
        case ERROR_SCD30_CO2_ZERO:
          break;
        default:
        {
          P117_data->softReset();
          break;
        }
      }
      success = true;
      break;
    }
    case PLUGIN_WRITE:
    {
      P117_data_struct *P117_data = static_cast<P117_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P117_data) {
        return success;
      }
      String command = parseString(string, 1);
      uint16_t value = 0;
      String log;
      float temp;

      if (equals(command, F("scdgetabc"))) {
        P117_data->getCalibrationType(&value);
        log += F("ABC: ");
        log += value;
        success = true;
      } else if (equals(command, F("scdgetalt"))) {
        P117_data->getAltitudeCompensation(&value);
        log += F("Altitude: ");
        log += value;
        success = true;
      } else if (equals(command, F("scdgettmp"))) {
        P117_data->getTemperatureOffset(&temp);
        log += F("Temp offset: ");
        log += toString(temp, 2);
        success = true;
      } else if (equals(command, F("scdsetcalibration")) && (event->Par1 >= 0) && (event->Par1 <= 1)) {
        P117_data->setCalibrationMode(event->Par1 == 1);
        P117_AUTO_CALIBRATION = event->Par1;
        log += F("Calibration: ");
        log += event->Par1 == 1 ? F("auto") : F("manual");
        success = true;
      } else if (equals(command, F("scdsetfrc")) && (event->Par1 >= 400) && (event->Par1 <= 2000)) {
        int res = P117_data->setForcedRecalibrationFactor(event->Par1);
        log += F("SCD30 Forced calibration: ");
        log += event->Par1;
        log += F(", result: ");
        log += res;
        success = true;
      } else if (equals(command, F("scdgetinterval"))) {
        P117_data->getMeasurementInterval(&value);
        log += F("Interval: ");
        log += value;
        success = true;
      } else if (equals(command, F("scdsetinterval")) && (event->Par1 >= 2) && (event->Par1 <= 1800)) {
        int res = P117_data->setMeasurementInterval(event->Par1);
        P117_MEASURE_INTERVAL = event->Par1;
        log += F("SCD30 Measurement Interval: ");
        log += event->Par1;
        log += F(", result: ");
        log += res;
        success = true;
      }

      if (success) {
        SendStatus(event, log);
      } else {
        addLog(LOG_LEVEL_ERROR, F("SCD30: Unknown command."));
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P118_Itho.ino"
# 105 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P118_Itho.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P118

# include "_Plugin_Helper.h"
# include "./src/PluginStructs/P118_data_struct.h"

#define PLUGIN_118 
#define PLUGIN_ID_118 118
#define PLUGIN_NAME_118 "Communication - Itho ventilation"
#define PLUGIN_VALUENAME1_118 "State"
#define PLUGIN_VALUENAME2_118 "Timer"
#define PLUGIN_VALUENAME3_118 "LastIDindex"

boolean Plugin_118(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_118;
      Device[deviceCount].Type = DEVICE_TYPE_SPI2;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_118);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_118));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_118));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_118));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_input(F("Interrupt pin (CC1101 GDO2)"));
      event->String2 = formatGpioName_output(F("CS pin (CC1101 CSN)"));
      break;
    }

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      string = F("GDO2: ");
      string += formatGpioLabel(P118_IRQPIN, false);
      string += event->String1;
      string += F("CSN: ");
      string += formatGpioLabel(P118_CSPIN, false);
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P118_IRQPIN = -1;
      P118_CSPIN = PIN_SPI_SS;
      P118_CONFIG_LOG = 0;
      P118_CONFIG_DEVID1 = 10;
      P118_CONFIG_DEVID2 = 87;
      P118_CONFIG_DEVID3 = 81;
      P118_CONFIG_RF_LOG = 1;
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      # ifdef P118_DEBUG_LOG
      addLog(LOG_LEVEL_INFO, F("INIT PLUGIN_118"));
      # endif

      if (validGpio(P118_CSPIN) && (P118_IRQPIN != P118_CSPIN)) {
        initPluginTaskData(event->TaskIndex, new (std::nothrow) P118_data_struct(P118_CSPIN,
                                                                                 P118_IRQPIN,
                                                                                 P118_CONFIG_LOG == 1,
                                                                                 P118_CONFIG_RF_LOG == 1));
        P118_data_struct *P118_data = static_cast<P118_data_struct *>(getPluginTaskData(event->TaskIndex));

        success = (nullptr != P118_data) && P118_data->plugin_init(event);
      } else {
        addLog(LOG_LEVEL_ERROR, F("ITHO: CS pin not correctly configured, plugin can not start!"));
      }

      break;
    }

    case PLUGIN_EXIT:
    {
      # ifdef P118_DEBUG_LOG
      addLog(LOG_LEVEL_INFO, F("EXIT PLUGIN_118"));
      # endif
      P118_data_struct *P118_data = static_cast<P118_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P118_data) {
        success = P118_data->plugin_exit(event);
      }

      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P118_data_struct *P118_data = static_cast<P118_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P118_data) {
        success = P118_data->plugin_once_a_second(event);
      }

      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P118_data_struct *P118_data = static_cast<P118_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P118_data) {
        success = P118_data->plugin_fifty_per_second(event);
      }

      break;
    }


    case PLUGIN_READ: {
      P118_data_struct *P118_data = static_cast<P118_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P118_data) {
        success = P118_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_WRITE: {
      P118_data_struct *P118_data = static_cast<P118_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P118_data) {
        success = P118_data->plugin_write(event, string);
      }

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      PLUGIN_118_ExtraSettingsStruct PLUGIN_118_ExtraSettings;
      LoadCustomTaskSettings(event->TaskIndex, reinterpret_cast<uint8_t *>(&PLUGIN_118_ExtraSettings), sizeof(PLUGIN_118_ExtraSettings));
      addFormSubHeader(F("Remote RF Controls"));
      addFormTextBox(F("Unit ID remote 1"), F("pID1"), PLUGIN_118_ExtraSettings.ID1, 8);
      # if P118_FEATURE_ORCON
      addFormNote(F("For Orcon: The addres of remote 1 will be used as source/sender address"));
      # endif
      addFormTextBox(F("Unit ID remote 2"), F("pID2"), PLUGIN_118_ExtraSettings.ID2, 8);
      addFormTextBox(F("Unit ID remote 3"), F("pID3"), PLUGIN_118_ExtraSettings.ID3, 8);

      # ifndef BUILD_NO_DEBUG
      addFormCheckBox(F("Enable RF DEBUG log"), F("plog"), P118_CONFIG_LOG);

      # endif
      addFormCheckBox(F("Enable minimal RF INFO log"), F("prflog"), P118_CONFIG_RF_LOG);

      addFormNumericBox(F("Device ID byte 1"), F("pdevid1"), P118_CONFIG_DEVID1, 0, 255);
      addFormNumericBox(F("Device ID byte 2"), F("pdevid2"), P118_CONFIG_DEVID2, 0, 255);
      addFormNumericBox(F("Device ID byte 3"), F("pdevid3"), P118_CONFIG_DEVID3, 0, 255);
      addFormNote(F("Device ID of your ESP, should not be the same as your neighbours ;-). "
                    "Defaults to 10,87,81 which corresponds to the old Itho library"));
      # if P118_FEATURE_ORCON
      addFormNote(F("For Orcon: This is the destination ID a.k.a. the ID of the Ventilation unit."));

      addFormCheckBox(F("Enable Orcon support"), F("orcon"), P118_CONFIG_ORCON);
      # endif
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PLUGIN_118_ExtraSettingsStruct PLUGIN_118_ExtraSettings;
      strcpy(PLUGIN_118_ExtraSettings.ID1, web_server.arg(F("pID1")).c_str());
      strcpy(PLUGIN_118_ExtraSettings.ID2, web_server.arg(F("pID2")).c_str());
      strcpy(PLUGIN_118_ExtraSettings.ID3, web_server.arg(F("pID3")).c_str());
      SaveCustomTaskSettings(event->TaskIndex, reinterpret_cast<uint8_t *>(&PLUGIN_118_ExtraSettings), sizeof(PLUGIN_118_ExtraSettings));

      # ifndef BUILD_NO_DEBUG
      P118_CONFIG_LOG = isFormItemChecked(F("plog"));
      # endif
      P118_CONFIG_RF_LOG = isFormItemChecked(F("prflog"));

      P118_CONFIG_DEVID1 = getFormItemInt(F("pdevid1"), 10);
      P118_CONFIG_DEVID2 = getFormItemInt(F("pdevid2"), 87);
      P118_CONFIG_DEVID3 = getFormItemInt(F("pdevid3"), 81);
      # if P118_FEATURE_ORCON
      P118_CONFIG_ORCON = isFormItemChecked(F("orcon")) ? 1 : 0;
      # endif
      success = true;
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P119_ITG3205_Gyro.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P119
# 25 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P119_ITG3205_Gyro.ino"
# include "src/PluginStructs/P119_data_struct.h"

#define PLUGIN_119 
#define PLUGIN_ID_119 119
#define PLUGIN_NAME_119 "Gyro - ITG3205"
#define PLUGIN_VALUENAME1_119 "X"
#define PLUGIN_VALUENAME2_119 "Y"
#define PLUGIN_VALUENAME3_119 "Z"


#define P119_RAW_DATA PCONFIG(0)
#define P119_I2C_ADDR PCONFIG(1)
#define P119_AVERAGE_BUFFER PCONFIG(2)
#define P119_FREQUENCY PCONFIG(3)
#define P119_FREQUENCY_10 0
#define P119_FREQUENCY_50 1

boolean Plugin_119(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_119;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_119);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_119));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_119));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_119));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x68, 0x69 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, P119_I2C_ADDR);
        addFormNote(F("AD0 Low=0x68, High=0x69"));
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P119_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      P119_I2C_ADDR = 0x68;
      P119_AVERAGE_BUFFER = 10;


      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        ExtraTaskSettings.TaskDeviceValueDecimals[i] = 0;
      }

      success = true;
      break;
    }


    case PLUGIN_WEBFORM_LOAD:
    {
      addFormCheckBox(F("Read 'raw' values from Gyro"), F("rawData"), P119_RAW_DATA == 1);

      addFormNumericBox(F("Averaging buffer size"), F("average_buf"), P119_AVERAGE_BUFFER, 1, 100);
      addUnit(F("1..100"));

      const __FlashStringHelper *frequencyOptions[] = {
        F("10"),
        F("50") };
      const int frequencyValues[] = { P119_FREQUENCY_10, P119_FREQUENCY_50 };
      addFormSelector(F("Measuring frequency"), F("frequency"), 2, frequencyOptions, frequencyValues, P119_FREQUENCY);
      addUnit(F("Hz"));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P119_I2C_ADDR = getFormItemInt(F("i2c_addr"));
      P119_RAW_DATA = isFormItemChecked(F("rawData")) ? 1 : 0;
      P119_AVERAGE_BUFFER = getFormItemInt(F("average_buf"));
      P119_FREQUENCY = getFormItemInt(F("frequency"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P119_data_struct(P119_I2C_ADDR, P119_RAW_DATA, P119_AVERAGE_BUFFER));
      break;
    }

    case PLUGIN_READ:
    {
      P119_data_struct *P119_data = static_cast<P119_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P119_data) {
        success = P119_data->initialized();
      }

      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P119_data_struct *P119_data = static_cast<P119_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P119_data) {
        int X, Y, Z;

        if (P119_data->read_data(X, Y, Z)) {
          UserVar.setFloat(event->TaskIndex, 0, X);
          UserVar.setFloat(event->TaskIndex, 1, Y);
          UserVar.setFloat(event->TaskIndex, 2, Z);

          success = true;
        }
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    case PLUGIN_FIFTY_PER_SECOND:
    {
      if (((function == PLUGIN_TEN_PER_SECOND) && (P119_FREQUENCY == P119_FREQUENCY_10)) ||
          ((function == PLUGIN_FIFTY_PER_SECOND) && (P119_FREQUENCY == P119_FREQUENCY_50))) {
        P119_data_struct *P119_data = static_cast<P119_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P119_data) {
          success = P119_data->read_sensor();
        }
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P120_ADXL345_Accelerometer.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P120
# 28 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P120_ADXL345_Accelerometer.ino"
# include "src/PluginStructs/P120_data_struct.h"

#define PLUGIN_120 
#define PLUGIN_ID_120 120
#define PLUGIN_NAME_120 "Accelerometer - ADXL345 (I2C)"


boolean Plugin_120(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_120;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_120);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      P120_data_struct::plugin_get_device_value_names(event);
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P120_NR_OUTPUT_VALUES;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(P120_SENSOR_TYPE_INDEX));
      event->idx = P120_SENSOR_TYPE_INDEX;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES: {
      serialHelper_getGpioNames(event);
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x53, 0x1D };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, P120_I2C_ADDR);
        addFormNote(F("AD0 Low=0x53, High=0x1D"));
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P120_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      P120_I2C_ADDR = 0x53;
      P120_AVERAGE_BUFFER = 10;

      P120_data_struct *P120_data = new (std::nothrow) P120_data_struct(P120_AVERAGE_BUFFER);

      if (nullptr != P120_data) {
        P120_data->setI2Caddress(static_cast<uint8_t>(P120_I2C_ADDR));
        success = P120_data->plugin_set_defaults(event);
        delete P120_data;
      }


      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        ExtraTaskSettings.TaskDeviceValueDecimals[i] = 0;
      }

      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      success = P120_data_struct::plugin_webform_loadOutputSelector(event);
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      P120_data_struct *P120_data = new (std::nothrow) P120_data_struct(P120_AVERAGE_BUFFER);

      if (nullptr != P120_data) {
        P120_data->setI2Caddress(static_cast<uint8_t>(P120_I2C_ADDR));
        success = P120_data->plugin_webform_load(event);
        delete P120_data;
      }
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P120_I2C_ADDR = getFormItemInt(F("i2c_addr"));
      P120_AVERAGE_BUFFER = getFormItemInt(F("average_buf"));

      P120_data_struct *P120_data = new (std::nothrow) P120_data_struct(P120_AVERAGE_BUFFER);

      if (nullptr != P120_data) {
        P120_data->setI2Caddress(static_cast<uint8_t>(P120_I2C_ADDR));
        success = P120_data->plugin_webform_save(event);
        delete P120_data;
      }
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P120_data_struct(P120_AVERAGE_BUFFER));
      P120_data_struct *P120_data = static_cast<P120_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P120_data) {
        P120_data->setI2Caddress(static_cast<uint8_t>(P120_I2C_ADDR));
        success = true;
      }

      break;
    }

    case PLUGIN_READ:
    {
      P120_data_struct *P120_data = static_cast<P120_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P120_data) {
        success = P120_data->initialized();
      }

      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      P120_data_struct *P120_data =
        static_cast<P120_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P120_data) {
        success = P120_data->plugin_get_config_value(event, string);
      }
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P120_data_struct *P120_data = static_cast<P120_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P120_data) {
        success = P120_data->read_data(event);
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    case PLUGIN_FIFTY_PER_SECOND:
    {
      if (((function == PLUGIN_TEN_PER_SECOND) && (P120_FREQUENCY == P120_FREQUENCY_10)) ||
          ((function == PLUGIN_FIFTY_PER_SECOND) && (P120_FREQUENCY == P120_FREQUENCY_50))) {
        P120_data_struct *P120_data = static_cast<P120_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P120_data) {
          success = P120_data->read_sensor(event);
        }
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P121_HMC5883L.ino"

#include "_Plugin_Helper.h"
#ifdef USES_P121
# 24 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P121_HMC5883L.ino"
# include "src/PluginStructs/P121_data_struct.h"
# include <Adafruit_Sensor.h>
# include <Adafruit_HMC5883_U.h>
# include <math.h>

#define PLUGIN_121 
#define PLUGIN_ID_121 121
#define PLUGIN_NAME_121 "Position - HMC5883L"
#define PLUGIN_VALUENAME1_121 "x"
#define PLUGIN_VALUENAME2_121 "y"
#define PLUGIN_VALUENAME3_121 "z"
#define PLUGIN_VALUENAME4_121 "dir"

boolean Plugin_121(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_121;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_121);
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_121));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_121));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_121));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_121));
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      success = true;
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = (event->Par1 == 0x1E);
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x1E;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormFloatNumberBox(F("Declination Angle"), F("pdecl"), PCONFIG_FLOAT(0), -180.0f, 180.0f, 2, 0.01f);
      PCONFIG_FLOAT(1) = PCONFIG_FLOAT(0) * M_PI / 180.0f;
      addUnit(F("degree"));
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      PCONFIG_FLOAT(0) = getFormItemFloat(F("pdecl"));
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P121_data_struct());
      P121_data_struct *P121_data = static_cast<P121_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P121_data) && P121_data->begin(event->TaskIndex);
      break;
    }

    case PLUGIN_READ:
    {
      P121_data_struct *P121_data = static_cast<P121_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P121_data) {
        if (!P121_data->begin(event->TaskIndex)) {
          addLog(LOG_LEVEL_ERROR, F("Could not initialize HCM5883L"));
          break;
        }
        sensors_event_t s_event;
        P121_data->mag.getEvent(&s_event);

        UserVar.setFloat(event->TaskIndex, 0, s_event.magnetic.x);
        UserVar.setFloat(event->TaskIndex, 1, s_event.magnetic.y);
        UserVar.setFloat(event->TaskIndex, 2, s_event.magnetic.z);

        float heading = atan2(s_event.magnetic.y, s_event.magnetic.x);

        const float decl = PCONFIG_FLOAT(1);

        if (decl != 0) {
          heading += decl;
        }

        if (heading < 0) {
          heading += 2.0f * PI;
        }

        if (heading > 2.0f * PI) {
          heading -= 2.0f * PI;
        }

        UserVar.setFloat(event->TaskIndex, 3, heading * 180.0f / M_PI);

        success = true;
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P122_SHT2x.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P122






# include "src/PluginStructs/P122_data_struct.h"

#define PLUGIN_122 
#define PLUGIN_ID_122 122
#define PLUGIN_NAME_122 "Environment - SHT2x"
#define PLUGIN_VALUENAME1_122 "Temperature"
#define PLUGIN_VALUENAME2_122 "Humidity"
# 34 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P122_SHT2x.ino"
#define P122_I2C_ADDRESS PCONFIG(0)
#define P122_I2C_ADDRESS_LABEL PCONFIG_LABEL(0)
#define P122_RESOLUTION PCONFIG(1)
#define P122_RESOLUTION_LABEL PCONFIG_LABEL(1)



boolean Plugin_122(uint8_t function, struct EventStruct *event, String& string)
{




  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {

      Device[++deviceCount].Number = PLUGIN_ID_122;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_HUM;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].I2CNoDeviceCheck = true;


      Device[deviceCount].PluginStats = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Default;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {

      string = F(PLUGIN_NAME_122);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {



      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_122));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_122));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {

      P122_I2C_ADDRESS = P122_I2C_ADDRESS_AD0_0;
      P122_RESOLUTION = P122_RESOLUTION_14T_12RH;
      success = true;
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P122_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { P122_I2C_ADDRESS_AD0_0, P122_I2C_ADDRESS_AD0_1 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS)
      {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, P122_I2C_ADDRESS);
        addFormNote(F("ADO Low=0x40, High=0x41"));
      }
      else
      {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {




      # define P122_RESOLUTION_OPTIONS 4

      const __FlashStringHelper *options[] = {
        F("Temp 14 bits / RH 12 bits"),
        F("Temp 13 bits / RH 10 bits"),
        F("Temp 12 bits / RH  8 bits"),
        F("Temp 11 bits / RH 11 bits"),
      };
      const int optionValues[] = {
        P122_RESOLUTION_14T_12RH,
        P122_RESOLUTION_13T_10RH,
        P122_RESOLUTION_12T_08RH,
        P122_RESOLUTION_11T_11RH,
      };
      addFormSelector(F("Resolution"), P122_RESOLUTION_LABEL, P122_RESOLUTION_OPTIONS, options, optionValues, P122_RESOLUTION);

# ifndef LIMIT_BUILD_SIZE
      P122_data_struct *P122_data = static_cast<P122_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (P122_data != nullptr)
      {
        uint32_t eida;
        uint32_t eidb;
        uint8_t firmware;
        P122_data->getEID(eida, eidb, firmware);
        String txt = F("CHIP ID:");
        txt += formatToHex(eida);
        txt += ',';
        txt += formatToHex(eidb);
        txt += F(" firmware=");
        txt += String(firmware);
# ifdef PLUGIN_122_DEBUG
        txt += F(" userReg= ");
        txt += formatToHex(P122_data->getUserReg());
# endif
        addFormNote(txt);
      }
# endif
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {





      P122_I2C_ADDRESS = getFormItemInt(F("i2c_addr"));
      P122_RESOLUTION = getFormItemInt(P122_RESOLUTION_LABEL);
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {

      initPluginTaskData(event->TaskIndex, new (std::nothrow) P122_data_struct());
      P122_data_struct *P122_data = static_cast<P122_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (P122_data != nullptr)
      {
        P122_data->setupDevice(P122_I2C_ADDRESS, P122_RESOLUTION);
        P122_data->reset();
        success = true;
      }
      UserVar.setFloat(event->TaskIndex, 0, NAN);
      UserVar.setFloat(event->TaskIndex, 1, NAN);
      UserVar.setFloat(event->TaskIndex, 2, NAN);
      break;
    }

    case PLUGIN_READ:
    {


      P122_data_struct *P122_data = static_cast<P122_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P122_data)
      {
        if (P122_data->inError())
        {
          UserVar.setFloat(event->TaskIndex, 0, NAN);
          UserVar.setFloat(event->TaskIndex, 1, NAN);
          addLog(LOG_LEVEL_ERROR, F("SHT2x: in Error!"));
        }
        else if (P122_data->newValues())
        {
          UserVar.setFloat(event->TaskIndex, 0, P122_data->getTemperature());
          UserVar.setFloat(event->TaskIndex, 1, P122_data->getHumidity());
          P122_data->startMeasurements();
        }
      }

      if (loglevelActiveFor(LOG_LEVEL_INFO))
      {
        String log = F("P122: Temperature: ");
        log += UserVar[event->BaseVarIndex + 0];
        log += F(" Humidity: ");
        log += UserVar[event->BaseVarIndex + 1];
        addLog(LOG_LEVEL_INFO, log);
      }
      success = true;
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {


      P122_data_struct *P122_data = static_cast<P122_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P122_data)
      {
        P122_data->update();
      }
      success = true;
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P124_MultiRelay.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P124
# 24 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P124_MultiRelay.ino"
#define PLUGIN_124 
#define PLUGIN_ID_124 124
#define PLUGIN_NAME_124 "Output - I2C Multi Relay"
#define PLUGIN_VALUENAME1_124 "State"
#define PLUGIN_VALUENAME2_124 "Channel"
#define PLUGIN_VALUENAME3_124 "Get"

# include "./src/PluginStructs/P124_data_struct.h"

static uint32_t P124_InitializedRelays = 0u;

boolean Plugin_124(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_124;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_124);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_124));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_124));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_124));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P124_CONFIG_I2C_ADDRESS = 0x11;
      ExtraTaskSettings.TaskDeviceValueDecimals[0] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[1] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[2] = 0;
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {

      const uint8_t i2cAddressValues[] = { 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2caddress"), 8, i2cAddressValues, P124_CONFIG_I2C_ADDRESS);

        addFormCheckBox(F("Change I2C address of board"), F("change_i2c"), false);
        addFormNote(
          F("Change of address will be stored in the board and retained until changed again. See documentation for change-procedure."));
      } else {
        success = intArrayContains(8, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P124_CONFIG_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_LOAD:
    {
      const __FlashStringHelper *optionsMode2[] = {
        F("2"),
        F("4"),
        F("8") };
      const int optionValuesMode2[] { 2, 4, 8 };
      addFormSelector(F("Number of relays"), F("relays"), 3, optionsMode2, optionValuesMode2, P124_CONFIG_RELAY_COUNT, true);

      addFormSelector_YesNo(F("Initialize relays on startup"),
                            getPluginCustomArgName(P124_FLAGS_INIT_RELAYS),
                            bitRead(P124_CONFIG_FLAGS, P124_FLAGS_INIT_RELAYS) ? 1 : 0, true);
      String label;

      if (bitRead(P124_CONFIG_FLAGS, P124_FLAGS_INIT_RELAYS)) {
        addFormCheckBox(F("Apply initial state always"),
                        getPluginCustomArgName(P124_FLAGS_INIT_ALWAYS),
                        bitRead(P124_CONFIG_FLAGS, P124_FLAGS_INIT_ALWAYS));
        addFormNote(F("Disabled: Applied once per restart, Enabled: Applied on every plugin start, like on Submit of this page"));

        for (int i = 0; i < P124_CONFIG_RELAY_COUNT; i++) {
          label = F("Relay ");
          label += i + 1;
          label += F(" initial state (on/off)");
          addFormCheckBox(label, getPluginCustomArgName(i), bitRead(P124_CONFIG_FLAGS, i));
        }
      }

      addFormSelector_YesNo(F("Reset relays on exit"),
                            getPluginCustomArgName(P124_FLAGS_EXIT_RELAYS),
                            bitRead(P124_CONFIG_FLAGS, P124_FLAGS_EXIT_RELAYS) ? 1 : 0, true);

      if (bitRead(P124_CONFIG_FLAGS, P124_FLAGS_EXIT_RELAYS)) {
        for (int i = 0; i < P124_CONFIG_RELAY_COUNT; i++) {
          label = F("Relay ");
          label += i + 1;
          label += F(" exit-state (on/off)");
          addFormCheckBox(label, getPluginCustomArgName(i + P124_FLAGS_EXIT_OFFSET), bitRead(P124_CONFIG_FLAGS, i + P124_FLAGS_EXIT_OFFSET));
        }
        addFormNote(F("ATTENTION: These Relay states will be set when the task is enabled and the settings are saved!"));
      }

      addFormCheckBox(F("Loop Channel/Get on read"),
                      getPluginCustomArgName(P124_FLAGS_LOOP_GET),
                      bitRead(P124_CONFIG_FLAGS, P124_FLAGS_LOOP_GET));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P124_CONFIG_RELAY_COUNT = getFormItemInt(F("relays"));
      P124_CONFIG_I2C_ADDRESS = getFormItemInt(F("i2caddress"));
      uint32_t lSettings = 0u;
      bitWrite(lSettings, P124_FLAGS_INIT_RELAYS, getFormItemIntCustomArgName(P124_FLAGS_INIT_RELAYS) == 1);
      bitWrite(lSettings, P124_FLAGS_INIT_ALWAYS, isFormItemChecked(getPluginCustomArgName(P124_FLAGS_INIT_ALWAYS)));
      bitWrite(lSettings, P124_FLAGS_EXIT_RELAYS, getFormItemIntCustomArgName(P124_FLAGS_EXIT_RELAYS) == 1);
      bitWrite(lSettings, P124_FLAGS_LOOP_GET, isFormItemChecked(getPluginCustomArgName(P124_FLAGS_LOOP_GET)));

      if (lSettings != 0) {
        for (int i = 0; i < P124_CONFIG_RELAY_COUNT; i++) {
          bitWrite(lSettings, i, isFormItemChecked(getPluginCustomArgName(i)));
          bitWrite(lSettings, i + P124_FLAGS_EXIT_OFFSET, isFormItemChecked(getPluginCustomArgName(i + P124_FLAGS_EXIT_OFFSET)));
        }
      }
      P124_CONFIG_FLAGS = lSettings;

      if (isFormItemChecked(F("change_i2c"))) {
        P124_data_struct *P124_data = new (std::nothrow) P124_data_struct(P124_CONFIG_I2C_ADDRESS, P124_CONFIG_RELAY_COUNT, true);

        if (nullptr != P124_data) {
          P124_data->init();
          P124_CONFIG_I2C_ADDRESS++;

          if (P124_CONFIG_I2C_ADDRESS > 0x18) { P124_CONFIG_I2C_ADDRESS = 0x11; }

          delete P124_data;
          P124_data = nullptr;
        }
      }

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P124_data_struct(P124_CONFIG_I2C_ADDRESS, P124_CONFIG_RELAY_COUNT));
      P124_data_struct *P124_data = static_cast<P124_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P124_data) && P124_data->init()) {
        if (loglevelActiveFor(LOG_LEVEL_INFO)) {
          addLogMove(LOG_LEVEL_INFO,
                     concat(F("MultiRelay: Initialized, firmware version: "), static_cast<int>(P124_data->getFirmwareVersion())));
        }

        if (bitRead(P124_CONFIG_FLAGS, P124_FLAGS_INIT_RELAYS) &&
            (!bitRead(P124_InitializedRelays, event->TaskIndex) ||
             bitRead(P124_CONFIG_FLAGS, P124_FLAGS_INIT_ALWAYS))) {
          P124_data->channelCtrl(get8BitFromUL(P124_CONFIG_FLAGS, P124_FLAGS_INIT_OFFSET));
          UserVar.setFloat(event->TaskIndex, 0, P124_data->getChannelState());
          bitSet(P124_InitializedRelays, event->TaskIndex);
        }
        P124_data->setLoopState(bitRead(P124_CONFIG_FLAGS, P124_FLAGS_LOOP_GET));
        success = true;
      } else {
        addLog(LOG_LEVEL_ERROR, F("MultiRelay: Initialization error!"));
      }

      break;
    }

    case PLUGIN_EXIT:
    {
      P124_data_struct *P124_data = static_cast<P124_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P124_data) {
        if (P124_data->isInitialized()) {
          P124_data->channelCtrl(get8BitFromUL(P124_CONFIG_FLAGS, P124_FLAGS_EXIT_OFFSET));
          UserVar.setFloat(event->TaskIndex, 0, P124_data->getChannelState());
        }
        addLog(LOG_LEVEL_INFO, F("MultiRelay: Object still alive."));
      }
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      P124_data_struct *P124_data = static_cast<P124_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P124_data) && P124_data->isInitialized()) {
        UserVar.setFloat(event->TaskIndex, 0, P124_data->getChannelState());

        if (P124_data->isLoopEnabled()) {
          uint8_t chan = P124_data->getNextLoop();
          uint8_t data = P124_data->getChannelState() & (1 << (chan - 1));
          UserVar.setFloat(event->TaskIndex, 1, chan);
          UserVar.setFloat(event->TaskIndex, 2, data ? 1 : 0);
        }
        success = true;
      }
      break;
    }

    case PLUGIN_WEBFORM_SHOW_VALUES:
    {
      P124_data_struct *P124_data = static_cast<P124_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P124_data) && P124_data->isInitialized()) {
        uint8_t varNr = 3;
        String label = F("Relay state ");
        label += P124_CONFIG_RELAY_COUNT;
        label += F("..");
        label += 1;
        String state = F("0b ");
        uint32_t val = UserVar[event->BaseVarIndex];
        val &= 0xff;
        val |= (0x1 << P124_CONFIG_RELAY_COUNT);
        state += ull2String(val, 2);
        state.remove(3, 1);
        pluginWebformShowValue(event->TaskIndex, varNr++, label, state, true);


      }
      break;
    }

    case PLUGIN_WRITE:
    {
      # if FEATURE_I2C_DEVICE_CHECK

      if (!I2C_deviceCheck(P124_CONFIG_I2C_ADDRESS, event->TaskIndex, 10, PLUGIN_I2C_GET_ADDRESS)) {
        break;
      }
      # endif
      P124_data_struct *P124_data = static_cast<P124_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P124_data) {
        return success;
      }

      # ifdef P124_DEBUG_LOG
      addLog(LOG_LEVEL_INFO, string);

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log = F("Par1..3:");
        log += event->Par1;
        log += ',';
        log += event->Par2;
        log += ',';
        log += event->Par3;
        addLogMove(LOG_LEVEL_INFO, log);
      }
      # endif

      const String command = parseString(string, 1);

      if (P124_data->isInitialized() &&
          equals(command, F("multirelay"))) {
        const String subcommand = parseString(string, 2);

        if (equals(subcommand, F("on"))) {
          success = P124_data->turn_on_channel(event->Par2);
        } else if (equals(subcommand, F("off"))) {
          success = P124_data->turn_off_channel(event->Par2);
        } else if (equals(subcommand, F("set"))) {
          success = P124_data->channelCtrl(event->Par2);
        } else if (equals(subcommand, F("get")) && (event->Par2 > 0) && (event->Par2 <= P124_CONFIG_RELAY_COUNT)) {
          uint8_t data = P124_data->getChannelState() & (1 << (event->Par2 - 1));
          UserVar.setFloat(event->TaskIndex, 1, event->Par2);
          UserVar.setFloat(event->TaskIndex, 2, (data ? 1 : 0));

          success = true;
        } else if (equals(subcommand, F("loop")) && (event->Par2 >= 0) && (event->Par2 <= 1)) {
          P124_data->setLoopState(event->Par2 == 1);

          success = true;
        }

        if (success) {
          UserVar.setFloat(event->TaskIndex, 0, P124_data->getChannelState());
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P125_ADXL345_SPI.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P125
# 27 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P125_ADXL345_SPI.ino"
# include "src/PluginStructs/P120_data_struct.h"

#define PLUGIN_125 
#define PLUGIN_ID_125 125
#define PLUGIN_NAME_125 "Accelerometer - ADXL345 (SPI)"

boolean Plugin_125(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_125;
      Device[deviceCount].Type = DEVICE_TYPE_SPI;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_125);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES: {
      P120_data_struct::plugin_get_device_value_names(event);
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P120_NR_OUTPUT_VALUES;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(P120_SENSOR_TYPE_INDEX));
      event->idx = P120_SENSOR_TYPE_INDEX;
      success = true;
      break;
    }


    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("CS"));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P120_CS_PIN = -1;
      P120_AVERAGE_BUFFER = 10;

      P120_data_struct *P120_data = new (std::nothrow) P120_data_struct(P120_AVERAGE_BUFFER);

      if (nullptr != P120_data) {
        P120_data->setSPI_CSpin(static_cast<int>(P120_CS_PIN));
        success = P120_data->plugin_set_defaults(event);
        delete P120_data;
      }


      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        ExtraTaskSettings.TaskDeviceValueDecimals[i] = 0;
      }

      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      success = P120_data_struct::plugin_webform_loadOutputSelector(event);
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      P120_data_struct *P120_data = new (std::nothrow) P120_data_struct(P120_AVERAGE_BUFFER);

      if (nullptr != P120_data) {
        P120_data->setSPI_CSpin(static_cast<int>(P120_CS_PIN));
        success = P120_data->plugin_webform_load(event);
        delete P120_data;
      }
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P120_AVERAGE_BUFFER = getFormItemInt(F("average_buf"));

      P120_data_struct *P120_data = new (std::nothrow) P120_data_struct(P120_AVERAGE_BUFFER);

      if (nullptr != P120_data) {
        P120_data->setSPI_CSpin(static_cast<int>(P120_CS_PIN));
        success = P120_data->plugin_webform_save(event);
        delete P120_data;
      }
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P120_data_struct(P120_AVERAGE_BUFFER));
      P120_data_struct *P120_data = static_cast<P120_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P120_data) {
        P120_data->setSPI_CSpin(static_cast<int>(P120_CS_PIN));
        success = true;
      }

      break;
    }

    case PLUGIN_READ:
    {
      P120_data_struct *P120_data = static_cast<P120_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P120_data) {
        success = P120_data->initialized();
      }

      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      P120_data_struct *P120_data =
        static_cast<P120_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P120_data) {
        success = P120_data->plugin_get_config_value(event, string);
      }
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P120_data_struct *P120_data = static_cast<P120_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P120_data) {
        success = P120_data->read_data(event);
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    case PLUGIN_FIFTY_PER_SECOND:
    {
      if (((function == PLUGIN_TEN_PER_SECOND) && (P120_FREQUENCY == P120_FREQUENCY_10)) ||
          ((function == PLUGIN_FIFTY_PER_SECOND) && (P120_FREQUENCY == P120_FREQUENCY_50))) {
        P120_data_struct *P120_data = static_cast<P120_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P120_data) {
          success = P120_data->read_sensor(event);
        }
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P126_74HC595.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P126
# 51 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P126_74HC595.ino"
#define PLUGIN_126 
#define PLUGIN_ID_126 126
#define PLUGIN_NAME_126 "Output - Shift registers (74HC595)"
#define PLUGIN_VALUENAME1_126 "State_A"
#define PLUGIN_VALUENAME2_126 "State_B"
#define PLUGIN_VALUENAME3_126 "State_C"
#define PLUGIN_VALUENAME4_126 "State_D"

# include "./src/PluginStructs/P126_data_struct.h"


String P126_ul2stringFixed(uint32_t value, uint8_t base) {
  uint64_t val = static_cast<uint64_t>(value);

  val &= 0x0ffffffff;
  val |= 0x100000000;
  String valStr = ull2String(val, base);

  valStr.remove(0, 1);
  valStr.toUpperCase();
  return valStr;
}

boolean Plugin_126(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_126;
      Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].DecimalsOnly = false;
      Device[deviceCount].ValueCount =
      # if P126_MAX_CHIP_COUNT <= 4
        1
      # elif P126_MAX_CHIP_COUNT <= 8
        2
      # elif P126_MAX_CHIP_COUNT <= 12
        3
      # else
        4
      # endif
      ;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_126);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_126));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_126));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_126));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_126));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P126_CONFIG_DATA_PIN = -1;
      P126_CONFIG_CLOCK_PIN = -1;
      P126_CONFIG_LATCH_PIN = -1;
      ExtraTaskSettings.TaskDeviceValueDecimals[0] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[1] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[2] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[3] = 0;
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("Data pin (DS)"));
      event->String2 = formatGpioName_output(F("Clock pin (SH_CP)"));
      event->String3 = formatGpioName_output(F("Latch pin (ST_CP)"));
      break;
    }
    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Device configuration"));

      addFormNumericBox(F("Number of chips (Q7' &rarr; DS)"),
                        F("chips"),
                        P126_CONFIG_CHIP_COUNT,
                        1,
                        P126_MAX_CHIP_COUNT);
      String unit = F("Daisychained 1..");
      unit += P126_MAX_CHIP_COUNT;
      addUnit(unit);

      addFormNumericBox(F("Offset for display"),
                        F("offset"),
                        P126_CONFIG_SHOW_OFFSET,
                        0,
                        P126_MAX_SHOW_OFFSET);
      addUnit(F("Multiple of 4"));

      # ifdef P126_SHOW_VALUES
      addFormCheckBox(F("Values display (Off=Hex/On=Bin)"), F("valdisplay"), P126_CONFIG_FLAGS_GET_VALUES_DISPLAY == 1);
      # endif

      const __FlashStringHelper *outputOptions[] = {
        F("Decimal &amp; hex/bin"),
        F("Decimal only"),
        F("Hex/bin only") };
      const int outputValues[] = { P126_OUTPUT_BOTH, P126_OUTPUT_DEC_ONLY, P126_OUTPUT_HEXBIN };
      addFormSelector(F("Output selection"), F("output"), 3, outputOptions, outputValues, P126_CONFIG_FLAGS_GET_OUTPUT_SELECTION);

      addFormCheckBox(F("Restore Values on warm boot"), F("valrestore"), P126_CONFIG_FLAGS_GET_VALUES_RESTORE);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      uint8_t previousOffset = P126_CONFIG_SHOW_OFFSET;
      P126_CONFIG_CHIP_COUNT = getFormItemInt(F("chips"));
      P126_CONFIG_SHOW_OFFSET = getFormItemInt(F("offset"));

      if (P126_CONFIG_SHOW_OFFSET >= P126_CONFIG_CHIP_COUNT) {
        P126_CONFIG_SHOW_OFFSET = 0;
      }
      P126_CONFIG_SHOW_OFFSET -= (P126_CONFIG_SHOW_OFFSET % 4);

      if ((P126_CONFIG_CHIP_COUNT > 4) &&
          (P126_CONFIG_SHOW_OFFSET > P126_CONFIG_CHIP_COUNT - 4) &&
          (P126_CONFIG_CHIP_COUNT < P126_MAX_SHOW_OFFSET)) {
        P126_CONFIG_SHOW_OFFSET -= 4;
      }

      uint32_t lSettings = 0u;

      # ifdef P126_SHOW_VALUES

      if (isFormItemChecked(F("valdisplay"))) { bitSet(lSettings, P126_FLAGS_VALUES_DISPLAY); }
      # endif

      if (!isFormItemChecked(F("valrestore"))) { bitSet(lSettings, P126_FLAGS_VALUES_RESTORE); }
      set4BitToUL(lSettings, P126_FLAGS_OUTPUT_SELECTION, getFormItemInt(F("output")));

      P126_CONFIG_FLAGS = lSettings;


      if ((previousOffset != P126_CONFIG_SHOW_OFFSET) && P126_CONFIG_FLAGS_GET_VALUES_RESTORE) {
        for (uint8_t varNr = 0; varNr < VARS_PER_TASK; varNr++) {
          UserVar.setUint32(event->TaskIndex, varNr, 0u);
        }
        # ifdef P126_DEBUG_LOG
        addLog(LOG_LEVEL_INFO, F("74HC595: 'Offset for display' changed: state values reset."));
        # endif
      }

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P126_data_struct(P126_CONFIG_DATA_PIN,
                                                                               P126_CONFIG_CLOCK_PIN,
                                                                               P126_CONFIG_LATCH_PIN,
                                                                               P126_CONFIG_CHIP_COUNT));
      P126_data_struct *P126_data = static_cast<P126_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P126_data) && P126_data->isInitialized()) {
        success = P126_data->plugin_init(event);
      }

      if (!success) {
        addLog(LOG_LEVEL_ERROR, F("74HC595: Initialization error!"));
      # ifdef P126_DEBUG_LOG
      } else {
        addLog(LOG_LEVEL_INFO, F("74HC595: Initialized."));
      # endif
      }

      break;
    }

    case PLUGIN_EXIT:
    {
      success = true;
      break;
    }

    case PLUGIN_READ:
    {
      P126_data_struct *P126_data = static_cast<P126_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P126_data) {
        success = P126_data->plugin_read(event);
      }


      break;
    }

    case PLUGIN_FORMAT_USERVAR:
    {
      string.clear();

      if ((P126_CONFIG_FLAGS_GET_OUTPUT_SELECTION == P126_OUTPUT_BOTH) ||
          (P126_CONFIG_FLAGS_GET_OUTPUT_SELECTION == P126_OUTPUT_DEC_ONLY)) {
        string += ull2String(UserVar.getUint32(event->TaskIndex, event->idx));
      }

      if (P126_CONFIG_FLAGS_GET_OUTPUT_SELECTION == P126_OUTPUT_BOTH) {
        string += ',';
      }

      if ((P126_CONFIG_FLAGS_GET_OUTPUT_SELECTION == P126_OUTPUT_BOTH) ||
          (P126_CONFIG_FLAGS_GET_OUTPUT_SELECTION == P126_OUTPUT_HEXBIN)) {
        string += '0';
        string += (P126_CONFIG_FLAGS_GET_VALUES_DISPLAY ? 'b' : 'x');
        string += P126_ul2stringFixed(UserVar.getUint32(event->TaskIndex, event->idx),
                                      # ifdef P126_SHOW_VALUES
                                      (P126_CONFIG_FLAGS_GET_VALUES_DISPLAY ? BIN :
                                      # endif
                                      HEX
                                      # ifdef P126_SHOW_VALUES
                                      )
                                      # endif
                                      );
      }
      success = true;
      break;
    }

    # ifdef P126_SHOW_VALUES
    case PLUGIN_WEBFORM_SHOW_VALUES:
      {
        String state, label;
        state.reserve(40);
        String abcd = F("ABCDEFGH");

        const uint16_t endCheck = P126_CONFIG_CHIP_COUNT + (P126_CONFIG_CHIP_COUNT == 255 ? 3 : 4);
        const uint16_t maxVar = min(static_cast<uint8_t>(VARS_PER_TASK), static_cast<uint8_t>(ceil(P126_CONFIG_CHIP_COUNT / 4.0)));
        uint8_t dotInsert;
        uint8_t dotOffset;

        for (uint16_t varNr = 0; varNr < maxVar; varNr++) {
          if (P126_CONFIG_FLAGS_GET_VALUES_DISPLAY) {
            label = F("Bin");
            state = F("0b");
            dotInsert = 10;
            dotOffset = 9;
          } else {
            label = F("Hex");
            state = F("0x");
            dotInsert = 4;
            dotOffset = 3;
          }
          label += F(" State_");
          label += abcd.substring(varNr, varNr + 1);
          label += ' ';

          label += min(255, P126_CONFIG_SHOW_OFFSET + (4 * varNr) + 4);
          label += '_';
          label += (P126_CONFIG_SHOW_OFFSET + (4 * varNr) + 1);

          if ((P126_CONFIG_SHOW_OFFSET + (4 * varNr) + 4) <= endCheck) {
            state += P126_ul2stringFixed(UserVar.getUint32(event->TaskIndex, varNr), P126_CONFIG_FLAGS_GET_VALUES_DISPLAY ? BIN : HEX);

            for (uint8_t i = 0; i < 3; i++, dotInsert += dotOffset) {
              state = state.substring(0, dotInsert) + '.' + state.substring(dotInsert);
            }
            pluginWebformShowValue(event->TaskIndex, VARS_PER_TASK + varNr, label, state, true);
          }
        }
        success = true;
        break;
      }
    # endif
    case PLUGIN_WRITE:
      {
        P126_data_struct *P126_data = static_cast<P126_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P126_data) {
          success = P126_data->plugin_write(event, string);
        }

        break;
      }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P127_CDM7160.ino"
# 17 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P127_CDM7160.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P127

# include "src/PluginStructs/P127_data_struct.h"

#define PLUGIN_127 
#define PLUGIN_ID_127 127
#define PLUGIN_NAME_127 "Gases - CO2 CDM7160"
#define PLUGIN_VALUENAME1_127 "CO2"


boolean Plugin_127_init = false;


boolean Plugin_127(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function) {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_127;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_127);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_127));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { CDM7160_ADDR, CDM7160_ADDR_0 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 2, i2cAddressValues, P127_CONFIG_I2C_ADDRESS);
        # ifndef LIMIT_BUILD_SIZE
        addFormNote(F("CAD0 High/open=0x69, Low=0x68"));
        # endif
      } else {
        success = intArrayContains(2, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P127_CONFIG_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      ExtraTaskSettings.TaskDeviceValueDecimals[0] = 0;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Altitude"), F("altitude"), P127_CONFIG_ALTITUDE, 0, 2550);
      addUnit('m');

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P127_CONFIG_I2C_ADDRESS = getFormItemInt(F("i2c_addr"));
      P127_CONFIG_ALTITUDE = getFormItemInt(F("altitude"));

      success = true;
      break;
    }
    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P127_data_struct(P127_CONFIG_I2C_ADDRESS, P127_CONFIG_ALTITUDE));
      P127_data_struct *P127_data = static_cast<P127_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P127_data) && P127_data->init();

      break;
    }
    case PLUGIN_ONCE_A_SECOND:
    {
      P127_data_struct *P127_data = static_cast<P127_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P127_data) {
        success = P127_data->checkData();
      }

      break;
    }
    case PLUGIN_READ:
    {
      P127_data_struct *P127_data = static_cast<P127_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P127_data) {
        return success;
      }

      UserVar.setFloat(event->TaskIndex, 0, P127_data->readData());

      success = true;

      if (UserVar[event->BaseVarIndex] > 15000) {
        addLog(LOG_LEVEL_ERROR, F("CDM7160: Sensor still initializing, data ignored"));
        success = false;
      } else if (UserVar[event->BaseVarIndex] > 10000) {
        addLog(LOG_LEVEL_ERROR, F("CDM7160: Sensor saturated! > 10000 ppm"));
      }

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log = F("CDM7160: Address: 0x");
        log += String(P127_CONFIG_I2C_ADDRESS, HEX);
        log += F(": CO2 ppm: ");
        log += UserVar[event->BaseVarIndex];
        log += F(", alt: ");
        log += P127_data->getAltitude();
        log += F(", comp: ");
        log += P127_data->getCompensation();
        addLogMove(LOG_LEVEL_INFO, log);
      }
      break;
    }
    case PLUGIN_WRITE:
    {
      P127_data_struct *P127_data = static_cast<P127_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P127_data) {
        String command = parseString(string, 1);

        if (equals(command, F("cdmrst"))) {
          addLog(LOG_LEVEL_INFO, F("CDM7160: reset"));
          P127_data->setReset();
          success = true;
        }
      }

      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P127_data_struct *P127_data = static_cast<P127_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P127_data) {
        success = P127_data->plugin_fifty_per_second();
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P128_NeoPixelBusFX.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P128
# 132 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P128_NeoPixelBusFX.ino"
# include "src/PluginStructs/P128_data_struct.h"

#define PLUGIN_128 
#define PLUGIN_ID_128 128
#define PLUGIN_NAME_128 "Output - NeoPixel (BusFX)"
#define PLUGIN_VALUENAME1_128 "Mode"
#define PLUGIN_VALUENAME2_128 "Lastmode"
#define PLUGIN_VALUENAME3_128 "Fadetime"
#define PLUGIN_VALUENAME4_128 "Fadedelay"

boolean Plugin_128(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_128;
      # if defined(ESP32)
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      # endif
      # if defined(ESP8266)
      Device[deviceCount].Type = DEVICE_TYPE_DUMMY;
      # endif
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Custom = true;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].DecimalsOnly = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_128);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_128));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_128));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_128));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_128));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      # ifdef ESP32
      PIN(0) = -1;
      # endif
      P128_CONFIG_MAX_BRIGHT = 255;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSubHeader(F("Actuator"));

      addRowLabel(formatGpioName_output(F("Stripe data")));
      # ifdef ESP8266
      addHtml(F("<span style=\"color:red\">Please connect stripe to GPIO2!</span>"));
      # endif
      # ifdef ESP32
      addPinSelect(PinSelectPurpose::Generic_output, F("taskdevicepin1"), PIN(0));
      # endif

      addFormNumericBox(F("Led Count"), F("ledcnt"), P128_CONFIG_LED_COUNT, 1, 999);

      if (P128_CONFIG_MAX_BRIGHT == 0) { P128_CONFIG_MAX_BRIGHT = 255; }
      addFormNumericBox(F("Max brightness"), F("maxbright"), P128_CONFIG_MAX_BRIGHT, 1, 255);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P128_CONFIG_LED_COUNT = getFormItemInt(F("ledcnt"));
      P128_CONFIG_MAX_BRIGHT = getFormItemInt(F("maxbright"));

      # ifdef ESP32
      PIN(0) = getFormItemInt(F("taskdevicepin1"));
      # endif

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {

      P128_data_struct *P128_clear = static_cast<P128_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P128_clear) {
        clearPluginTaskData(event->TaskIndex);
      }

      if (P128_CONFIG_MAX_BRIGHT == 0) { P128_CONFIG_MAX_BRIGHT = 255; }
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P128_data_struct(PIN(0), P128_CONFIG_LED_COUNT, P128_CONFIG_MAX_BRIGHT));
      break;
    }

    case PLUGIN_READ:
    {
      P128_data_struct *P128_data = static_cast<P128_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P128_data) {
        success = P128_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_WRITE:
    {
      P128_data_struct *P128_data = static_cast<P128_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P128_data) {
        success = P128_data->plugin_write(event, string);
      }

      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P128_data_struct *P128_data = static_cast<P128_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P128_data) {
        success = P128_data->plugin_fifty_per_second(event);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P129_74HC165.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P129
# 34 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P129_74HC165.ino"
#define PLUGIN_129 
#define PLUGIN_ID_129 129
#define PLUGIN_NAME_129 "Input - Shift registers (74HC165)"
#define PLUGIN_VALUENAME1_129 "State_A"
#define PLUGIN_VALUENAME2_129 "State_B"
#define PLUGIN_VALUENAME3_129 "State_C"
#define PLUGIN_VALUENAME4_129 "State_D"

# include "./src/PluginStructs/P129_data_struct.h"


String P129_ul2stringFixed(uint32_t value, uint8_t base) {

  const uint64_t val = static_cast<uint64_t>(value) | 0x100000000ull;

  String valStr = ull2String(val, base).substring(1);
  if (base == HEX) {
    valStr.toUpperCase();
  }
  return valStr;
}

boolean Plugin_129(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_129;
      Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].DecimalsOnly = false;
      Device[deviceCount].ValueCount =
      # if P129_MAX_CHIP_COUNT <= 4
        1
      # elif P129_MAX_CHIP_COUNT <= 8
        2
      # elif P129_MAX_CHIP_COUNT <= 12
        3
      # else
        4
      # endif
      ;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_129);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_129));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_129));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_129));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_129));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P129_CONFIG_CHIP_COUNT = 1;
      P129_CONFIG_DATA_PIN = -1;
      P129_CONFIG_CLOCK_PIN = -1;
      P129_CONFIG_ENABLE_PIN = -1;
      P129_CONFIG_LOAD_PIN = -1;
      ExtraTaskSettings.TaskDeviceValueDecimals[0] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[1] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[2] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[3] = 0;
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_input(F("Data (Q7)"));
      event->String2 = formatGpioName_output(F("Clock (CP)"));
      event->String3 = formatGpioName_output(F("Enable (<SPAN STYLE=\"text-decoration:overline\">EN</SPAN>) (opt.)"));
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = min(static_cast<uint8_t>(VARS_PER_TASK),
                        static_cast<uint8_t>(ceil(P129_CONFIG_CHIP_COUNT / 4.0f)));
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(
        min(static_cast<uint8_t>(VARS_PER_TASK),
            static_cast<uint8_t>(ceil(P129_CONFIG_CHIP_COUNT / 4.0f))));
      event->idx = 0;
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormPinSelect(PinSelectPurpose::Generic_output,
                       formatGpioName_output(F("Load (<SPAN STYLE=\"text-decoration:overline\">PL</SPAN>)")),
                       F("load_pin"),
                       P129_CONFIG_LOAD_PIN);
      # ifndef LIMIT_BUILD_SIZE
      addFormNote(F("GPIO pins for Data, Clock and Load <B>must</B> be configured to correctly initialize the plugin."));
      # endif

      addFormSubHeader(F("Device configuration"));

      {
        String chipCount[P129_MAX_CHIP_COUNT];
        int chipOption[P129_MAX_CHIP_COUNT];

        for (uint8_t i = 0; i < P129_MAX_CHIP_COUNT; i++) {
          chipCount[i] = String(i + 1);
          chipOption[i] = i + 1;
        }
        addFormSelector(F("Number of chips (Q7 &rarr; DS)"),
                        F("chipcnt"),
                        P129_MAX_CHIP_COUNT,
                        chipCount,
                        chipOption,
                        P129_CONFIG_CHIP_COUNT,
                        true);
        addUnit(concat(F("Daisychained 1.."), P129_MAX_CHIP_COUNT));
        # ifndef LIMIT_BUILD_SIZE
        addFormNote(F("Changing the number of chips will reload the page and update the Event configuration."));
        # endif
      }

      const __FlashStringHelper *frequencyOptions[] = {
        F("10/sec (100 msec)"),
        F("50/sec (20 msec)") };
      const int frequencyValues[] = { P129_FREQUENCY_10, P129_FREQUENCY_50 };
      addFormSelector(F("Sample frequency"), F("frequency"), 2, frequencyOptions, frequencyValues, P129_CONFIG_FLAGS_GET_READ_FREQUENCY);

      addFormSubHeader(F("Display and output"));

      # ifdef P129_SHOW_VALUES
      addFormCheckBox(F("Values display (Off=Hex/On=Bin)"), F("valuesdisplay"), P129_CONFIG_FLAGS_GET_VALUES_DISPLAY == 1);
      # endif

      const __FlashStringHelper *outputOptions[] = {
        F("Decimal &amp; hex/bin"),
        F("Decimal only"),
        F("Hex/bin only") };
      const int outputValues[] = { P129_OUTPUT_BOTH, P129_OUTPUT_DEC_ONLY, P129_OUTPUT_HEXBIN };
      addFormSelector(F("Output selection"), F("outputsel"), 3, outputOptions, outputValues, P129_CONFIG_FLAGS_GET_OUTPUT_SELECTION);

      addFormCheckBox(F("Separate events per pin"), F("separate_events"), P129_CONFIG_FLAGS_GET_SEPARATE_EVENTS == 1);

      addFormSubHeader(F("Event configuration"));

      {
        addRowLabel(F("Enable change-event for"));
        html_table(EMPTY_STRING);
        html_table_header(F("Chip #&nbsp;"), 70);
        html_table_header(F("Port:"), 70);
        html_table_header(F("D7"), 30);
        html_table_header(F("D6"), 30);
        html_table_header(F("D5"), 30);
        html_table_header(F("D4"), 30);
        html_table_header(F("D3"), 30);
        html_table_header(F("D2"), 30);
        html_table_header(F("D1"), 30);
        html_table_header(F("D0"), 30);

        uint64_t bits = 0;
        uint8_t off = 0;

        for (uint8_t i = 0; i < P129_CONFIG_CHIP_COUNT; i++) {
          if (i % 4 == 0) {
            bits = PCONFIG_ULONG(i / 4) & 0x0ffffffff;
            off = 0;
            # ifndef P129_DEBUG_LOG

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {
              String log = F("74HC165 Reading from: ");
              log += (i / 4);
              log += F(", bits: ");
              log += P129_ul2stringFixed(bits, BIN);
              addLog(LOG_LEVEL_INFO, log);
            }
            # endif
          }
          html_TR();
          addHtml(F("<td align =\"center\">"));
          addHtmlInt(i + 1);
          html_TD();

          for (uint8_t j = 0; j < 8; j++) {
            html_TD();
            # if FEATURE_TOOLTIPS
            const String toolTip = strformat(
              F("Chip %d port D %d, pin %d"),
              (i + 1),
              (7 - j),
              i * 8 + (8 - j));
            # endif
            addCheckBox(getPluginCustomArgName((i * 8 + (7 - j)) + 1), bitRead(bits, off * 8 + (7 - j)) == 1
                        # if FEATURE_TOOLTIPS
                        , false
                        , toolTip
                        # endif
                        );
          }
          off++;
        }
        html_end_table();
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P129_CONFIG_LOAD_PIN = getFormItemInt(F("load_pin"));
      P129_CONFIG_CHIP_COUNT = getFormItemInt(F("chipcnt"));

      uint32_t lSettings = 0u;

      # ifdef P129_SHOW_VALUES

      if (isFormItemChecked(F("valuesdisplay"))) { bitSet(lSettings, P129_FLAGS_VALUES_DISPLAY); }

      if (isFormItemChecked(F("separate_events"))) { bitSet(lSettings, P129_FLAGS_SEPARATE_EVENTS); }
      # endif

      if (getFormItemInt(F("frequency"))) { bitSet(lSettings, P129_FLAGS_READ_FREQUENCY); }
      set4BitToUL(lSettings, P129_FLAGS_OUTPUT_SELECTION, getFormItemInt(F("outputsel")));

      P129_CONFIG_FLAGS = lSettings & 0xFFFF;

      uint64_t bits = 0;
      uint8_t off = 0;

      for (uint8_t i = 0; i < P129_CONFIG_CHIP_COUNT; i++) {
        if (i % 4 == 0) {
          bits = 0;
          off = 0;
        }

        for (uint8_t j = 0; j < 8; j++) {
          bitWriteULL(bits, static_cast<uint64_t>(off * 8 + (7 - j)), isFormItemChecked(getPluginCustomArgName((i * 8 + (7 - j)) + 1)));
        }
        PCONFIG_ULONG(i / 4) = bits;

        # ifndef P129_DEBUG_LOG

        if (loglevelActiveFor(LOG_LEVEL_INFO) && ((i % 4 == 3) || (i == P129_CONFIG_CHIP_COUNT))) {
          String log = F("74HC165 Writing to: ");
          log += (i / 4);
          log += F(", offset: ");
          log += (off * 8);
          log += F(", bits: ");
          log += P129_ul2stringFixed(bits, BIN);
          addLog(LOG_LEVEL_INFO, log);
        }
        # endif
        off++;
      }
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P129_data_struct(P129_CONFIG_DATA_PIN,
                                                                               P129_CONFIG_CLOCK_PIN,
                                                                               P129_CONFIG_ENABLE_PIN,
                                                                               P129_CONFIG_LOAD_PIN,
                                                                               P129_CONFIG_CHIP_COUNT));
      P129_data_struct *P129_data = static_cast<P129_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P129_data) && P129_data->isInitialized()) {
        success = P129_data->plugin_init(event);
      }

      if (!success) {
        addLog(LOG_LEVEL_ERROR, F("74HC165: Initialization error!"));
      # ifdef P129_DEBUG_LOG
      } else {
        addLog(LOG_LEVEL_INFO, F("74HC165: Initialized."));
      # endif
      }

      break;
    }

    case PLUGIN_READ:
    {
      P129_data_struct *P129_data = static_cast<P129_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P129_data) {
        success = P129_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    case PLUGIN_FIFTY_PER_SECOND:
    {
      if (((function == PLUGIN_TEN_PER_SECOND) && (P129_CONFIG_FLAGS_GET_READ_FREQUENCY == P129_FREQUENCY_10)) ||
          ((function == PLUGIN_FIFTY_PER_SECOND) && (P129_CONFIG_FLAGS_GET_READ_FREQUENCY == P129_FREQUENCY_50))) {
        P129_data_struct *P129_data = static_cast<P129_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P129_data) {
          success = P129_data->plugin_readData(event);
        }
      }

      break;
    }
    case PLUGIN_FORMAT_USERVAR:
    {
      string.clear();

      if ((P129_CONFIG_FLAGS_GET_OUTPUT_SELECTION == P129_OUTPUT_BOTH) ||
          (P129_CONFIG_FLAGS_GET_OUTPUT_SELECTION == P129_OUTPUT_DEC_ONLY)) {
        string += String(UserVar.getUint32(event->TaskIndex, event->idx));
      }

      if (P129_CONFIG_FLAGS_GET_OUTPUT_SELECTION == P129_OUTPUT_BOTH) {
        string += ',';
      }

      if ((P129_CONFIG_FLAGS_GET_OUTPUT_SELECTION == P129_OUTPUT_BOTH) ||
          (P129_CONFIG_FLAGS_GET_OUTPUT_SELECTION == P129_OUTPUT_HEXBIN)) {
        string += '0';
        string += (P129_CONFIG_FLAGS_GET_VALUES_DISPLAY ? 'b' : 'x');
        string += P129_ul2stringFixed(UserVar.getUint32(event->TaskIndex, event->idx),
                                      # ifdef P129_SHOW_VALUES
                                      (P129_CONFIG_FLAGS_GET_VALUES_DISPLAY ? BIN :
                                      # endif
                                      HEX
                                      # ifdef P129_SHOW_VALUES
                                      )
                                      # endif
                                      );
      }
      success = true;
      break;
    }

    # ifdef P129_SHOW_VALUES
    case PLUGIN_WEBFORM_SHOW_VALUES:
      {
        String state, label;
        state.reserve(40);
        String abcd = F("ABCDEFGH");
        const uint16_t endCheck = P129_CONFIG_CHIP_COUNT + 4;
        const uint16_t maxVar = min(static_cast<uint8_t>(VARS_PER_TASK), static_cast<uint8_t>(ceil(P129_CONFIG_CHIP_COUNT / 4.0f)));
        uint8_t dotInsert;
        uint8_t dotOffset;

        for (uint16_t varNr = 0; varNr < maxVar; varNr++) {
          if (P129_CONFIG_FLAGS_GET_VALUES_DISPLAY) {
            label = F("Bin");
            state = F("0b");
            dotInsert = 10;
            dotOffset = 9;
          } else {
            label = F("Hex");
            state = F("0x");
            dotInsert = 4;
            dotOffset = 3;
          }
          label += F(" State_");
          label += abcd.substring(varNr, varNr + 1);
          label += ' ';

          label += min(255, P129_CONFIG_SHOW_OFFSET + (4 * varNr) + 4);
          label += '_';
          label += (P129_CONFIG_SHOW_OFFSET + (4 * varNr) + 1);

          if ((P129_CONFIG_SHOW_OFFSET + (4 * varNr) + 4) <= endCheck) {
            state += P129_ul2stringFixed(UserVar.getUint32(event->TaskIndex, varNr), P129_CONFIG_FLAGS_GET_VALUES_DISPLAY ? BIN : HEX);

            for (uint8_t i = 0; i < 3; i++, dotInsert += dotOffset) {
              state = state.substring(0, dotInsert) + '.' + state.substring(dotInsert);
            }
            pluginWebformShowValue(event->TaskIndex, VARS_PER_TASK + varNr, label, state, true);
          }
        }
        success = true;
        break;
      }
    # endif
    case PLUGIN_WRITE:
      {
        P129_data_struct *P129_data = static_cast<P129_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P129_data) {
          success = P129_data->plugin_write(event, string);
        }

        break;
      }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P131_NeoPixelMatrix.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P131
# 30 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P131_NeoPixelMatrix.ino"
#define PLUGIN_131 
#define PLUGIN_ID_131 131
#define PLUGIN_NAME_131 "Display - NeoPixel Matrix"

# include "./src/PluginStructs/P131_data_struct.h"

boolean Plugin_131(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_131;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_131);
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P131_CONFIG_MATRIX_WIDTH = 8;
      P131_CONFIG_MATRIX_HEIGHT = 8;
      P131_CONFIG_TILE_WIDTH = 1;
      P131_CONFIG_TILE_HEIGHT = 1;

      set8BitToUL(P131_CONFIG_FLAGS, P131_FLAGS_MATRIX_TYPE,
                  NEO_MATRIX_TOP | NEO_MATRIX_LEFT | NEO_MATRIX_ROWS | NEO_MATRIX_PROGRESSIVE |
                  NEO_TILE_TOP | NEO_TILE_LEFT | NEO_TILE_ROWS | NEO_TILE_PROGRESSIVE);

      set4BitToUL(P131_CONFIG_FLAGS, P131_CONFIG_FLAG_MODE, static_cast<int>(AdaGFXTextPrintMode::TruncateExceedingMessage));

      set8BitToUL(P131_CONFIG_FLAGS_B, P131_CONFIG_FLAG_B_BRIGHTNESS, 40);
      set8BitToUL(P131_CONFIG_FLAGS_B, P131_CONFIG_FLAG_B_MAXBRIGHT, 255);

      P131_CONFIG_COLORS = ADAGFX_WHITE | (ADAGFX_BLACK << 16);

      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("DIN"));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      const int optionValuesZeroOne[] { 0, 1 };

      {
        const __FlashStringHelper *stripOptions[] = { F("GRB"), F("GRBW") };
        addFormSelector(F("Strip Type"), F("striptype"), 2, stripOptions, optionValuesZeroOne, P131_CONFIG_FLAGS_GET_STRIP_TYPE);
      }

      {
        const __FlashStringHelper *optionsTop[] = {
          F("Top/Left"),
          F("Top/Right"),
          F("Bottom/Left"),
          F("Bottom/Right") };
        const int optionValuesTop[] { 0, 2, 1, 3 };

        const __FlashStringHelper *optionsRowCol[] = {
          F("Rows"),
          F("Columns") };

        const __FlashStringHelper *optionsProZig[] = {
          F("Progressive"),
          F("Zigzag") };

        addFormSubHeader(F("Matrix"));

        addFormNumericBox(F("Matrix width"), F("mxwidth"),
                          P131_CONFIG_MATRIX_WIDTH, 1, 100);
        addFormNumericBox(F("Matrix height"), F("mxheight"),
                          P131_CONFIG_MATRIX_HEIGHT, 1, 100);

        addFormSelector(F("Matrix start-pixel"), F("mxstart"), 4, optionsTop, optionValuesTop,
                        get2BitFromUL(P131_CONFIG_FLAGS, P131_FLAGS_MATRIX_TYPE_TOP));

        addFormSelector(F("Matrix Rows/Columns mode"), F("mxrowcol"), 2, optionsRowCol, optionValuesZeroOne,
                        bitRead(P131_CONFIG_FLAGS, P131_FLAGS_MATRIX_TYPE_RC));

        addFormSelector(F("Matrix flow direction"), F("mxprozig"), 2, optionsProZig, optionValuesZeroOne,
                        bitRead(P131_CONFIG_FLAGS, P131_FLAGS_MATRIX_TYPE_PZ));

        addFormSubHeader(F("Multiple matrices: Tiles"));

        addFormNumericBox(F("Tile matrix width"), F("tlwidth"),
                          P131_CONFIG_TILE_WIDTH, 1, 32);
        addFormNumericBox(F("Tile matrix height"), F("tlheight"),
                          P131_CONFIG_TILE_HEIGHT, 1, P131_Nlines);

        addFormSelector(F("Tile start-matrix"), F("tlstart"), 4, optionsTop, optionValuesTop,
                        get2BitFromUL(P131_CONFIG_FLAGS, P131_FLAGS_TILE_TYPE_TOP));

        addFormSelector(F("Tile Rows/Columns mode"), F("tlrowcol"), 2, optionsRowCol, optionValuesZeroOne,
                        bitRead(P131_CONFIG_FLAGS, P131_FLAGS_TILE_TYPE_RC));

        addFormSelector(F("Tile flow direction"), F("tlprozig"), 2, optionsProZig, optionValuesZeroOne,
                        bitRead(P131_CONFIG_FLAGS, P131_FLAGS_TILE_TYPE_PZ));
      }

      addFormSubHeader(F("Display"));

      AdaGFXFormRotation(F("rotate"), P131_CONFIG_FLAG_GET_ROTATION);

      AdaGFXFormTextPrintMode(F("tpmode"), P131_CONFIG_FLAG_GET_MODE);

      addFormNumericBox(F("Initial brightness"), F("brightness"), P131_CONFIG_FLAG_GET_BRIGHTNESS, 0, 255);
      addUnit(F("0..255"));
      addFormNumericBox(F("Maximum allowed brightness"), F("maxbright"), P131_CONFIG_FLAG_GET_MAXBRIGHT, 1, 255);
      addUnit(F("1..255"));

      AdaGFXFormFontScaling(F("fontscale"), P131_CONFIG_FLAG_GET_FONTSCALE, 4);

      # ifdef P131_SHOW_SPLASH
      addFormCheckBox(F("Show splash on start"), F("splash"), P131_CONFIG_FLAG_GET_SHOW_SPLASH);
      # endif

      addFormCheckBox(F("Clear display on exit"), F("clearOnExit"), bitRead(P131_CONFIG_FLAGS, P131_CONFIG_FLAG_CLEAR_ON_EXIT));

      {
        const __FlashStringHelper *commandTriggers[] = {
          P131_CommandTrigger_toString(P131_CommandTrigger::neomatrix),
          P131_CommandTrigger_toString(P131_CommandTrigger::neo)
        };
        const int commandTriggerOptions[] = {
          static_cast<int>(P131_CommandTrigger::neomatrix),
          static_cast<int>(P131_CommandTrigger::neo)
        };
        constexpr int cmdCount = sizeof(commandTriggerOptions) / sizeof(commandTriggerOptions[0]);
        addFormSelector(F("Write Command trigger"),
                        F("cmdtrigger"),
                        cmdCount,
                        commandTriggers,
                        commandTriggerOptions,
                        P131_CONFIG_FLAG_GET_CMD_TRIGGER);
        # ifndef LIMIT_BUILD_SIZE
        addFormNote(F("Select the command that is used to handle commands for this display."));
        # endif
      }

      addFormSubHeader(F("Content"));

      AdaGFXFormForeAndBackColors(F("fgcolor"),
                                  P131_CONFIG_GET_COLOR_FOREGROUND,
                                  F("bgcolor"),
                                  P131_CONFIG_GET_COLOR_BACKGROUND);

      {
        String strings[P131_Nlines];
        LoadCustomTaskSettings(event->TaskIndex, strings, P131_Nlines, 0);

        uint16_t remain = DAT_TASKS_CUSTOM_SIZE;

        addFormSubHeader(F("Lines"));
        addRowLabel(F("Lines"));

        html_table(EMPTY_STRING);
        html_table_header(F("Line #&nbsp;"));
        html_table_header(F("Text"));
        html_table_header(F("Scroll"));
        html_table_header(F("Empty start"));
        html_table_header(F("Scroll right"));
        html_table_header(F("Stepsize"));
        html_table_header(F("Speed"));

        for (uint8_t varNr = 0; varNr < P131_CONFIG_TILE_HEIGHT; varNr++) {
          html_TR_TD();
          addHtml(F("&nbsp;"));
          addHtmlInt(varNr + 1);

          html_TD();
          addTextBox(getPluginCustomArgName(varNr),
                     parseStringKeepCaseNoTrim(strings[varNr], 1),
                     P131_Nchars,
                     false,
                     false,
                     EMPTY_STRING,
                     F(""));

          String opts = parseString(strings[varNr], 2);
          uint32_t optBits = 0;
          validUIntFromString(opts, optBits);

          html_TD();
          addCheckBox(getPluginCustomArgName(varNr + 100), bitRead(optBits, P131_OPTBITS_SCROLL) == 1, false
                      # if FEATURE_TOOLTIPS
                      , F("Scroll text")
                      # endif
                      );
          html_TD();
          addCheckBox(getPluginCustomArgName(varNr + 200), bitRead(optBits, P131_OPTBITS_STARTBLANK) == 0, false
                      # if FEATURE_TOOLTIPS
                      , F("Start and end scroll with empty display")
                      # endif
                      );
          html_TD();
          addCheckBox(getPluginCustomArgName(varNr + 300), bitRead(optBits, P131_OPTBITS_RIGHTSCROLL) == 1, false
                      # if FEATURE_TOOLTIPS
                      , F("Scroll from left to right")
                      # endif
                      );
          html_TD();
          addNumericBox(getPluginCustomArgName(varNr + 400), get4BitFromUL(optBits, P131_OPTBITS_SCROLLSTEP) + 1, 1, P131_MAX_SCROLL_STEPS
                        # if FEATURE_TOOLTIPS
                        , F(""), F("Scroll 1..16 pixels / step")
                        # endif
                        );

          opts = parseString(strings[varNr], 3);
          int32_t scrollSpeed = 0;
          validIntFromString(opts, scrollSpeed);

          if (scrollSpeed == 0) { scrollSpeed = 10; }
          html_TD();
          addNumericBox(getPluginCustomArgName(varNr + 500), scrollSpeed, 1, P131_MAX_SCROLL_SPEED
                        # if FEATURE_TOOLTIPS
                        , F(""), F("Scroll-speed in 0.1 seconds / step")
                        # endif
                        );

          remain -= (strings[varNr].length() + 1);

          if ((P131_CONFIG_TILE_HEIGHT > 1) && (varNr == P131_CONFIG_TILE_HEIGHT - 1)) {
            html_TD();
            addUnit(concat(F("Remaining: "), static_cast<int>(remain)));
          }
        }
        html_end_table();
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      const uint8_t prevLines = P131_CONFIG_TILE_HEIGHT;
      P131_CONFIG_MATRIX_WIDTH = getFormItemInt(F("mxwidth"));
      P131_CONFIG_MATRIX_HEIGHT = getFormItemInt(F("mxheight"));
      P131_CONFIG_TILE_WIDTH = getFormItemInt(F("tlwidth"));
      P131_CONFIG_TILE_HEIGHT = getFormItemInt(F("tlheight"));



      set2BitToUL(P131_CONFIG_FLAGS, P131_FLAGS_MATRIX_TYPE_TOP, getFormItemInt(F("mxstart")) & 0x03);
      bitWrite(P131_CONFIG_FLAGS, P131_FLAGS_MATRIX_TYPE_RC, getFormItemInt(F("mxrowcol")));
      bitWrite(P131_CONFIG_FLAGS, P131_FLAGS_MATRIX_TYPE_PZ, getFormItemInt(F("mxprozig")));


      set2BitToUL(P131_CONFIG_FLAGS, P131_FLAGS_TILE_TYPE_TOP, getFormItemInt(F("tlstart")) & 0x03);
      bitWrite(P131_CONFIG_FLAGS, P131_FLAGS_TILE_TYPE_RC, getFormItemInt(F("tlrowcol")));
      bitWrite(P131_CONFIG_FLAGS, P131_FLAGS_TILE_TYPE_PZ, getFormItemInt(F("tlprozig")));


      set4BitToUL(P131_CONFIG_FLAGS, P131_CONFIG_FLAG_MODE, getFormItemInt(F("tpmode")));
      set4BitToUL(P131_CONFIG_FLAGS, P131_CONFIG_FLAG_ROTATION, getFormItemInt(F("rotate")));
      set4BitToUL(P131_CONFIG_FLAGS, P131_CONFIG_FLAG_FONTSCALE, getFormItemInt(F("fontscale")));
      set4BitToUL(P131_CONFIG_FLAGS, P131_CONFIG_FLAG_CMD_TRIGGER, getFormItemInt(F("cmdtrigger")));

      bitWrite(P131_CONFIG_FLAGS, P131_CONFIG_FLAG_CLEAR_ON_EXIT, isFormItemChecked(F("clearOnExit")));
      bitWrite(P131_CONFIG_FLAGS, P131_CONFIG_FLAG_STRIP_TYPE, getFormItemInt(F("striptype")) == 1);
      # ifdef P131_SHOW_SPLASH
      bitWrite(P131_CONFIG_FLAGS, P131_CONFIG_FLAG_SHOW_SPLASH, !isFormItemChecked(F("splash")));
      # endif


      set8BitToUL(P131_CONFIG_FLAGS_B, P131_CONFIG_FLAG_B_BRIGHTNESS, getFormItemInt(F("brightness")));
      set8BitToUL(P131_CONFIG_FLAGS_B, P131_CONFIG_FLAG_B_MAXBRIGHT, getFormItemInt(F("maxbright")));

      String color = webArg(F("fgcolor"));
      uint16_t fgcolor = ADAGFX_WHITE;

      if (!color.isEmpty()) {
        fgcolor = AdaGFXparseColor(color);
      }
      color = webArg(F("bgcolor"));
      const uint16_t bgcolor = AdaGFXparseColor(color);

      P131_CONFIG_COLORS = fgcolor | (bgcolor << 16);

      String strings[P131_Nlines];
      String error;
      error.reserve(70);

      for (uint8_t varNr = 0; varNr < prevLines; varNr++) {
        error.clear();
        error += wrapWithQuotes(webArg(getPluginCustomArgName(varNr)));
        error += ',';
        uint32_t optBits = 0;
        bitWrite(optBits, P131_OPTBITS_SCROLL, isFormItemChecked(getPluginCustomArgName(varNr + 100)));
        bitWrite(optBits, P131_OPTBITS_STARTBLANK, !isFormItemChecked(getPluginCustomArgName(varNr + 200)));
        bitWrite(optBits, P131_OPTBITS_RIGHTSCROLL, isFormItemChecked(getPluginCustomArgName(varNr + 300)));
        set4BitToUL(optBits, P131_OPTBITS_SCROLLSTEP, getFormItemIntCustomArgName(varNr + 400) - 1);
        error += optBits;
        error += ',';
        error += getFormItemIntCustomArgName(varNr + 500);
        strings[varNr] = error;
      }
      error.clear();

      error += SaveCustomTaskSettings(event->TaskIndex, strings, P131_Nlines, 0);

      if (error.length() > 0) {
        addHtmlError(error);
      }

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      if (PIN(0) != -1) {
        # ifndef BUILD_NO_DEBUG
        String log = F("neomatrix: INIT, matrixType: 0b");
        log += String(P131_CONFIG_FLAGS_GET_MATRIX_TYPE, BIN);
        addLogMove(LOG_LEVEL_INFO, log);
        # endif
        initPluginTaskData(event->TaskIndex, new (std::nothrow) P131_data_struct(P131_CONFIG_MATRIX_WIDTH,
                                                                                 P131_CONFIG_MATRIX_HEIGHT,
                                                                                 P131_CONFIG_TILE_WIDTH,
                                                                                 P131_CONFIG_TILE_HEIGHT,
                                                                                 PIN(0),
                                                                                 P131_CONFIG_FLAGS_GET_MATRIX_TYPE,
                                                                                 P131_CONFIG_FLAGS_GET_STRIP_TYPE
                                                                                    ? NEO_GRBW + NEO_KHZ800
                                                                                    : NEO_GRB + NEO_KHZ800,
                                                                                 P131_CONFIG_FLAG_GET_ROTATION,
                                                                                 P131_CONFIG_FLAG_GET_FONTSCALE,
                                                                                 static_cast<AdaGFXTextPrintMode>(P131_CONFIG_FLAG_GET_MODE),
                                                                                 P131_CommandTrigger_toString(static_cast<P131_CommandTrigger>(
                                                                                                                P131_CONFIG_FLAG_GET_CMD_TRIGGER)),
                                                                                 P131_CONFIG_FLAG_GET_BRIGHTNESS,
                                                                                 P131_CONFIG_FLAG_GET_MAXBRIGHT,
                                                                                 P131_CONFIG_GET_COLOR_FOREGROUND,
                                                                                 P131_CONFIG_GET_COLOR_BACKGROUND));
        P131_data_struct *P131_data = static_cast<P131_data_struct *>(getPluginTaskData(event->TaskIndex));

        success = (nullptr != P131_data) && P131_data->plugin_init(event);
      # ifndef BUILD_NO_DEBUG
      } else {
        addLog(LOG_LEVEL_ERROR, F("NEOMATRIX: No GPIO pin configured, init cancelled."));
      # endif
      }

      break;
    }

    case PLUGIN_EXIT:
    {
      P131_data_struct *P131_data = static_cast<P131_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P131_data) {
        success = P131_data->plugin_exit(event);
      }
      break;
    }

    case PLUGIN_READ:
    {
      P131_data_struct *P131_data = static_cast<P131_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P131_data) {
        success = P131_data->plugin_read(event);
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P131_data_struct *P131_data = static_cast<P131_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P131_data) {
        success = P131_data->plugin_write(event, string);
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P131_data_struct *P131_data = static_cast<P131_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P131_data) {
        success = P131_data->plugin_ten_per_second(event);
      }

      break;
    }

    # if ADAGFX_ENABLE_GET_CONFIG_VALUE
    case PLUGIN_GET_CONFIG_VALUE:
    {
      P131_data_struct *P131_data = static_cast<P131_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P131_data) {
        success = P131_data->plugin_get_config_value(event, string);

      }
      break;
    }
    # endif
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P132_INA3221.ino"
#ifdef USES_P132
# 17 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P132_INA3221.ino"
#include "_Plugin_Helper.h"

#define PLUGIN_132 
#define PLUGIN_ID_132 132
#define PLUGIN_NAME_132 "Energy (DC) - INA3221"
#define PLUGIN_VALUENAME1_132 "Value1"
#define PLUGIN_VALUENAME2_132 "Value2"
#define PLUGIN_VALUENAME3_132 "Value3"
#define PLUGIN_VALUENAME4_132 "Value4"

#include "./src/PluginStructs/P132_data_struct.h"

boolean Plugin_132(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_132;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_132);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_132));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_132));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_132));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_132));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x40, 0x41, 0x42, 0x43 };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), 4, i2cAddressValues, P132_I2C_ADDR);
        addFormNote(F("A0 connected to: GND= 0x40, VCC= 0x41, SDA= 0x42, SCL= 0x43"));
      } else {
        success = intArrayContains(4, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P132_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      P132_VALUE_1 = 0;
      P132_VALUE_2 = 1;
      P132_VALUE_3 = 2;
      P132_VALUE_4 = 3;
      uint32_t lSettings = 0;
      set3BitToUL(lSettings, P132_FLAG_AVERAGE, 0x00);
      set3BitToUL(lSettings, P132_FLAG_CONVERSION_B, 0x04);
      set3BitToUL(lSettings, P132_FLAG_CONVERSION_S, 0x04);
      P132_CONFIG_FLAGS = lSettings;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      #define INA3221_var_OPTION 6
      {
        const __FlashStringHelper *varOptions[] = {
          F("Current channel 1"),
          F("Voltage channel 1"),
          F("Current channel 2"),
          F("Voltage channel 2"),
          F("Current channel 3"),
          F("Voltage channel 3")
        };

        for (uint8_t r = 0; r < VARS_PER_TASK; r++) {
          addFormSelector(concat(F("Power value "), r + 1),
                          getPluginCustomArgName(r), INA3221_var_OPTION, varOptions, NULL, PCONFIG(P132_CONFIG_BASE + r));
        }
      }


      addFormSubHeader(F("Hardware"));

      #define INA3221_shunt_OPTION 3
      {
        const __FlashStringHelper *varshuntptions[] = {
          F("0.1 ohm"),
          F("0.01 ohm"),
          F("0.005 ohm"),
        };
        const int shuntvalue[] = { 1, 10, 20 };
        addFormSelector(F("Shunt resistor"), F("shunt"), INA3221_shunt_OPTION, varshuntptions, shuntvalue, P132_SHUNT);
        addFormNote(F("Select as is installed on the board."));
      }

      addFormSubHeader(F("Measurement"));

      #define INA3221_average_OPTION 8
      {
        const __FlashStringHelper *averagingSamples[] = {
          F("1 (default)"),
          F("4"),
          F("16"),
          F("64"),
          F("128"),
          F("256"),
          F("512"),
          F("1024"),
        };
        const int averageValue[] = { 0b000, 0b001, 0b010, 0b011, 0b100, 0b101, 0b110, 0b111 };
        addFormSelector(F("Averaging samples"),
                        F("average"),
                        INA3221_average_OPTION,
                        averagingSamples,
                        averageValue,
                        P132_GET_AVERAGE);
        addFormNote(F("Samples &gt; 16 then min. Interval: 64= 4, 128= 7, 256= 14, 512= 26, 1024= 52 seconds!"));
      }

      #define INA3221_conversion_OPTION 8
      {
        const __FlashStringHelper *conversionRates[] = {
          F("140 &micro;sec"),
          F("204 &micro;sec"),
          F("332 &micro;sec"),
          F("588 &micro;sec"),
          F("1.1 msec (default)"),
          F("2.116 msec"),
          F("4.156 msec"),
          F("8.244 msec"),
        };


        const int conversionValues[] = { 0b000, 0b001, 0b010, 0b011, 0b100, 0b101, 0b110, 0b111 };
        addFormSelector(F("Conversion rate Voltage"),
                        F("conv_v"),
                        INA3221_conversion_OPTION,
                        conversionRates,
                        conversionValues,
                        P132_GET_CONVERSION_B);

        addFormSelector(F("Conversion rate Current"),
                        F("conv_c"),
                        INA3221_conversion_OPTION,
                        conversionRates,
                        conversionValues,
                        P132_GET_CONVERSION_S);
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P132_I2C_ADDR = getFormItemInt(F("i2c_addr"));

      for (uint8_t r = 0; r < VARS_PER_TASK; r++) {
        PCONFIG(P132_CONFIG_BASE + r) = getFormItemIntCustomArgName(r);
      }
      P132_SHUNT = getFormItemInt(F("shunt"));

      uint32_t lSettings = 0;
      set3BitToUL(lSettings, P132_FLAG_AVERAGE, getFormItemInt(F("average")));
      set3BitToUL(lSettings, P132_FLAG_CONVERSION_B, getFormItemInt(F("conv_v")));
      set3BitToUL(lSettings, P132_FLAG_CONVERSION_S, getFormItemInt(F("conv_c")));
      P132_CONFIG_FLAGS = lSettings;

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P132_data_struct(event));
      P132_data_struct *P132_data = static_cast<P132_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P132_data) {
        P132_data->setCalibration_INA3221(event);
        success = true;
      }

      break;
    }

    case PLUGIN_READ:
    {
      P132_data_struct *P132_data = static_cast<P132_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P132_data) {
        return success;
      }

      uint8_t reg;

      for (uint8_t r = 0; r < VARS_PER_TASK; r++) {

        reg = static_cast<uint8_t>(PCONFIG(P132_CONFIG_BASE + r) + 1);

        if ((reg == 2) || (reg == 4) || (reg == 6)) {
          UserVar.setFloat(event->TaskIndex, r, P132_data->getBusVoltage_V(reg)
                                             + (P132_data->getShuntVoltage_mV(reg - 1) / 1000.0f));
        } else {
          UserVar.setFloat(event->TaskIndex, r, (P132_data->getShuntVoltage_mV(reg) / 100.0f) * P132_SHUNT);
        }
      }

      #ifndef BUILD_NO_DEBUG

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {
        String log = F("INA3221: Values: ");
        log += UserVar[event->BaseVarIndex];
        log += '/';
        log += UserVar[event->BaseVarIndex + 1];
        log += '/';
        log += UserVar[event->BaseVarIndex + 2];
        log += '/';
        log += UserVar[event->BaseVarIndex + 3];
        addLog(LOG_LEVEL_INFO, log);
      }
      #endif

      success = true;
      break;
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P133_LTR390.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P133
# 12 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P133_LTR390.ino"
#define PLUGIN_133 
#define PLUGIN_ID_133 133
#define PLUGIN_NAME_133 "UV - LTR390"
#define PLUGIN_VALUENAME1_133 "UV"
#define PLUGIN_VALUENAME2_133 "UVIndex"
#define PLUGIN_VALUENAME3_133 "Ambient"
#define PLUGIN_VALUENAME4_133 "Lux"

# include "./src/PluginStructs/P133_data_struct.h"

boolean Plugin_133(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_133;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_133);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_133));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_133));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_133));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_133));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = event->Par1 == 0x53;
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x53;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      P133_SELECT_MODE = static_cast<int>(P133_selectMode_e::DualMode);
      P133_UVGAIN = LTR390_GAIN_3;
      P133_UVRESOLUTION = LTR390_RESOLUTION_18BIT;
      P133_ALSGAIN = LTR390_GAIN_3;
      P133_ALSRESOLUTION = LTR390_RESOLUTION_18BIT;
      P133_INITRESET = 1;

      ExtraTaskSettings.TaskDeviceValueDecimals[0] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[2] = 0;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *selectModeOptions[] = {
          F("Dual mode, read alternating UV/Ambient"),
          F("UV reading only"),
          F("Ambient reading only")
        };
        const int selectModeValues[] = {
          static_cast<int>(P133_selectMode_e::DualMode),
          static_cast<int>(P133_selectMode_e::UVMode),
          static_cast<int>(P133_selectMode_e::ALSMode)
        };
        addFormSelector(F("Read mode"), F("mode"), 3, selectModeOptions, selectModeValues, P133_SELECT_MODE, true);
      }

      const __FlashStringHelper *gainOptions[] = { F("1x"), F("3x"), F("6x"), F("9x"), F("18x") };
      const int gainValues[] = {
        LTR390_GAIN_1,
        LTR390_GAIN_3,
        LTR390_GAIN_6,
        LTR390_GAIN_9,
        LTR390_GAIN_18
      };

      const __FlashStringHelper *resolutionOptions[] = {
        F("20 bit"),
        F("19 bit"),
        F("18 bit"),
        F("17 bit"),
        F("16 bit"),
        F("13 bit")
      };
      const int resolutionValues[] = {
        LTR390_RESOLUTION_20BIT,
        LTR390_RESOLUTION_19BIT,
        LTR390_RESOLUTION_18BIT,
        LTR390_RESOLUTION_17BIT,
        LTR390_RESOLUTION_16BIT,
        LTR390_RESOLUTION_13BIT,
      };

      if (static_cast<P133_selectMode_e>(P133_SELECT_MODE) != P133_selectMode_e::ALSMode) {
        addFormSelector(F("UV Gain"), F("uvgain"), 5, gainOptions, gainValues, P133_UVGAIN);
        addFormSelector(F("UV Resolution"), F("uvres"), 6, resolutionOptions, resolutionValues, P133_UVRESOLUTION);
      }

      if (static_cast<P133_selectMode_e>(P133_SELECT_MODE) != P133_selectMode_e::UVMode) {
        addFormSelector(F("Ambient Gain"), F("alsgain"), 5, gainOptions, gainValues, P133_ALSGAIN);
        addFormSelector(F("Ambient Resolution"), F("alsres"), 6, resolutionOptions, resolutionValues, P133_ALSRESOLUTION);
      }

      addFormCheckBox(F("Reset sensor on init"), F("initreset"), P133_INITRESET == 1);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      if (static_cast<P133_selectMode_e>(P133_SELECT_MODE) != P133_selectMode_e::ALSMode) {
        P133_UVGAIN = getFormItemInt(F("uvgain"));
        P133_UVRESOLUTION = getFormItemInt(F("uvres"));
      }

      if (static_cast<P133_selectMode_e>(P133_SELECT_MODE) != P133_selectMode_e::UVMode) {
        P133_ALSGAIN = getFormItemInt(F("alsgain"));
        P133_ALSRESOLUTION = getFormItemInt(F("alsres"));
      }

      P133_SELECT_MODE = getFormItemInt(F("mode"));
      P133_INITRESET = isFormItemChecked(F("initreset")) ? 1 : 0;

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P133_data_struct(static_cast<P133_selectMode_e>(P133_SELECT_MODE),
                                                                               static_cast<ltr390_gain_t>(P133_UVGAIN),
                                                                               static_cast<ltr390_resolution_t>(P133_UVRESOLUTION),
                                                                               static_cast<ltr390_gain_t>(P133_ALSGAIN),
                                                                               static_cast<ltr390_resolution_t>(P133_ALSRESOLUTION),
                                                                               P133_INITRESET == 1));
      P133_data_struct *P133_data = static_cast<P133_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P133_data) && P133_data->plugin_init(event);
      break;
    }

    case PLUGIN_READ:
    {
      P133_data_struct *P133_data = static_cast<P133_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P133_data) {
        success = P133_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P133_data_struct *P133_data = static_cast<P133_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P133_data) {
        success = P133_data->plugin_ten_per_second(event);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P134_A02YYUW.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P134
# 16 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P134_A02YYUW.ino"
#define PLUGIN_134 
#define PLUGIN_ID_134 134
#define PLUGIN_NAME_134 "Distance - A02YYUW"
#define PLUGIN_VALUENAME1_134 "Distance"

# include "./src/PluginStructs/P134_data_struct.h"

boolean Plugin_134(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_134;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_134);

      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_134));

      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      serialHelper_getGpioNames(event, false, true);

      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P134_data_struct(CONFIG_PORT, CONFIG_PIN1, CONFIG_PIN2));
      P134_data_struct *P134_data = static_cast<P134_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P134_data) && P134_data->isInitialized();

      break;
    }

    case PLUGIN_READ:
    {
      P134_data_struct *P134_data = static_cast<P134_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P134_data) {
        success = P134_data->plugin_read(event);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P135_SCD4x.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P135
# 24 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P135_SCD4x.ino"
#define PLUGIN_135 
#define PLUGIN_ID_135 135
#define PLUGIN_NAME_135 "Gases - CO2 SCD4x"
#define PLUGIN_VALUENAME1_135 "CO2"
#define PLUGIN_VALUENAME2_135 "Humidity"
#define PLUGIN_VALUENAME3_135 "Temperature"

# include "./src/PluginStructs/P135_data_struct.h"

boolean Plugin_135(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_135;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TRIPLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 3;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].I2CMax100kHz = true;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_135);

      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_135));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_135));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_135));

      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = event->Par1 == 0x62;
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x62;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      ExtraTaskSettings.TaskDeviceValueDecimals[0] = 0;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *sensorTypes[] = {
          F("SCD40"),
          F("SCD41"),
        };
        const int sensorTypeOptions[] = {
          static_cast<int>(scd4x_sensor_type_e::SCD4x_SENSOR_SCD40),
          static_cast<int>(scd4x_sensor_type_e::SCD4x_SENSOR_SCD41),
        };
        addFormSelector(F("Sensor model"), F("ptype"), 2, sensorTypes, sensorTypeOptions, P135_SENSOR_TYPE, true);
        # ifndef LIMIT_BUILD_SIZE
        addFormNote(F("Page will reload on change."));
        # endif
      }

      addFormNumericBox(F("Altitude"), F("altitude"), P135_SENSOR_ALTITUDE, 0, 2000);
      addUnit(F("0..2000 m"));

      addFormTextBox(F("Temp offset"), F("tempoffset"), toString(P135_TEMPERATURE_OFFSET, 2), 5);
      addUnit(F("&deg;C"));

      addFormCheckBox(F("Low-power measurement"), F("pinterval"), P135_MEASURE_INTERVAL == 1);
      addFormNote(F("Unchecked= 5 sec. Checked= 30 sec. measuring duration."));

      if (P135_SENSOR_TYPE == static_cast<int>(scd4x_sensor_type_e::SCD4x_SENSOR_SCD41)) {
        addFormCheckBox(F("Single-shot measurements (SCD41 only)"), F("singleshot"), P135_MEASURE_SINGLE_SHOT == 1);
        # ifndef LIMIT_BUILD_SIZE
        addFormNote(F("When enabled will start a single measurement every Interval, duration 5 sec."));
        # endif
      }

      addFormCheckBox(F("Automatic Self Calibration"), F("autocal"), P135_AUTO_CALIBRATION == 1);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P135_SENSOR_TYPE = getFormItemInt(F("ptype"));
      uint16_t alt = getFormItemInt(F("altitude"));

      if (alt > 2000) { alt = 2000; }
      P135_SENSOR_ALTITUDE = alt;
      P135_TEMPERATURE_OFFSET = getFormItemFloat(F("tempoffset"));
      P135_AUTO_CALIBRATION = isFormItemChecked(F("autocal")) ? 1 : 0;
      P135_MEASURE_INTERVAL = isFormItemChecked(F("pinterval")) ? 1 : 0;

      if (P135_SENSOR_TYPE == static_cast<int>(scd4x_sensor_type_e::SCD4x_SENSOR_SCD41)) {
        P135_MEASURE_SINGLE_SHOT = isFormItemChecked(F("singleshot")) ? 1 : 0;
      }
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P135_data_struct(event->TaskIndex,
                                                                               P135_SENSOR_TYPE,
                                                                               P135_SENSOR_ALTITUDE,
                                                                               P135_TEMPERATURE_OFFSET,
                                                                               P135_AUTO_CALIBRATION == 1,
                                                                               P135_MEASURE_INTERVAL == 1,
                                                                               (P135_MEASURE_SINGLE_SHOT == 1) &&
                                                                               (P135_SENSOR_TYPE ==
                                                                                static_cast<int>(scd4x_sensor_type_e::SCD4x_SENSOR_SCD41))));
      P135_data_struct *P135_data = static_cast<P135_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P135_data) && P135_data->init();

      break;
    }

    case PLUGIN_READ:
    {
      P135_data_struct *P135_data = static_cast<P135_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P135_data) {
        success = P135_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_WRITE:
    {
      P135_data_struct *P135_data = static_cast<P135_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P135_data) {
        success = P135_data->plugin_write(event, string);
      }

      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      P135_data_struct *P135_data = static_cast<P135_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P135_data) {
        success = P135_data->plugin_get_config_value(event, string);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P137_AXP192.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P137

# ifdef ESP32
# 70 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P137_AXP192.ino"
#define PLUGIN_137 
#define PLUGIN_ID_137 137
#define PLUGIN_NAME_137 "Power mgt - AXP192 Power management"

# include "./src/PluginStructs/P137_data_struct.h"

boolean Plugin_137(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_137;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].PowerManager = true;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_PRIORITY_INIT:
    {
      # ifndef BUILD_NO_DEBUG
      addLogMove(LOG_LEVEL_DEBUG, F("P137: PLUGIN_PRIORITY_INIT"));
      # endif
      success = Settings.isPowerManagerTask(event->TaskIndex);
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_137);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < P137_NR_OUTPUT_VALUES) {
          ExtraTaskSettings.setTaskDeviceValueName(i, toString(static_cast<P137_valueOptions_e>(PCONFIG(P137_CONFIG_BASE + i)), false));
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P137_NR_OUTPUT_VALUES;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(P137_SENSOR_TYPE_INDEX));
      event->idx = P137_SENSOR_TYPE_INDEX;
      success = true;
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = event->Par1 == I2C_AXP192_DEFAULT_ADDRESS;
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = I2C_AXP192_DEFAULT_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG(0) = static_cast<int>(P137_valueOptions_e::VbusVoltage);
      PCONFIG(1) = static_cast<int>(P137_valueOptions_e::VbusCurrent);
      PCONFIG(2) = static_cast<int>(P137_valueOptions_e::BatteryVoltage);
      PCONFIG(3) = static_cast<int>(P137_valueOptions_e::InternalTemperature);
      PCONFIG(P137_SENSOR_TYPE_INDEX) = static_cast<uint8_t>(Sensor_VType::SENSOR_TYPE_QUAD);
      P137_CONFIG_DECIMALS = 2;
      P137_CONFIG_PREDEFINED = 2;
      P137_CheckPredefinedParameters(event);
      P137_CONFIG_PREDEFINED = 0;

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Decimals for config values"), F("decimals"), P137_CONFIG_DECIMALS, 0, 4);

      addFormSubHeader(F("Hardware outputs AXP192"));

      {
        P137_CheckPredefinedParameters(event);
        const __FlashStringHelper *predefinedNames[] = {
          toString(P137_PredefinedDevices_e::Unselected),
          toString(P137_PredefinedDevices_e::M5Stack_StickC),
          toString(P137_PredefinedDevices_e::M5Stack_Core2),
          toString(P137_PredefinedDevices_e::LilyGO_TBeam),
          toString(P137_PredefinedDevices_e::UserDefined)
        };
        const int predefinedValues[] = {
          static_cast<int>(P137_PredefinedDevices_e::Unselected),
          static_cast<int>(P137_PredefinedDevices_e::M5Stack_StickC),
          static_cast<int>(P137_PredefinedDevices_e::M5Stack_Core2),
          static_cast<int>(P137_PredefinedDevices_e::LilyGO_TBeam),
          static_cast<int>(P137_PredefinedDevices_e::UserDefined) };
        addFormSelector(F("Predefined device configuration"), F("predef"),
                        sizeof(predefinedValues) / sizeof(int),
                        predefinedNames, predefinedValues, 0, !Settings.isPowerManagerTask(event->TaskIndex));

        if (!Settings.isPowerManagerTask(event->TaskIndex)) {
          addFormNote(F("Page will reload when selection is changed."));
        }

        if (static_cast<P137_PredefinedDevices_e>(P137_CURRENT_PREDEFINED) != P137_PredefinedDevices_e::Unselected) {
          String note;
          note.reserve(55);
          note += F("Last selected: ");
          note += toString(static_cast<P137_PredefinedDevices_e>(P137_CURRENT_PREDEFINED));
          addFormNote(note);
        }
      }
      const __FlashStringHelper *notConnected = F("N/C - Unused");
      {
        const __FlashStringHelper *ldoioRangeUnit = F("range 1800 - 3300mV");

        addFormNumericBox(F("LDO2"), F("pldo2"), P137_GET_CONFIG_LDO2, -1, P137_CONST_MAX_LDO,
                          # if FEATURE_TOOLTIPS
                          EMPTY_STRING,
                          # endif
                          bitRead(P137_CONFIG_DISABLEBITS, 0));
        addUnit(bitRead(P137_CONFIG_DISABLEBITS, 0) && (P137_GET_CONFIG_LDO2 == -1) ? notConnected : ldoioRangeUnit);
        addFormNumericBox(F("LDO3"), F("pldo3"), P137_GET_CONFIG_LDO3, -1, P137_CONST_MAX_LDO,
                          # if FEATURE_TOOLTIPS
                          EMPTY_STRING,
                          # endif
                          bitRead(P137_CONFIG_DISABLEBITS, 1));
        addUnit(bitRead(P137_CONFIG_DISABLEBITS, 1) && (P137_GET_CONFIG_LDO3 == -1) ? notConnected : ldoioRangeUnit);
        addFormNumericBox(F("GPIO LDO (LDOIO)"), F("ldoiovolt"), P137_GET_CONFIG_LDOIO, -1, P137_CONST_MAX_LDOIO,
                          # if FEATURE_TOOLTIPS
                          EMPTY_STRING,
                          # endif
                          bitRead(P137_CONFIG_DISABLEBITS, 2));
        addUnit(bitRead(P137_CONFIG_DISABLEBITS, 2) && (P137_GET_CONFIG_LDOIO == -1) ? notConnected : ldoioRangeUnit);

        addFormNumericBox(F("DCDC2"), F("pdcdc2"), P137_GET_CONFIG_DCDC2, -1, P137_CONST_MAX_DCDC2,
                          # if FEATURE_TOOLTIPS
                          EMPTY_STRING,
                          # endif
                          bitRead(P137_CONFIG_DISABLEBITS, 8));
        addUnit(bitRead(P137_CONFIG_DISABLEBITS, 8) && (P137_GET_CONFIG_DCDC2 == -1) ? notConnected : F("range 700 - 2750mV"));
        addFormNumericBox(F("DCDC3"), F("pdcdc3"), P137_GET_CONFIG_DCDC3, -1, P137_CONST_MAX_DCDC,
                          # if FEATURE_TOOLTIPS
                          EMPTY_STRING,
                          # endif
                          bitRead(P137_CONFIG_DISABLEBITS, 9));
        addUnit(bitRead(P137_CONFIG_DISABLEBITS, 9) && (P137_GET_CONFIG_DCDC3 == -1) ? notConnected : F("range 700 - 3500mV"));

        addFormNote(F("Values &lt; min. range will switch off the output. Set to -1 to not initialize/unused."));
        addFormNote(F("Check your device documentation for what is connected to each output."));
      }

      {
        const __FlashStringHelper *bootStates[] = {
          toString(P137_GPIOBootState_e::Default),
          toString(P137_GPIOBootState_e::Output_low),
          toString(P137_GPIOBootState_e::Output_high),
          toString(P137_GPIOBootState_e::Input),
          toString(P137_GPIOBootState_e::PWM),
        };
        const int bootStateValues[] = {
          static_cast<int>(P137_GPIOBootState_e::Default),
          static_cast<int>(P137_GPIOBootState_e::Output_low),
          static_cast<int>(P137_GPIOBootState_e::Output_high),
          static_cast<int>(P137_GPIOBootState_e::Input),
          static_cast<int>(P137_GPIOBootState_e::PWM),
        };
        const String bootStateAttributes[] = {
          F(""),
          F(""),
          F(""),
          F("disabled"),
          F("disabled"),
        };

        for (int i = 0; i < 5; i++) {
          const String id = concat(F("pgpio"), i);
          addRowLabel(concat(F("Initial state GPIO"), i));
          addSelector(id, sizeof(bootStateValues) / sizeof(int),
                      bootStates, bootStateValues, bootStateAttributes,
                      get3BitFromUL(P137_CONFIG_FLAGS, i * 3),
                      false, !bitRead(P137_CONFIG_DISABLEBITS, i + 3), F("")
                      # if FEATURE_TOOLTIPS
                      , EMPTY_STRING
                      # endif
                      );

          if (bitRead(P137_CONFIG_DISABLEBITS, i + 3)) {
            addUnit(notConnected);
          }
        }
        addFormNote(F("This refers to AXP192 GPIO pins, <B>not</B> ESP GPIO pins!"));
      }

      {

        addHtml(F("<div hidden>"));
        addNumericBox(F("pbits"), P137_CONFIG_DISABLEBITS, 0, 0xFFFF);
        addHtml(F("</div>"));
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      const __FlashStringHelper *valOptions[] = {
        toString(P137_valueOptions_e::None),
        toString(P137_valueOptions_e::BatteryVoltage),
        toString(P137_valueOptions_e::BatteryDischargeCurrent),
        toString(P137_valueOptions_e::BatteryChargeCurrent),
        toString(P137_valueOptions_e::BatteryPower),
        toString(P137_valueOptions_e::AcinVoltage),
        toString(P137_valueOptions_e::AcinCurrent),
        toString(P137_valueOptions_e::VbusVoltage),
        toString(P137_valueOptions_e::VbusCurrent),
        toString(P137_valueOptions_e::InternalTemperature),
        toString(P137_valueOptions_e::ApsVoltage),
        toString(P137_valueOptions_e::LDO2),
        toString(P137_valueOptions_e::LDO3),
        toString(P137_valueOptions_e::LDOIO),
        toString(P137_valueOptions_e::DCDC2),
        toString(P137_valueOptions_e::DCDC3),
      };
      const int valValues[] = {
        static_cast<int>(P137_valueOptions_e::None),
        static_cast<int>(P137_valueOptions_e::BatteryVoltage),
        static_cast<int>(P137_valueOptions_e::BatteryDischargeCurrent),
        static_cast<int>(P137_valueOptions_e::BatteryChargeCurrent),
        static_cast<int>(P137_valueOptions_e::BatteryPower),
        static_cast<int>(P137_valueOptions_e::AcinVoltage),
        static_cast<int>(P137_valueOptions_e::AcinCurrent),
        static_cast<int>(P137_valueOptions_e::VbusVoltage),
        static_cast<int>(P137_valueOptions_e::VbusCurrent),
        static_cast<int>(P137_valueOptions_e::InternalTemperature),
        static_cast<int>(P137_valueOptions_e::ApsVoltage),
        static_cast<int>(P137_valueOptions_e::LDO2),
        static_cast<int>(P137_valueOptions_e::LDO3),
        static_cast<int>(P137_valueOptions_e::LDOIO),
        static_cast<int>(P137_valueOptions_e::DCDC2),
        static_cast<int>(P137_valueOptions_e::DCDC3),
      };

      for (uint8_t i = 0; i < P137_NR_OUTPUT_VALUES; i++) {
        sensorTypeHelper_loadOutputSelector(event,
                                            P137_CONFIG_BASE + i,
                                            i,
                                            sizeof(valValues) / sizeof(int),
                                            valOptions,
                                            valValues);
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      for (uint8_t i = 0; i < P137_NR_OUTPUT_VALUES; i++) {
        sensorTypeHelper_saveOutputSelector(event, P137_CONFIG_BASE + i, i,
                                            toString(static_cast<P137_valueOptions_e>(PCONFIG(P137_CONFIG_BASE + i)), false));
      }

      P137_REG_DCDC2_LDO2 = (P137_valueToSetting(getFormItemInt(F("pdcdc2")), P137_CONST_MAX_DCDC2) << 16) |
                            P137_valueToSetting(getFormItemInt(F("pldo2")), P137_CONST_MAX_LDO);
      P137_REG_DCDC3_LDO3 = (P137_valueToSetting(getFormItemInt(F("pdcdc3")), P137_CONST_MAX_DCDC) << 16) |
                            P137_valueToSetting(getFormItemInt(F("pldo3")), P137_CONST_MAX_LDO);
      P137_REG_LDOIO = P137_valueToSetting(getFormItemInt(F("ldoiovolt")), P137_CONST_MAX_LDOIO);

      for (int i = 0; i < 5; i++) {
        P137_SET_GPIO_FLAGS(i, getFormItemInt(concat(F("pgpio"), i)));
      }

      P137_CONFIG_DECIMALS = getFormItemInt(F("decimals"));
      P137_CONFIG_PREDEFINED = getFormItemInt(F("predef"));
      P137_CONFIG_DISABLEBITS = getFormItemInt(F("pbits"), static_cast<int>(P137_CONFIG_DISABLEBITS));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      P137_data_struct *P137_init = static_cast<P137_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P137_init) {
        # ifndef BUILD_NO_DEBUG
        addLogMove(LOG_LEVEL_INFO, F("P137: Already initialized, skipped."));
        # endif

        success = true;
      } else {
        # ifndef BUILD_NO_DEBUG
        addLogMove(LOG_LEVEL_DEBUG, F("P137: PLUGIN_INIT"));
        # endif
        success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P137_data_struct(event));
      }

      break;
    }

    case PLUGIN_READ:
    {
      P137_data_struct *P137_data = static_cast<P137_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P137_data) {
        success = P137_data->plugin_read(event);
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P137_data_struct *P137_data = static_cast<P137_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P137_data) {
        success = P137_data->plugin_write(event, string);
      }
      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      P137_data_struct *P137_data = static_cast<P137_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P137_data) {
        success = P137_data->plugin_get_config_value(event, string);
      }
      break;
    }
  }

  return success;
}

# endif
#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P138_IP5306.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P138
# 37 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P138_IP5306.ino"
#define PLUGIN_138 
#define PLUGIN_ID_138 138
#define PLUGIN_NAME_138 "Power mgt - IP5306 Power management"

# include "./src/PluginStructs/P138_data_struct.h"

boolean Plugin_138(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_138;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_QUAD;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_138);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < P138_NR_OUTPUT_VALUES) {
          ExtraTaskSettings.setTaskDeviceValueName(i, toString(static_cast<P138_valueOptions_e>(PCONFIG(P138_CONFIG_BASE + i)), false));
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }
      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P138_NR_OUTPUT_VALUES;
      success = true;
      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(P138_SENSOR_TYPE_INDEX));
      event->idx = P138_SENSOR_TYPE_INDEX;
      success = true;
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = event->Par1 == 0x75;
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = 0x75;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG(0) = static_cast<int>(P138_valueOptions_e::StopVoltage);
      PCONFIG(1) = static_cast<int>(P138_valueOptions_e::InCurrent);
      PCONFIG(2) = static_cast<int>(P138_valueOptions_e::BatteryCurrent);
      PCONFIG(3) = static_cast<int>(P138_valueOptions_e::ChargeLevel);
      PCONFIG(P138_SENSOR_TYPE_INDEX) = static_cast<uint8_t>(Sensor_VType::SENSOR_TYPE_QUAD);
      P138_CONFIG_DECIMALS = 2;
      bitSet(P138_CONFIG_FLAGS, P138_FLAG_POWERCHANGE);

      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      {
        const __FlashStringHelper *valOptions[] = {
          toString(P138_valueOptions_e::None),
          toString(P138_valueOptions_e::BatteryCurrent),
          toString(P138_valueOptions_e::ChargeUnderVoltage),
          toString(P138_valueOptions_e::StopVoltage),
          toString(P138_valueOptions_e::InCurrent),
          toString(P138_valueOptions_e::ChargeLevel),
          toString(P138_valueOptions_e::PowerSource),
        };
        const int valValues[] = {
          static_cast<int>(P138_valueOptions_e::None),
          static_cast<int>(P138_valueOptions_e::BatteryCurrent),
          static_cast<int>(P138_valueOptions_e::ChargeUnderVoltage),
          static_cast<int>(P138_valueOptions_e::StopVoltage),
          static_cast<int>(P138_valueOptions_e::InCurrent),
          static_cast<int>(P138_valueOptions_e::ChargeLevel),
          static_cast<int>(P138_valueOptions_e::PowerSource),
        };

        for (uint8_t i = 0; i < P138_NR_OUTPUT_VALUES; i++) {
          sensorTypeHelper_loadOutputSelector(event,
                                              P138_CONFIG_BASE + i,
                                              i,
                                              sizeof(valValues) / sizeof(int),
                                              valOptions,
                                              valValues);
        }
      }
      success = true;

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Decimals for config values"), F("decimals"), P138_CONFIG_DECIMALS, 0, 4);

      addFormCheckBox(F("Event on PowerSource change"), F("eventpwrchg"), bitRead(P138_CONFIG_FLAGS, P138_FLAG_POWERCHANGE));
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      for (uint8_t i = 0; i < P138_NR_OUTPUT_VALUES; i++) {
        sensorTypeHelper_saveOutputSelector(event, P138_CONFIG_BASE + i, i,
                                            toString(static_cast<P138_valueOptions_e>(PCONFIG(P138_CONFIG_BASE + i)), false));
      }

      P138_CONFIG_DECIMALS = getFormItemInt(F("decimals"));
      bitWrite(P138_CONFIG_FLAGS, P138_FLAG_POWERCHANGE, isFormItemChecked(F("eventpwrchg")));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P138_data_struct(event));
      break;
    }

    case PLUGIN_READ:
    {
      P138_data_struct *P138_data = static_cast<P138_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P138_data) {
        success = P138_data->plugin_read(event);
      }
      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P138_data_struct *P138_data = static_cast<P138_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P138_data) {
        success = P138_data->plugin_fifty_per_second(event);
      }
      break;
    }
# 220 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P138_IP5306.ino"
    case PLUGIN_GET_CONFIG_VALUE:
    {
      P138_data_struct *P138_data = static_cast<P138_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P138_data) {
        success = P138_data->plugin_get_config_value(event, string);
      }
      break;
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P141_PCD8544_Nokia5110.ino"
#include "_Plugin_Helper.h"

#ifdef USES_P141
# 29 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P141_PCD8544_Nokia5110.ino"
#define PLUGIN_141 
#define PLUGIN_ID_141 141
#define PLUGIN_NAME_141 "Display - PCD8544 Nokia 5110 LCD"
#define PLUGIN_VALUENAME1_141 "CursorX"
#define PLUGIN_VALUENAME2_141 "CursorY"

# include "src/PluginStructs/P141_data_struct.h"

boolean Plugin_141(uint8_t function, struct EventStruct *event, String& string)
{
  bool success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_141;
      Device[deviceCount].Type = DEVICE_TYPE_SPI3;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      # if P141_FEATURE_CURSOR_XY_VALUES
      Device[deviceCount].ValueCount = 2;
      # endif
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_141);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      # if P141_FEATURE_CURSOR_XY_VALUES
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_141));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_141));
      # endif
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      event->String1 = formatGpioName_output(F("SCE"));
      event->String2 = formatGpioName_output(F("D/C"));
      event->String3 = formatGpioName_output_optional(F("RST "));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      # ifdef ESP32

      if (Settings.InitSPI == 2) {
        P141_CS_PIN = P141_LCD_CS_HSPI;
      } else
      # endif
      {
        P141_CS_PIN = P141_LCD_CS;
      }
      P141_DC_PIN = P141_LCD_DC;
      P141_RST_PIN = P141_LCD_RST;
      P141_CONFIG_BUTTON_PIN = -1;
      P141_CONFIG_BACKLIGHT_PIN = -1;
      P141_CONFIG_BACKLIGHT_PERCENT = 50;
      P141_CONFIG_CONTRAST = 60;

      uint32_t lSettings = 0;


      set4BitToUL(lSettings, P141_CONFIG_FLAG_MODE, static_cast<int>(AdaGFXTextPrintMode::ClearThenTruncate));
      set4BitToUL(lSettings, P141_CONFIG_FLAG_FONTSCALE, 1);
      set4BitToUL(lSettings, P141_CONFIG_FLAG_LINESPACING, 15);
      set4BitToUL(lSettings, P141_CONFIG_FLAG_CMD_TRIGGER, static_cast<int>(P141_CommandTrigger::pcd8544));
      bitWrite(lSettings, P141_CONFIG_FLAG_BACK_FILL, 1);
      P141_CONFIG_FLAGS = lSettings;

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      AdaGFXFormBacklight(F("pbacklight"), P141_CONFIG_BACKLIGHT_PIN,
                          F("pbackpercent"), P141_CONFIG_BACKLIGHT_PERCENT);

      addFormNumericBox(F("Display Contrast"), F("pcontrast"), P141_CONFIG_CONTRAST, 0, 100);
      addUnit(F("0-100%"));

      AdaGFXFormDisplayButton(F("pbutton"), P141_CONFIG_BUTTON_PIN,
                              F("pbtnInverse"), bitRead(P141_CONFIG_FLAGS, P141_CONFIG_FLAG_INVERT_BUTTON),
                              F("ptimer"), P141_CONFIG_DISPLAY_TIMEOUT);

      addFormSubHeader(F("Layout"));

      AdaGFXFormRotation(F("protate"), P141_CONFIG_FLAG_GET_ROTATION);

      AdaGFXFormTextPrintMode(F("pmode"), P141_CONFIG_FLAG_GET_MODE);

      AdaGFXFormFontScaling(F("pfontscale"), P141_CONFIG_FLAG_GET_FONTSCALE);

      addFormCheckBox(F("Invert display"), F("pinvert"), bitRead(P141_CONFIG_FLAGS, P141_CONFIG_FLAG_INVERTED));

      addFormCheckBox(F("Clear display on exit"), F("pclearOnExit"), bitRead(P141_CONFIG_FLAGS, P141_CONFIG_FLAG_CLEAR_ON_EXIT));

      {
        const __FlashStringHelper *commandTriggers[] = {
          toString(P141_CommandTrigger::pcd8544),
          toString(P141_CommandTrigger::lcd),
        };
        const int commandTriggerOptions[] = {
          static_cast<int>(P141_CommandTrigger::pcd8544),
          static_cast<int>(P141_CommandTrigger::lcd),
        };
        addFormSelector(F("Write Command trigger"),
                        F("pcmdtrigger"),
                        sizeof(commandTriggerOptions) / sizeof(int),
                        commandTriggers,
                        commandTriggerOptions,
                        P141_CONFIG_FLAG_GET_CMD_TRIGGER);
        # ifndef LIMIT_BUILD_SIZE
        addFormNote(F("Select the command that is used to handle commands for this display."));
        # endif
      }


      addFormCheckBox(F("Wake display on receiving text"), F("pNoDisplay"), !bitRead(P141_CONFIG_FLAGS, P141_CONFIG_FLAG_NO_WAKE));
      # ifndef LIMIT_BUILD_SIZE
      addFormNote(F("When checked, the display wakes up at receiving remote updates."));
      # endif

      AdaGFXFormTextColRowMode(F("pcolrow"), bitRead(P141_CONFIG_FLAGS, P141_CONFIG_FLAG_USE_COL_ROW) == 1);

      AdaGFXFormTextBackgroundFill(F("pbackfill"), bitRead(P141_CONFIG_FLAGS, P141_CONFIG_FLAG_BACK_FILL) == 0);

      addFormSubHeader(F("Content"));

      String strings[P141_Nlines];
      LoadCustomTaskSettings(event->TaskIndex, strings, P141_Nlines, 0);

      # ifndef LIMIT_BUILD_SIZE
      uint16_t remain = P141_Nlines * (P141_Nchars + 1);
      # endif

      for (uint8_t varNr = 0; varNr < P141_Nlines; varNr++) {
        addFormTextBox(concat(F("Line "), varNr + 1), getPluginCustomArgName(varNr), strings[varNr], P141_Nchars);
        # ifndef LIMIT_BUILD_SIZE
        remain -= (strings[varNr].length() + 1);
        # endif
      }
      # ifndef LIMIT_BUILD_SIZE
      addUnit(concat(F("Remaining: "), remain));
      # endif

      AdaGFXFormLineSpacing(F("linespc"), P141_CONFIG_FLAG_GET_LINESPACING);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P141_CONFIG_BUTTON_PIN = getFormItemInt(F("pbutton"));
      P141_CONFIG_DISPLAY_TIMEOUT = getFormItemInt(F("ptimer"));
      P141_CONFIG_BACKLIGHT_PIN = getFormItemInt(F("pbacklight"));
      P141_CONFIG_BACKLIGHT_PERCENT = getFormItemInt(F("pbackpercent"));
      P141_CONFIG_CONTRAST = getFormItemInt(F("pcontrast"));

      uint32_t lSettings = 0;
      bitWrite(lSettings, P141_CONFIG_FLAG_NO_WAKE, !isFormItemChecked(F("pNoDisplay")));

      bitWrite(lSettings, P141_CONFIG_FLAG_INVERT_BUTTON, isFormItemChecked(F("pbtnInverse")));
      bitWrite(lSettings, P141_CONFIG_FLAG_CLEAR_ON_EXIT, isFormItemChecked(F("pclearOnExit")));
      bitWrite(lSettings, P141_CONFIG_FLAG_USE_COL_ROW, isFormItemChecked(F("pcolrow")));

      set4BitToUL(lSettings, P141_CONFIG_FLAG_MODE, getFormItemInt(F("pmode")));
      set4BitToUL(lSettings, P141_CONFIG_FLAG_ROTATION, getFormItemInt(F("protate")));
      set4BitToUL(lSettings, P141_CONFIG_FLAG_FONTSCALE, getFormItemInt(F("pfontscale")));
      set4BitToUL(lSettings, P141_CONFIG_FLAG_LINESPACING, getFormItemInt(F("linespc")));
      set4BitToUL(lSettings, P141_CONFIG_FLAG_CMD_TRIGGER, getFormItemInt(F("pcmdtrigger")));

      bitWrite(lSettings, P141_CONFIG_FLAG_BACK_FILL, !isFormItemChecked(F("pbackfill")));
      bitWrite(lSettings, P141_CONFIG_FLAG_INVERTED, isFormItemChecked(F("pinvert")));
      P141_CONFIG_FLAGS = lSettings;

      String strings[P141_Nlines];
      String error;

      for (uint8_t varNr = 0; varNr < P141_Nlines; varNr++) {
        strings[varNr] = web_server.arg(getPluginCustomArgName(varNr));
      }

      error = SaveCustomTaskSettings(event->TaskIndex, strings, P141_Nlines, 0);

      if (!error.isEmpty()) {
        addHtmlError(error);
      }

      success = true;
      break;
    }

    case PLUGIN_GET_DISPLAY_PARAMETERS:
    {
      event->Par1 = 84;
      event->Par2 = 48;
      event->Par3 = P141_CONFIG_FLAG_GET_ROTATION;
      event->Par4 = static_cast<int>(AdaGFXColorDepth::Monochrome);

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      if (Settings.InitSPI != 0) {
        initPluginTaskData(event->TaskIndex,
                           new (std::nothrow) P141_data_struct(P141_CONFIG_FLAG_GET_ROTATION,
                                                               P141_CONFIG_FLAG_GET_FONTSCALE,
                                                               static_cast<AdaGFXTextPrintMode>(P141_CONFIG_FLAG_GET_MODE),
                                                               P141_CONFIG_BACKLIGHT_PIN,
                                                               P141_CONFIG_BACKLIGHT_PERCENT,
                                                               P141_CONFIG_CONTRAST,
                                                               P141_CONFIG_DISPLAY_TIMEOUT,
                                                               toString(static_cast<P141_CommandTrigger>(
                                                                          P141_CONFIG_FLAG_GET_CMD_TRIGGER)),
                                                               ADAGFX_WHITE,
                                                               ADAGFX_BLACK,
                                                               bitRead(P141_CONFIG_FLAGS, P141_CONFIG_FLAG_BACK_FILL) == 0,
                                                               bitRead(P141_CONFIG_FLAGS, P141_CONFIG_FLAG_INVERTED) == 1));
        P141_data_struct *P141_data = static_cast<P141_data_struct *>(getPluginTaskData(event->TaskIndex));

        success = (nullptr != P141_data) && P141_data->plugin_init(event);
      # ifndef LIMIT_BUILD_SIZE
      } else {
        addLog(LOG_LEVEL_ERROR, F("PCD8544: SPI not enabled."));
      # endif
      }
      break;
    }

    case PLUGIN_EXIT:
    {
      P141_data_struct *P141_data = static_cast<P141_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P141_data) {
        success = P141_data->plugin_exit(event);
      }
      break;
    }


    case PLUGIN_FIFTY_PER_SECOND:
    {
      if (validGpio(P141_CONFIG_BUTTON_PIN)) {
        P141_data_struct *P141_data = static_cast<P141_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P141_data) {
          P141_data->registerButtonState(digitalRead(P141_CONFIG_BUTTON_PIN), bitRead(P141_CONFIG_FLAGS, P141_CONFIG_FLAG_INVERT_BUTTON));
          success = true;
        }
      }
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P141_data_struct *P141_data = static_cast<P141_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P141_data) {
        success = P141_data->plugin_ten_per_second(event);
      }
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P141_data_struct *P141_data = static_cast<P141_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P141_data) {
        success = P141_data->plugin_once_a_second(event);
      }
      break;
    }

    case PLUGIN_READ:
    {
      P141_data_struct *P141_data = static_cast<P141_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P141_data) {
        success = P141_data->plugin_read(event);
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P141_data_struct *P141_data = static_cast<P141_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P141_data) {
        success = P141_data->plugin_write(event, string);
      }
      break;
    }
    # if ADAGFX_ENABLE_GET_CONFIG_VALUE
    case PLUGIN_GET_CONFIG_VALUE:
    {
      P141_data_struct *P141_data = static_cast<P141_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P141_data) {
        success = P141_data->plugin_get_config_value(event, string);

      }
      break;
    }
    # endif
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P143_I2C_Rotary.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P143
# 35 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P143_I2C_Rotary.ino"
#define PLUGIN_143 
#define PLUGIN_ID_143 143
#define PLUGIN_NAME_143 "Switch input - I2C Rotary encoders"
#define PLUGIN_VALUENAME1_143 "Counter"
#define PLUGIN_VALUENAME2_143 "State"

# include "./src/PluginStructs/P143_data_struct.h"

boolean Plugin_143(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_143;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_143);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_143));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_143));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {

      const uint8_t i2cAddressValues[] = { 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D,
                                           # if P143_FEATURE_INCLUDE_M5STACK
                                           0x40,
                                           # endif
                                           # if P143_FEATURE_INCLUDE_DFROBOT
                                           0x54, 0x55, 0x56, 0x57
                                           # endif
      };

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        int addrOffset = 0;
        int addrLength = 13;

        switch (static_cast<P143_DeviceType_e>(P143_ENCODER_TYPE)) {
          case P143_DeviceType_e::AdafruitEncoder:
            addrLength = 8;
            break;
          # if P143_FEATURE_INCLUDE_M5STACK
          case P143_DeviceType_e::M5StackEncoder:
            addrOffset = 8;
            addrLength = 1;
            break;
          # endif
          # if P143_FEATURE_INCLUDE_DFROBOT
          case P143_DeviceType_e::DFRobotEncoder:
            addrOffset = 9;
            addrLength = 4;
            break;
          # endif
        }
        addFormSelectorI2C(F("pi2c"), addrLength, &i2cAddressValues[addrOffset], P143_I2C_ADDR);
      } else {
        int addrCount = 8;
        # if P143_FEATURE_INCLUDE_M5STACK
        addrCount++;
        # endif
        # if P143_FEATURE_INCLUDE_DFROBOT
        addrCount += 4;
        # endif
        success = intArrayContains(addrCount, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P143_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      string = F("Encoder: ");
      string += toString(static_cast<P143_DeviceType_e>(P143_ENCODER_TYPE));
      string += F(" (");
      string += formatToHex(P143_I2C_ADDR);
      string += ')';
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P143_I2C_ADDR = 0x36;
      P143_ENCODER_TYPE = static_cast<int16_t>(P143_DeviceType_e::AdafruitEncoder);
      P143_PREVIOUS_TYPE = -1;

      ExtraTaskSettings.TaskDeviceValueDecimals[0] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[1] = 0;
      P143_SET_LONGPRESS_INTERVAL = P143_LONGPRESS_MIN_INTERVAL;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      P143_CheckEncoderDefaultSettings(event);

      {
        const __FlashStringHelper *selectModeOptions[] = {
          toString(P143_DeviceType_e::AdafruitEncoder),
          # if P143_FEATURE_INCLUDE_M5STACK
          toString(P143_DeviceType_e::M5StackEncoder),
          # endif
          # if P143_FEATURE_INCLUDE_DFROBOT
          toString(P143_DeviceType_e::DFRobotEncoder),
          # endif
        };
        const int selectModeValues[] = {
          static_cast<int>(P143_DeviceType_e::AdafruitEncoder),
          # if P143_FEATURE_INCLUDE_M5STACK
          static_cast<int>(P143_DeviceType_e::M5StackEncoder),
          # endif
          # if P143_FEATURE_INCLUDE_DFROBOT
          static_cast<int>(P143_DeviceType_e::DFRobotEncoder)
          # endif
        };
        addFormSelector(F("Encoder type"),
                        F("pdevice"),
                        sizeof(selectModeValues) / sizeof(int),
                        selectModeOptions,
                        selectModeValues,
                        P143_ENCODER_TYPE,
                        true);
        addFormNote(F("Changing the Encoder type will reload the page and reset Encoder specific settings to default!"));
      }

      P143_DeviceType_e device = static_cast<P143_DeviceType_e>(P143_ENCODER_TYPE);

      addFormSubHeader(concat(F("Encoder specific: "), toString(device)));

      switch (device) {
        case P143_DeviceType_e::AdafruitEncoder:
        # if P143_FEATURE_INCLUDE_M5STACK
        case P143_DeviceType_e::M5StackEncoder:
        # endif
        {
          {
            addRowLabel(F("Neopixel 1 initial color"));
            addHtml(F("<table style='padding:0;'>"));
            html_TD(F("padding:0"));
            addHtml('R');
            addNumericBox(F("pred"), P143_ADAFRUIT_COLOR_RED, 0, 255);
            html_TD();
            addHtml('G');
            addNumericBox(F("pgreen"), P143_ADAFRUIT_COLOR_GREEN, 0, 255);
            html_TD();
            addHtml('B');
            addNumericBox(F("pblue"), P143_ADAFRUIT_COLOR_BLUE, 0, 255);
            addUnit(F("0..255"));
            html_end_table();
            # if P143_FEATURE_INCLUDE_M5STACK

            if (device == P143_DeviceType_e::M5StackEncoder) {
              addRowLabel(F("Neopixel 2 initial color"));
              addHtml(F("<table style='padding:0;'>"));
              html_TD(F("padding:0"));
              addHtml('R');
              addNumericBox(F("pred2"), P143_M5STACK2_COLOR_RED, 0, 255);
              html_TD();
              addHtml('G');
              addNumericBox(F("pgreen2"), P143_M5STACK2_COLOR_GREEN, 0, 255);
              html_TD();
              addHtml('B');
              addNumericBox(F("pblue2"), P143_M5STACK2_COLOR_BLUE, 0, 255);
              addUnit(F("0..255"));
              html_end_table();
            }
            # endif
          }
          addFormNumericBox(F("Initial brightness"), F("pbright"), P143_NEOPIXEL_BRIGHTNESS, 1, 255);
          addUnit(F("1..255"));
          # if P143_FEATURE_INCLUDE_M5STACK

          if (device == P143_DeviceType_e::M5StackEncoder) {
            const __FlashStringHelper *selectLedModeOptions[] = {
              F("Both leds"),
              F("Led 1 only"),
              F("Led 2 only"),
            };
            const int selectLedModeValues[] = {
              static_cast<int>(P143_M5StackLed_e::BothLeds),
              static_cast<int>(P143_M5StackLed_e::Led1Only),
              static_cast<int>(P143_M5StackLed_e::Led2Only),
            };
            addFormSelector(F("Color map Leds"),
                            F("pledsel"),
                            sizeof(selectLedModeValues) / sizeof(int),
                            selectLedModeOptions,
                            selectLedModeValues,
                            P143_M5STACK_SELECTION);
          }
          # endif
          break;
        }
        # if P143_FEATURE_INCLUDE_DFROBOT
        case P143_DeviceType_e::DFRobotEncoder:
        {
          addFormNumericBox(F("Led vs. rotation gain"), F("pledgain"), P143_DFROBOT_LED_GAIN, P143_DFROBOT_MIN_GAIN, P143_DFROBOT_MAX_GAIN);
          addFormNote(F("Range 1..51, 1 =&gt; 1 led/~2.5 turns, 51 =&gt; 1 led/detent"));
          break;
        }
        # endif
      }

      addFormSubHeader(F("Generic settings"));

      addFormNumericBox(F("Initial encoder position"), F("pinitpos"), P143_INITIAL_POSITION);
      addFormNumericBox(F("Lowest encoder position"), F("pminpos"), P143_MINIMAL_POSITION);
      addFormNumericBox(F("Highest encoder position"), F("pmaxpos"), P143_MAXIMAL_POSITION);
      addFormNote(F("Not checked if Lowest = Highest."));
      # if P143_FEATURE_INCLUDE_DFROBOT

      if (device == P143_DeviceType_e::DFRobotEncoder) {
        addFormNumericBox(F("Offset to position"), F("poffset"), P143_OFFSET_POSITION, P143_DFROBOT_MIN_OFFSET, P143_DFROBOT_MAX_OFFSET);
        addFormNote(F("Range: 0..1023. To enable negative counter values for DFRobot encoder."));
      }
      # endif

      {
        const __FlashStringHelper *selectButtonOptions[] = {
          toString(P143_ButtonAction_e::PushButton),
          toString(P143_ButtonAction_e::PushButtonInverted),
          toString(P143_ButtonAction_e::ToggleSwitch),
        };
        const int selectButtonValues[] = {
          static_cast<int>(P143_ButtonAction_e::PushButton),
          static_cast<int>(P143_ButtonAction_e::PushButtonInverted),
          static_cast<int>(P143_ButtonAction_e::ToggleSwitch),
        };
        addFormSelector(F("Button action"),
                        F("pbutton"),
                        sizeof(selectButtonValues) / sizeof(int),
                        selectButtonOptions,
                        selectButtonValues,
                        P143_PLUGIN_BUTTON_ACTION);

        # if P143_FEATURE_INCLUDE_DFROBOT

        if (device != P143_DeviceType_e::DFRobotEncoder)
        # endif
        {
          addFormCheckBox(F("Enable Pushbutton longpress"), F("plongenable"), P143_PLUGIN_ENABLE_LONGPRESS);
          addFormNumericBox(F("Longpress min. interval"),
                            F("plongpress"),
                            P143_GET_LONGPRESS_INTERVAL,
                            P143_LONGPRESS_MIN_INTERVAL,
                            P143_LONGPRESS_MAX_INTERVAL);
          addUnit(F("ms"));
          # ifndef BUILD_NO_DEBUG
          addFormNote(F("Range: 500..5000 ms. Longpress: State = 11 for Pushbutton, 10 for Pushbutton (inverted)."));
          # endif
        }
      }

      # if P143_FEATURE_COUNTER_COLORMAPPING
      # if P143_FEATURE_INCLUDE_DFROBOT

      if (device != P143_DeviceType_e::DFRobotEncoder)
      # endif
      {
        {
          const __FlashStringHelper *selectCounterOptions[] = {
            toString(P143_CounterMapping_e::None),
            toString(P143_CounterMapping_e::ColorMapping),
            toString(P143_CounterMapping_e::ColorGradient),
          };
          const int selectCounterValues[] = {
            static_cast<int>(P143_CounterMapping_e::None),
            static_cast<int>(P143_CounterMapping_e::ColorMapping),
            static_cast<int>(P143_CounterMapping_e::ColorGradient),
          };
          addFormSelector(F("Counter color mapping"),
                          F("pmap"),
                          sizeof(selectCounterValues) / sizeof(int),
                          selectCounterOptions,
                          selectCounterValues,
                          P143_PLUGIN_COUNTER_MAPPING);
        }
        {
          String strings[P143_STRINGS];
          LoadCustomTaskSettings(event->TaskIndex, strings, P143_STRINGS, 0);

          addRowLabel(F("Colormap"));
          html_table(EMPTY_STRING);

          for (int varNr = 0; varNr < P143_STRINGS; varNr++) {
            html_TR_TD();


            addHtml('#');
            addHtmlInt(varNr + 1);
            html_TD();
            addTextBox(getPluginCustomArgName(varNr), strings[varNr], P143_STRING_LEN, false, false, EMPTY_STRING, F("xwide"));
          }
          html_end_table();
        }
      }
      # endif

      addFormCheckBox(F("Led(s) off on exit"), F("pexit"), P143_PLUGIN_EXIT_LED_OFF);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P143_I2C_ADDR = getFormItemInt(F("pi2c"));
      P143_ENCODER_TYPE = getFormItemInt(F("pdevice"));
      P143_INITIAL_POSITION = getFormItemInt(F("pinitpos"));
      P143_MINIMAL_POSITION = getFormItemInt(F("pminpos"));
      P143_MAXIMAL_POSITION = getFormItemInt(F("pmaxpos"));

      uint32_t lSettings = 0u;
      P143_DeviceType_e device = static_cast<P143_DeviceType_e>(P143_ENCODER_TYPE);

      # if P143_FEATURE_INCLUDE_DFROBOT

      if (device != P143_DeviceType_e::DFRobotEncoder)
      # endif
      {
        P143_SET_LONGPRESS_INTERVAL = getFormItemInt(F("plongpress"));
      }

      switch (device) {
        case P143_DeviceType_e::AdafruitEncoder:
        # if P143_FEATURE_INCLUDE_M5STACK
        case P143_DeviceType_e::M5StackEncoder:
        # endif
        {

          set8BitToUL(lSettings, P143_ADAFRUIT_OFFSET_RED, getFormItemInt(F("pred")) & 0xFF);
          set8BitToUL(lSettings, P143_ADAFRUIT_OFFSET_GREEN, getFormItemInt(F("pgreen")) & 0xFF);
          set8BitToUL(lSettings, P143_ADAFRUIT_OFFSET_BLUE, getFormItemInt(F("pblue")) & 0xFF);
          set8BitToUL(lSettings, P143_ADAFRUIT_OFFSET_BRIGHTNESS, getFormItemInt(F("pbright")) & 0xFF);
          P143_ADAFRUIT_COLOR_AND_BRIGHTNESS = lSettings;

          # if P143_FEATURE_INCLUDE_M5STACK

          if (device == P143_DeviceType_e::M5StackEncoder) {
            lSettings = 0u;
            set8BitToUL(lSettings, P143_M5STACK2_OFFSET_RED, getFormItemInt(F("pred2")) & 0xFF);
            set8BitToUL(lSettings, P143_M5STACK2_OFFSET_GREEN, getFormItemInt(F("pgreen2")) & 0xFF);
            set8BitToUL(lSettings, P143_M5STACK2_OFFSET_BLUE, getFormItemInt(F("pblue2")) & 0xFF);
            set4BitToUL(lSettings, P143_M5STACK_OFFSET_SELECTION, getFormItemInt(F("pledsel")) & 0x0F);
            P143_M5STACK_COLOR_AND_SELECTION = lSettings;
          }
          # endif

          break;
        }
        # if P143_FEATURE_INCLUDE_DFROBOT
        case P143_DeviceType_e::DFRobotEncoder:
        {
          P143_DFROBOT_LED_GAIN = getFormItemInt(F("pledgain"));
          P143_OFFSET_POSITION = getFormItemInt(F("poffset"));
          break;
        }
        # endif
      }


      lSettings = 0u;
      # if P143_FEATURE_COUNTER_COLORMAPPING
      # if P143_FEATURE_INCLUDE_DFROBOT

      if (device != P143_DeviceType_e::DFRobotEncoder)
      # endif
      {
        set4BitToUL(lSettings, P143_PLUGIN_OFFSET_COUNTER_MAPPING, getFormItemInt(F("pmap")) & 0x0F);
      }
      # endif
      set4BitToUL(lSettings, P143_PLUGIN_OFFSET_BUTTON_ACTION, getFormItemInt(F("pbutton")) & 0x0F);
      bitWrite(lSettings, P143_PLUGIN_OFFSET_EXIT_LED_OFF, isFormItemChecked(F("pexit")) == 0);
      # if P143_FEATURE_INCLUDE_DFROBOT

      if (device != P143_DeviceType_e::DFRobotEncoder)
      # endif
      {
        bitWrite(lSettings, P143_PLUGIN_OFFSET_LONGPRESS, isFormItemChecked(F("plongenable")) == 1);
      }
      P143_PLUGIN_FLAGS = lSettings;

      # if P143_FEATURE_COUNTER_COLORMAPPING
      # if P143_FEATURE_INCLUDE_DFROBOT

      if (device != P143_DeviceType_e::DFRobotEncoder)
      # endif
      {

        String strings[P143_STRINGS];

        for (int varNr = 0; varNr < P143_STRINGS; varNr++) {
          strings[varNr] = webArg(getPluginCustomArgName(varNr));
        }
        String error = SaveCustomTaskSettings(event->TaskIndex, strings, P143_STRINGS, 0);

        if (error.length() > 0) {
          addHtmlError(error);
        }
      }
      # endif

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P143_data_struct(event));
      P143_data_struct *P143_data = static_cast<P143_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P143_data) && P143_data->plugin_init(event);
      break;
    }

    case PLUGIN_EXIT:
    {
      P143_data_struct *P143_data = static_cast<P143_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P143_data) {
        success = P143_data->plugin_exit(event);
      }
      break;
    }

    case PLUGIN_READ:
    {
      P143_data_struct *P143_data = static_cast<P143_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P143_data) {
        success = P143_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_WRITE:
    {
      P143_data_struct *P143_data = static_cast<P143_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P143_data) {
        success = P143_data->plugin_write(event, string);
      }

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P143_data_struct *P143_data = static_cast<P143_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P143_data) {
        success = P143_data->plugin_ten_per_second(event);
      }

      break;
    }

    case PLUGIN_FIFTY_PER_SECOND:
    {
      P143_data_struct *P143_data = static_cast<P143_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P143_data) {
        success = P143_data->plugin_fifty_per_second(event);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P144_Vindriktning.ino"
# 17 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P144_Vindriktning.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P144
#include "src/PluginStructs/P144_data_struct.h"


#define PLUGIN_144 
#define PLUGIN_ID_144 144
#define PLUGIN_NAME_144 "Dust - PM1006(K) (Vindriktning)"
#define PLUGIN_VALUENAME1_144 "PM2.5"
# 45 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P144_Vindriktning.ino"
boolean Plugin_144(uint8_t function, struct EventStruct *event, String& string)
{




  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {


      Device[++deviceCount].Number = PLUGIN_ID_144;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Default;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].Custom = false;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = false;
      Device[deviceCount].DecimalsOnly = false;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {

      string = F(PLUGIN_NAME_144);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {



      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_144));
      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      serialHelper_getGpioNames(event, false, true);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {

      string += serialHelper_getSerialTypeLabel(event);
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
# 140 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P144_Vindriktning.ino"
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {






      success = true;
      break;
    }
    case PLUGIN_INIT:
    {

      int8_t rxPin = serialHelper_getRxPin(event);
      int8_t txPin = serialHelper_getTxPin(event);
      ESPEasySerialPort portType = serialHelper_getSerialType(event);


      initPluginTaskData(event->TaskIndex, new (std::nothrow) P144_data_struct());
      P144_data_struct *P144_data =
        static_cast<P144_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (P144_data != nullptr)
      {
        success = P144_data->setSerial(portType, rxPin, txPin);
      }
      break;
    }

    case PLUGIN_READ:
    {


      P144_data_struct *P144_data =
        static_cast<P144_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (P144_data != nullptr) {
        UserVar.setFloat(event->TaskIndex, 0, P144_data->getValue());
        #ifdef PLUGIN_144_DEBUG
        if (loglevelActiveFor(LOG_LEVEL_INFO))
        {
          String log = F("P144 : READ ");
          log += UserVar[event->BaseVarIndex];
          addLogMove(LOG_LEVEL_INFO, log);
        }
        #endif
      }
      success = true;
      break;
    }

    case PLUGIN_WRITE:
    {





      break;
    }

    case PLUGIN_EXIT:
    {


      P144_data_struct *P144_data =
        static_cast<P144_data_struct *>(getPluginTaskData(event->TaskIndex));
      if (P144_data != nullptr) {
        P144_data->disconnectSerial();
      }
      success = true;
      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {

      success = true;
      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {


      P144_data_struct *P144_data =
        static_cast<P144_data_struct *>(getPluginTaskData(event->TaskIndex));
      if (P144_data != nullptr)
      {
        success = P144_data->processSensor();
      }
      break;
    }

  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P145_MQxxx.ino"
# 70 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P145_MQxxx.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P145
#include "src/PluginStructs/P145_data_struct.h"

#define PLUGIN_145 
#define PLUGIN_ID_145 145
#define PLUGIN_NAME_145 "Gases - MQxxx (MQ135 CO2, MQ3 Alcohol) [TESTING]"
#define PLUGIN_VALUENAME1_145 "level"
#define PLUGIN_145_DEBUG false






#define P145_PCONFIG_RLOAD PCONFIG_FLOAT(0)
#define P145_PCONFIG_RZERO PCONFIG_FLOAT(1)
#define P145_PCONFIG_REF PCONFIG_FLOAT(2)
#define P145_PCONFIG_FLAGS PCONFIG(0)
#define P145_PCONFIG_TEMP_TASK PCONFIG(1)
#define P145_PCONFIG_TEMP_VAL PCONFIG(2)
#define P145_PCONFIG_HUM_TASK PCONFIG(3)
#define P145_PCONFIG_HUM_VAL PCONFIG(4)
#define P145_PCONFIG_SENSORT PCONFIG(5)


#define P145_CONFIG_PIN_AIN CONFIG_PIN1
#define P145_CONFIG_PIN_HEATER CONFIG_PIN2


#define P145_GUID_TYPE "f01"
#define P145_GUID_RLOAD "f02"
#define P145_GUID_RZERO "f03"
#define P145_GUID_RREFLEVEL "f04"
#define P145_GUID_CAL "f05"
#define P145_GUID_COMP "f06"
#define P145_GUID_LOWVCC "f07"
#define P145_GUID_TEMP_T "f08"
#define P145_GUID_TEMP_V "f09"
#define P145_GUID_HUM_T "f10"
#define P145_GUID_HUM_V "f11"
#define P145_GUID_AINPIN "f12"
#define P145_GUID_HEATPIN "f13"



boolean Plugin_145(byte function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {

    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_145;
      Device[deviceCount].Type = DEVICE_TYPE_CUSTOM0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }


    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_145);
      break;
    }


    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_145));
      break;
    }


    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      string = F("AIN: ");
# ifdef ESP32
      string += formatGpioLabel(P145_CONFIG_PIN_AIN, false);
#else
      string += F("ADC (TOUT)");
#endif
      if (validGpio(P145_CONFIG_PIN_HEATER))
      {
        string += F("<BR>HEAT: ");
        string += formatGpioLabel(P145_CONFIG_PIN_HEATER, false);
      }
      success = true;
      break;
    }


    case PLUGIN_WEBFORM_LOAD:
    {
      bool compensate = P145_PCONFIG_FLAGS & 0x0001;
      bool calibrate = (P145_PCONFIG_FLAGS >> 1) & 0x0001;
      bool lowvcc = (P145_PCONFIG_FLAGS >> 2) & 0x0001;


      String options[P145_MAXTYPES] = {};
      int optionValues[P145_MAXTYPES] = {};
      int x = P145_data_struct::getNbrOfTypes();
      if (x > P145_MAXTYPES)
      {
        x = P145_MAXTYPES;
      }
      for (int i=0; i<x; i++)
      {
        options[i] = concat(P145_data_struct::getTypeName(i), F(" - ")) + P145_data_struct::getGasName(i);
        optionValues[i] = i;
      }
      addFormSelector(F("Sensor type"), F(P145_GUID_TYPE), x, options, optionValues, P145_PCONFIG_SENSORT);

# ifdef ESP32

      addRowLabel(formatGpioName_input(F("Analog Pin ")));
#if HAS_HALL_EFFECT_SENSOR
      addADC_PinSelect(AdcPinSelectPurpose::ADC_Touch_HallEffect, F(P145_GUID_AINPIN), P145_CONFIG_PIN_AIN);
#else
      addADC_PinSelect(AdcPinSelectPurpose::ADC_Touch, F(P145_GUID_AINPIN), P145_CONFIG_PIN_AIN);
#endif
# endif
      addFormPinSelect( PinSelectPurpose::Generic_output, formatGpioName_output_optional(F("Heater Pin ")), F(P145_GUID_HEATPIN), P145_CONFIG_PIN_HEATER);

      addFormFloatNumberBox(F("Load Resistance"), F(P145_GUID_RLOAD), P145_PCONFIG_RLOAD, 0.0f, 10e6f, 2U);
      addUnit(F("Ohm"));
      addFormFloatNumberBox(F("R Zero"), F(P145_GUID_RZERO), P145_PCONFIG_RZERO, 0.0f, 10e6f, 2U);
      addUnit(F("Ohm"));
      addFormFloatNumberBox(F("Reference Level"), F(P145_GUID_RREFLEVEL), P145_PCONFIG_REF, 0.0f, 10e6f, 2U);
      addUnit(F("ppm"));
      P145_data_struct *P145_data = static_cast<P145_data_struct *>(getPluginTaskData(event->TaskIndex));
      if (P145_data != nullptr)
      {
        float calVal = P145_data->getCalibrationValue();
        if (calVal > 0.0)
        {
          addFormNote(String(F("Current measurement suggests Rzero= ")) + String(calVal));
        }
      }
      addFormCheckBox(F("Low sensor supply voltage"), F(P145_GUID_LOWVCC), lowvcc);

      addFormSeparator(2);

      addFormCheckBox(F("Enable automatic calibration"), F(P145_GUID_CAL), calibrate);
      addFormSelector_YesNo(F("Enable temp/humid compensation"), F(P145_GUID_COMP), compensate, true);


      if (compensate)
      {
        addFormNote(F("If compensation is enabled, the Temperature and Humidity values below need to be configured."));

        addRowLabel(F("Temperature"));
        addTaskSelect(F(P145_GUID_TEMP_T), P145_PCONFIG_TEMP_TASK);
        if (validTaskIndex(P145_PCONFIG_TEMP_TASK))
        {
          LoadTaskSettings(P145_PCONFIG_TEMP_TASK);
          addRowLabel(F("Temperature Value"));
          addTaskValueSelect(F(P145_GUID_TEMP_V), P145_PCONFIG_TEMP_VAL, P145_PCONFIG_TEMP_TASK);
        }

        addRowLabel(F("Humidity"));
        addTaskSelect(F(P145_GUID_HUM_T), P145_PCONFIG_HUM_TASK);
        if (validTaskIndex(P145_PCONFIG_HUM_TASK))
        {
          LoadTaskSettings(P145_PCONFIG_HUM_TASK);
          addRowLabel(F("Humidity Value"));
          addTaskValueSelect(F(P145_GUID_HUM_V), P145_PCONFIG_HUM_VAL, P145_PCONFIG_HUM_TASK);
        }
        LoadTaskSettings(event->TaskIndex);
      }

      success = true;
      break;
    }


    case PLUGIN_WEBFORM_SAVE:
    {
      P145_PCONFIG_SENSORT = getFormItemInt(F(P145_GUID_TYPE));
      P145_PCONFIG_RLOAD = getFormItemFloat(F(P145_GUID_RLOAD));
      P145_PCONFIG_RZERO = getFormItemFloat(F(P145_GUID_RZERO));
      P145_PCONFIG_REF = getFormItemFloat(F(P145_GUID_RREFLEVEL));
      bool compensate = (getFormItemInt(F(P145_GUID_COMP)) == 1);
      bool calibrate = isFormItemChecked(F(P145_GUID_CAL));
      bool lowvcc = isFormItemChecked(F(P145_GUID_LOWVCC));
      P145_PCONFIG_FLAGS = compensate + (calibrate << 1) + (lowvcc << 2);
      P145_PCONFIG_TEMP_TASK = getFormItemInt(F(P145_GUID_TEMP_T));
      P145_PCONFIG_TEMP_VAL = getFormItemInt(F(P145_GUID_TEMP_V));
      P145_PCONFIG_HUM_TASK = getFormItemInt(F(P145_GUID_HUM_T));
      P145_PCONFIG_HUM_VAL = getFormItemInt(F(P145_GUID_HUM_V));
# ifdef ESP32
      P145_CONFIG_PIN_AIN = getFormItemInt(F(P145_GUID_AINPIN));
#endif
      P145_CONFIG_PIN_HEATER = getFormItemInt(F(P145_GUID_HEATPIN));

      P145_data_struct *P145_data = static_cast<P145_data_struct *>(getPluginTaskData(event->TaskIndex));
      if (P145_data != nullptr)
      {
        P145_data->setSensorData(P145_PCONFIG_SENSORT, compensate, calibrate, lowvcc, P145_PCONFIG_RLOAD, P145_PCONFIG_RZERO, P145_PCONFIG_REF);
        P145_data->setSensorPins(P145_CONFIG_PIN_AIN, P145_CONFIG_PIN_HEATER);
        P145_data->dump();
      }
      success = true;
      break;
    }


    case PLUGIN_INIT:
    {
      P145_data_struct *P145_data = static_cast<P145_data_struct *>(getPluginTaskData(event->TaskIndex));
      if (P145_data == nullptr)
      {
        P145_data = new (std::nothrow) P145_data_struct();
        initPluginTaskData(event->TaskIndex, P145_data);
        if (P145_data != nullptr)
        {
          P145_data->plugin_init();
          P145_data->setSensorData(P145_PCONFIG_SENSORT, P145_PCONFIG_FLAGS & 0x0001, (P145_PCONFIG_FLAGS >> 1) & 0x0001, (P145_PCONFIG_FLAGS >> 2) & 0x0001, P145_PCONFIG_RLOAD, P145_PCONFIG_RZERO, P145_PCONFIG_REF);
          P145_data->setSensorPins(P145_CONFIG_PIN_AIN, P145_CONFIG_PIN_HEATER);
          P145_data->dump();
        }
      }
      success = true;
      break;
    }


    case PLUGIN_TEN_PER_SECOND:
    {
      P145_data_struct *P145_data = static_cast<P145_data_struct *>(getPluginTaskData(event->TaskIndex));
      if (P145_data != nullptr)
      {
        success = P145_data->plugin_ten_per_second();
      }
      break;
    }


    case PLUGIN_READ:
    {
      P145_data_struct *P145_data = static_cast<P145_data_struct *>(getPluginTaskData(event->TaskIndex));
      if (P145_data != nullptr)
      {
        float temperature = 20.0f;
        float humidity = 60.0f;
        bool compensate = P145_PCONFIG_FLAGS & 0x0001;
        if (compensate && validTaskIndex(P145_PCONFIG_TEMP_TASK) && validTaskIndex(P145_PCONFIG_HUM_TASK))
        {

          temperature = UserVar[P145_PCONFIG_TEMP_TASK * VARS_PER_TASK + P145_PCONFIG_TEMP_VAL];
          humidity = UserVar[P145_PCONFIG_HUM_TASK * VARS_PER_TASK + P145_PCONFIG_HUM_VAL];
        }
        UserVar.setFloat(event->TaskIndex, 0, P145_data->readValue(temperature, humidity));
        success = true;
      }
      break;
    }


    case PLUGIN_ONCE_A_SECOND:
    {
      P145_data_struct *P145_data = static_cast<P145_data_struct *>(getPluginTaskData(event->TaskIndex));
      if (P145_data != nullptr)
      {
        if ((P145_PCONFIG_FLAGS >> 1) & 0x0001)
        {


          P145_PCONFIG_RZERO = P145_data->getAutoCalibrationValue();
        }
        P145_data->heaterControl();
      }
      break;
    }
  }
  return success;
}
#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P146_CacheControllerReader.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P146

# include "src/PluginStructs/P146_data_struct.h"
# 25 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P146_CacheControllerReader.ino"
#define PLUGIN_146 
#define PLUGIN_ID_146 146
#define PLUGIN_NAME_146 "Generic - Cache Reader"
#define PLUGIN_VALUENAME1_146 "FileNr"
#define PLUGIN_VALUENAME2_146 "FilePos"


# include "src/ControllerQueue/C016_queue_element.h"
# include "src/Globals/C016_ControllerCache.h"
# include "src/Globals/CPlugins.h"

boolean Plugin_146(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_146;
      Device[deviceCount].Type = DEVICE_TYPE_DUMMY;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].DecimalsOnly = false;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = false;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Default;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_146);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_146));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_146));
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P146_SET_ERASE_BINFILES(0);
      P146_SET_SEND_BINARY(0);
      P146_SET_SEND_BULK(1);
      P146_SET_SEND_TIMESTAMP(1);
      P146_SET_SEND_READ_POS(1);
      P146_SET_JOIN_TIMESTAMP(1);
      P146_SET_ONLY_SET_TASKS(1);
      P146_SEPARATOR_CHARACTER = ',';

      P146_MINIMAL_SEND_INTERVAL = 100;
      P146_MQTT_MESSAGE_LENGTH = 800;

      String strings[P146_Nlines];
      strings[P146_TaskInfoTopicIndex] = F("%sysname%_%unit%/%tskname%/upload_meta");
      strings[P146_PublishTopicIndex] = F("%sysname%_%unit%/%tskname%/upload");

      SaveCustomTaskSettings(event->TaskIndex, strings, P146_Nlines, 0);


      success = true;
      break;
    }

    case PLUGIN_INIT:
    {

      ControllerCache.init();


      ControllerCache.setPeekFilePos(
        P146_TASKVALUE_FILENR,
        P146_TASKVALUE_FILEPOS);
      success = initPluginTaskData(
        event->TaskIndex,
        new (std::nothrow) P146_data_struct(event));
      break;
    }

    case PLUGIN_READ:
    {
      if (ControllerCache.peekDataAvailable()) {
        Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + P146_MINIMAL_SEND_INTERVAL);

        if (P146_GET_SEND_BULK) {
          if (P146_GET_SEND_BINARY) {
            P146_data_struct::prepare_BulkMQTT_message(event->TaskIndex);
          } else {
            P146_data_struct *P146_data = static_cast<P146_data_struct *>(getPluginTaskData(event->TaskIndex));

            if (nullptr != P146_data) {
              const char separator = static_cast<char>(P146_SEPARATOR_CHARACTER);
              P146_data->prepareCSVInBulk(event->TaskIndex, P146_GET_JOIN_TIMESTAMP, P146_GET_ONLY_SET_TASKS, separator);
            }
          }
        } else {


          if (P146_data_struct::sendViaOriginalTask(event->TaskIndex, P146_GET_SEND_TIMESTAMP)) {
            int readFileNr = 0;
            const int readPos = ControllerCache.getPeekFilePos(readFileNr);

            if (P146_GET_ERASE_BINFILES) {

              if (P146_TASKVALUE_FILENR != 0 && P146_TASKVALUE_FILENR < readFileNr) {
                ControllerCache.deleteCacheBlock(P146_TASKVALUE_FILENR);
              }
            }

            P146_SET_TASKVALUE_FILENR(readFileNr);
            P146_SET_TASKVALUE_FILEPOS(readPos);
          }
        }
      } else {

        Scheduler.schedule_task_device_timer(event->TaskIndex, millis() + 1000);
      }

      break;
    }

    case PLUGIN_PROCESS_CONTROLLER_DATA:
    {
      if (P146_GET_SEND_BULK) {
        P146_data_struct *P146_data = static_cast<P146_data_struct *>(getPluginTaskData(event->TaskIndex));

        if (nullptr != P146_data) {
          bool data_sent = false;

          if (P146_GET_SEND_BINARY) {
            data_sent = (0 != P146_data->sendBinaryInBulk(event->TaskIndex, P146_MQTT_MESSAGE_LENGTH));
          } else {
            data_sent = (0 != P146_data->sendCSVInBulk(event->TaskIndex, P146_MQTT_MESSAGE_LENGTH));
          }

          if (data_sent) {
            int readFileNr = 0;
            const int readPos = ControllerCache.getPeekFilePos(readFileNr);

            if (P146_GET_ERASE_BINFILES) {

              const int filenr = P146_TASKVALUE_FILENR;
              if (filenr != 0 && filenr < readFileNr) {
                ControllerCache.deleteCacheBlock(filenr);
              }
            }

            P146_SET_TASKVALUE_FILENR(readFileNr);
            P146_SET_TASKVALUE_FILEPOS(readPos);
          }
          success = true;
        }
      }

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormCheckBox(F("Delete Cache Files After Send"), F("deletebin"), P146_GET_ERASE_BINFILES);
      addFormSubHeader(F("MQTT Output Options"));
      addFormCheckBox(F("Send Bulk"), F("sendbulk"), P146_GET_SEND_BULK);
      addFormCheckBox(F("HEX encoded Binary"), F("binary"), P146_GET_SEND_BINARY);


      addFormNumericBox(F("Minimal Send Interval"), F("minsendinterval"), P146_MINIMAL_SEND_INTERVAL, 0, 1000);
      addFormNumericBox(F("Max Message Size"),
                        F("maxmsgsize"),
                        P146_MQTT_MESSAGE_LENGTH,
                        sizeof(C016_binary_element) + 16,
                        32768);

      String strings[P146_Nlines];
      LoadCustomTaskSettings(event->TaskIndex, strings, P146_Nlines, 0);
      addFormTextBox(F("TaskInfo Topic"), getPluginCustomArgName(P146_TaskInfoTopicIndex), strings[P146_TaskInfoTopicIndex], P146_Nchars);
      addFormTextBox(F("Publish Topic"), getPluginCustomArgName(P146_PublishTopicIndex), strings[P146_PublishTopicIndex], P146_Nchars);





      addTableSeparator(F("Export to CSV"), 2, 3);

      {
        const __FlashStringHelper *separatorLabels[] = {
          F("Tab"),
          F("Comma"),
          F("Semicolon")
        };
        const int separatorOptions[] = {
          '\t',
          ',',
          ';'
        };
        addFormSelector(F("Separator"), F("separator"), 3, separatorLabels, separatorOptions, P146_SEPARATOR_CHARACTER);
      }
      addFormCheckBox(F("Join Samples with same Timestamp"), F("jointimestamp"), P146_GET_JOIN_TIMESTAMP);
      addFormCheckBox(F("Export only enabled tasks"), F("onlysettasks"), P146_GET_ONLY_SET_TASKS);

      addFormNote(F("Download button link only updated after saving"));

      addRowLabel(EMPTY_STRING);
      html_add_button_prefix();
      addHtml(F("dumpcache?separator="));

      switch (static_cast<char>(P146_SEPARATOR_CHARACTER)) {
        case '\t': addHtml(F("Tab")); break;
        case ',': addHtml(F("Comma")); break;
        case ';':
        default: addHtml(F("Semicolon")); break;
      }

      if (P146_GET_JOIN_TIMESTAMP) {
        addHtml(F("&jointimestamp=1"));
      }

      if (P146_GET_ONLY_SET_TASKS) {
        addHtml(F("&onlysettasks=1"));
      }
      addHtml(F("'>Download as CSV</a>"));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P146_SET_ERASE_BINFILES(isFormItemChecked(F("deletebin")));
      P146_SET_SEND_BULK(isFormItemChecked(F("sendbulk")));
      P146_SET_SEND_BINARY(isFormItemChecked(F("binary")));




      P146_MINIMAL_SEND_INTERVAL = getFormItemInt(F("minsendinterval"));
      P146_MQTT_MESSAGE_LENGTH = getFormItemInt(F("maxmsgsize"));

      P146_SET_JOIN_TIMESTAMP(isFormItemChecked(F("jointimestamp")));
      P146_SET_ONLY_SET_TASKS(isFormItemChecked(F("onlysettasks")));
      P146_SEPARATOR_CHARACTER = getFormItemInt(F("separator"));

      String strings[P146_Nlines];
      String error;

      for (uint8_t varNr = 0; varNr < P146_Nlines; varNr++) {
        strings[varNr] = webArg(getPluginCustomArgName(varNr));
      }

      error = SaveCustomTaskSettings(event->TaskIndex, strings, P146_Nlines, 0);

      if (!error.isEmpty()) {
        addHtmlError(error);
      }


      success = true;
      break;
    }

    case PLUGIN_WRITE:
    {
      const String command = parseString(string, 1);
      const String subcommand = parseString(string, 2);

      if (equals(command, F("cachereader"))) {
        if (equals(subcommand, F("setreadpos"))) {
          P146_data_struct::setPeekFilePos(event->Par2, event->Par3);
          success = true;
        } else if (equals(subcommand, F("sendtaskinfo"))) {
          P146_data_struct *P146_data = static_cast<P146_data_struct *>(getPluginTaskData(event->TaskIndex));

          if (nullptr != P146_data) {
            P146_data->sendTaskInfoInBulk(event);
            success = true;
          }
        } else if (equals(subcommand, F("flush"))) {
          P146_data_struct::flush();
          success = true;
        }
      }
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P147_SGP4x.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P147
# 37 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P147_SGP4x.ino"
#define PLUGIN_147 
#define PLUGIN_ID_147 147
#define PLUGIN_NAME_147 "Gases - SGP4x VOC(/NOx)"
#define PLUGIN_VALUENAME1_147 "VOC"
#define PLUGIN_VALUENAME2_147 "NOx"

# include "./src/PluginStructs/P147_data_struct.h"

boolean Plugin_147(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_147;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_147);

      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_147));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_147));

      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P147_SENSOR_TYPE == static_cast<int>(P147_sensor_e::SGP41) ? 2 : 1;
      success = true;
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    {
      success = event->Par1 == P147_I2C_ADDRESS;
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P147_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      ExtraTaskSettings.TaskDeviceValueDecimals[0] = 0;
      ExtraTaskSettings.TaskDeviceValueDecimals[1] = 0;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      {
        const __FlashStringHelper *sensorTypes[] = {
          F("SGP40"),
          F("SGP41"),
        };
        const int sensorTypeOptions[] = {
          static_cast<int>(P147_sensor_e::SGP40),
          static_cast<int>(P147_sensor_e::SGP41),
        };
        addFormSelector(F("Sensor model"), F("ptype"), 2, sensorTypes, sensorTypeOptions, P147_SENSOR_TYPE, true);
        addFormNote(F("Page will reload on change."));
      }

      addFormSelector_YesNo(F("Use Compensation"), F("comp"), P147_GET_USE_COMPENSATION, true);
      addFormNote(F("Page will reload on change."));

      if (P147_GET_USE_COMPENSATION) {
        addRowLabel(F("Temperature Task"));
        addTaskSelect(F("ttask"), P147_TEMPERATURE_TASK);

        if (validTaskIndex(P147_TEMPERATURE_TASK)) {
          addRowLabel(F("Temperature Value"));
          addTaskValueSelect(F("tvalue"), P147_TEMPERATURE_VALUE, P147_TEMPERATURE_TASK);
        }

        addRowLabel(F("Humidity Task"));
        addTaskSelect(F("htask"), P147_HUMIDITY_TASK);

        if (validTaskIndex(P147_HUMIDITY_TASK)) {
          addRowLabel(F("Humidity Value"));
          addTaskValueSelect(F("hvalue"), P147_HUMIDITY_VALUE, P147_HUMIDITY_TASK);
        }
      }

      addFormSeparator(2);

      addFormCheckBox(F("Low-power measurement"), F("plow"), P147_LOW_POWER_MEASURE == 1);
      addFormNote(F("Unchecked= 1 sec., continuous heating, Checked= 10 sec. measurement interval."));

      # if P147_FEATURE_GASINDEXALGORITHM
      addFormCheckBox(F("Show raw data only"), F("raw"), P147_GET_RAW_DATA_ONLY);
      # endif

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      int prevSensor = P147_SENSOR_TYPE;
      P147_SENSOR_TYPE = getFormItemInt(F("ptype"));
      P147_LOW_POWER_MEASURE = isFormItemChecked(F("plow")) ? 1 : 0;
      P147_SET_USE_COMPENSATION(getFormItemInt(F("comp")));
      # if P147_FEATURE_GASINDEXALGORITHM
      P147_SET_RAW_DATA_ONLY(isFormItemChecked(F("raw")));
      # endif

      if (P147_GET_USE_COMPENSATION) {
        P147_TEMPERATURE_TASK = getFormItemInt(F("ttask"));
        P147_TEMPERATURE_VALUE = getFormItemInt(F("tvalue"));
        P147_HUMIDITY_TASK = getFormItemInt(F("htask"));
        P147_HUMIDITY_VALUE = getFormItemInt(F("hvalue"));
      }

      if ((prevSensor != P147_SENSOR_TYPE) && (P147_SENSOR_TYPE == static_cast<int>(P147_sensor_e::SGP41))) {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_147));
        ExtraTaskSettings.TaskDeviceValueDecimals[1] = 0;
      }
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P147_data_struct(event));
      P147_data_struct *P147_data = static_cast<P147_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P147_data) && P147_data->init(event);

      break;
    }

    case PLUGIN_TASKTIMER_IN:
    {
      P147_data_struct *P147_data = static_cast<P147_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P147_data) {
        success = P147_data->plugin_tasktimer_in(event);
      }

      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P147_data_struct *P147_data = static_cast<P147_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P147_data) {
        success = P147_data->plugin_once_a_second(event);
      }

      break;
    }

    case PLUGIN_READ:
    {
      P147_data_struct *P147_data = static_cast<P147_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P147_data) {
        success = P147_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_WRITE:
    {
      P147_data_struct *P147_data = static_cast<P147_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P147_data) {
        success = P147_data->plugin_write(event, string);
      }

      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      P147_data_struct *P147_data = static_cast<P147_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P147_data) {
        success = P147_data->plugin_get_config_value(event, string);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P148_POWRxxD_THR3xxD.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P148







#define PLUGIN_148 
#define PLUGIN_ID_148 148
#define PLUGIN_NAME_148 "Display - POWR3xxD/THR3xxD"


#define P148_DEVICE_SELECTOR PCONFIG(0)
#define P148_GPIO_TM1621_DAT CONFIG_PIN1
#define P148_GPIO_TM1621_WR CONFIG_PIN2
#define P148_GPIO_TM1621_RD CONFIG_PIN3
#define P148_GPIO_TM1621_CS CONFIG_PORT

#define P148_FIRST_PAGE_ROW_INDEX 2
#define P148_NR_PAGE_ROW_INDICES 6
#define P148_MAX_PAGE_ROW_INDEX (P148_FIRST_PAGE_ROW_INDEX + P148_NR_PAGE_ROW_INDICES)
#define P148_PAGE1_ROW1_TASK PCONFIG(P148_FIRST_PAGE_ROW_INDEX)
#define P148_PAGE1_ROW2_TASK PCONFIG(3)
#define P148_PAGE2_ROW1_TASK PCONFIG(4)
#define P148_PAGE2_ROW2_TASK PCONFIG(5)
#define P148_PAGE3_ROW1_TASK PCONFIG(6)
#define P148_PAGE3_ROW2_TASK PCONFIG(7)


# include "src/PluginStructs/P148_data_struct.h"

boolean Plugin_148(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_148;
      Device[deviceCount].Type = DEVICE_TYPE_CUSTOM0;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_NONE;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = false;
      Device[deviceCount].ValueCount = 0;
      Device[deviceCount].SendDataOption = false;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_148);
      break;
    }

    case PLUGIN_WEBFORM_SHOW_GPIO_DESCR:
    {
      const __FlashStringHelper *labels[] = {
        F("DAT"), F("WR"), F("RD"), F("CS")
      };
      int values[] = {
        P148_GPIO_TM1621_DAT,
        P148_GPIO_TM1621_WR,
        P148_GPIO_TM1621_RD,
        P148_GPIO_TM1621_CS
      };
      constexpr size_t nrElements = NR_ELEMENTS(values);

      for (size_t i = 0; i < nrElements; ++i) {
        if (i != 0) { addHtml(event->String1); }
        addHtml(labels[i]);
        addHtml(F(":&nbsp;"));
        addHtml(formatGpioLabel(values[i], true));
      }
      success = true;
      break;
    }

    case PLUGIN_SET_DEFAULTS:
    {
      P148_DEVICE_SELECTOR = 0;
      P148_GPIO_TM1621_DAT = -1;
      P148_GPIO_TM1621_CS = -1;
      P148_GPIO_TM1621_WR = -1;
      P148_GPIO_TM1621_RD = -1;
      P148_data_struct::MonitorTaskValue_t MonitorTaskValue;

      for (int i = P148_FIRST_PAGE_ROW_INDEX; i < P148_MAX_PAGE_ROW_INDEX; ++i) {
        PCONFIG(i) = MonitorTaskValue.getPconfigValue();
      }

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {

      addFormPinSelect(PinSelectPurpose::Generic_output,
                       formatGpioName_output(F("TM1621 DAT")),
                       F("taskdevicepin1"),
                       P148_GPIO_TM1621_DAT);
      addFormPinSelect(PinSelectPurpose::Generic_output,
                       formatGpioName_output(F("TM1621 WR")),
                       F("taskdevicepin2"),
                       P148_GPIO_TM1621_WR);
      addFormPinSelect(PinSelectPurpose::Generic_output,
                       formatGpioName_output(F("TM1621 RD")),
                       F("taskdevicepin3"),
                       P148_GPIO_TM1621_RD);
      addFormPinSelect(PinSelectPurpose::Generic_output,
                       formatGpioName_output(F("TM1621 CS")),
                       F("TDP"),
                       P148_GPIO_TM1621_CS);

      {
        const __FlashStringHelper *options[] = { F("Custom"), F("Sonoff POWR3xxD"), F("Sonoff THR3xxD") };
        int optionValues[] {
          static_cast<int>(P148_data_struct::Tm1621Device::USER),
          static_cast<int>(P148_data_struct::Tm1621Device::POWR3xxD),
          static_cast<int>(P148_data_struct::Tm1621Device::THR3xxD)
        };
        constexpr size_t nrElements = NR_ELEMENTS(optionValues);

        addFormSelector(F("Device Template"), F("devtmpl"), nrElements, options, optionValues, P148_DEVICE_SELECTOR);
        addFormNote(F("GPIO settings will be ignored when selecting other than 'Custom'"));
      }

      addFormSubHeader(F("Display Values"));

      for (int i = P148_FIRST_PAGE_ROW_INDEX; i < P148_MAX_PAGE_ROW_INDEX; ++i) {
        if ((i % 2 == 0) && (i != P148_FIRST_PAGE_ROW_INDEX)) {
          addFormSeparator(2);
        }

        P148_data_struct::MonitorTaskValue_t MonitorTaskValue(PCONFIG(i));
        MonitorTaskValue.webformLoad(i);
      }


      html_TR_TD();

      addHtml(F("<label class='nosave'>&nbsp;<input "));
      addHtmlAttribute(F("type"), F("checkbox"));
      addHtmlAttribute(F("id"), F("nosave"));
      addHtmlAttribute(F("name"), F("nosave"));
      addHtmlAttribute(F("style"), F("display:none"));
      addHtml(F("><span class='checkmark'></span></label>"));

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P148_DEVICE_SELECTOR = getFormItemInt(F("devtmpl"));

      switch (static_cast<P148_data_struct::Tm1621Device>(P148_DEVICE_SELECTOR)) {
        case P148_data_struct::Tm1621Device::USER:


          P148_GPIO_TM1621_DAT = getFormItemInt(F("taskdevicepin1"));
          P148_GPIO_TM1621_WR = getFormItemInt(F("taskdevicepin2"));
          P148_GPIO_TM1621_RD = getFormItemInt(F("taskdevicepin3"));
          P148_GPIO_TM1621_CS = getFormItemInt(F("TDP"));
          break;
        case P148_data_struct::Tm1621Device::POWR3xxD:
          P148_GPIO_TM1621_DAT = 14;
          P148_GPIO_TM1621_WR = 27;
          P148_GPIO_TM1621_RD = 26;
          P148_GPIO_TM1621_CS = 25;
          break;
        case P148_data_struct::Tm1621Device::THR3xxD:
          P148_GPIO_TM1621_DAT = 5;
          P148_GPIO_TM1621_WR = 18;
          P148_GPIO_TM1621_RD = 23;
          P148_GPIO_TM1621_CS = 17;
          break;
      }

      for (int i = P148_FIRST_PAGE_ROW_INDEX; i < P148_MAX_PAGE_ROW_INDEX; ++i) {
        P148_data_struct::MonitorTaskValue_t MonitorTaskValue(PCONFIG(i));
        PCONFIG(i) = MonitorTaskValue.webformSave(i);
      }

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      P148_data_struct::Tm1621_t config;
      config.pin_da = P148_GPIO_TM1621_DAT;
      config.pin_wr = P148_GPIO_TM1621_WR;
      config.pin_rd = P148_GPIO_TM1621_RD;
      config.pin_cs = P148_GPIO_TM1621_CS;
      config.device = static_cast<P148_data_struct::Tm1621Device>(P148_DEVICE_SELECTOR);
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P148_data_struct(config));
      P148_data_struct *P148_data =
        static_cast<P148_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P148_data) {
        if (P148_data->init()) {
          for (int i = P148_FIRST_PAGE_ROW_INDEX; i < P148_MAX_PAGE_ROW_INDEX; ++i) {
            P148_data->MonitorTaskValues[i - P148_FIRST_PAGE_ROW_INDEX] = P148_data_struct::MonitorTaskValue_t(PCONFIG(i));
          }

          P148_data->writeStrings(F("ESP"), F("Easy"));
          success = true;
        }
      }
      break;
    }

    case PLUGIN_READ:
    {
      P148_data_struct *P148_data =
        static_cast<P148_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P148_data) {
        P148_data->showPage();
      }
      break;
    }

    case PLUGIN_WRITE:
    {
      P148_data_struct *P148_data =
        static_cast<P148_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P148_data) {
        success = P148_data->plugin_write(event, string);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P150_TMP117.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P150
# 19 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P150_TMP117.ino"
# include "src/PluginStructs/P150_data_struct.h"

#define PLUGIN_150 
#define PLUGIN_ID_150 150
#define PLUGIN_NAME_150 "Environment - TMP117 Temperature"
#define PLUGIN_VALUENAME1_150 "Temperature"
#define PLUGIN_VALUENAME2_150 "Raw"

boolean Plugin_150(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_150;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_150);

      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_150));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_150));

      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P150_GET_OPT_ENABLE_RAW ? 2 : 1;
      success = true;

      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = P150_GET_OPT_ENABLE_RAW ? Sensor_VType::SENSOR_TYPE_DUAL : Sensor_VType::SENSOR_TYPE_SINGLE;
      event->idx = P150_GET_OPT_ENABLE_RAW ? 2 : 1;
      success = true;

      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x48, 0x49, 0x4A, 0x4B };

      if (PLUGIN_WEBFORM_SHOW_I2C_PARAMS == function) {
        addFormSelectorI2C(F("i2c_addr"), 4, i2cAddressValues, P150_I2C_ADDRESS);
      } else {
        success = intArrayContains(4, i2cAddressValues, event->Par1);
      }

      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P150_I2C_ADDRESS;
      success = true;

      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      P150_SET_CONF_AVERAGING(P150_AVERAGING_8_SAMPLES);
      P150_SET_CONF_CONVERSION_MODE(P150_CONVERSION_CONTINUOUS);
      P150_SET_CONF_CYCLE_BITS(P150_CYCLE_1_SEC);
      P150_SET_OPT_ENABLE_RAW(1);
      P150_SET_OPT_ENABLE_LOG(1);
      ExtraTaskSettings.TaskDeviceValueDecimals[1] = 0;

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Temperature offset"), F("offset"), P150_TEMPERATURE_OFFSET);
      addUnit(F("x 0.1C"));
      addFormNote(F("Offset in units of 0.1 degree Celsius!"));

      {
        const __FlashStringHelper *averagingCaptions[] = {
          F("No averaging"),
          F("8 sample average"),
          F("32 sample average"),
          F("64 sample average"),
        };
        const int averagingOptions[] = {
          P150_AVERAGING_NONE,
          P150_AVERAGING_8_SAMPLES,
          P150_AVERAGING_32_SAMPLES,
          P150_AVERAGING_64_SAMPLES,
        };
        addFormSelector(F("Averaging"), F("avg"), 4, averagingCaptions, averagingOptions, P150_GET_CONF_AVERAGING);
      }

      {
        const __FlashStringHelper *conversionCaptions[] = {
          F("Continuous"),
          F("One-shot"),
        };
        const int conversionOptions[] = {
          P150_CONVERSION_CONTINUOUS,
          P150_CONVERSION_ONE_SHOT,
        };
        addFormSelector(F("Conversion mode"), F("conv"), 2, conversionCaptions, conversionOptions, P150_GET_CONF_CONVERSION_MODE, true);
        addFormNote(F("Changing this setting will save and reload this page."));
      }

      if (P150_GET_CONF_CONVERSION_MODE == P150_CONVERSION_CONTINUOUS) {
        const __FlashStringHelper *cycleCaptions[] = {
          F("15.5 msec"),
          F("125 msec"),
          F("250 msec"),
          F("500 msec"),
          F("1 sec"),
          F("4 sec"),
          F("8 sec"),
          F("16 sec"),
        };
        const int cycleOptions[] = {
          P150_CYCLE_15_5_MSEC,
          P150_CYCLE_125_MSEC,
          P150_CYCLE_250_MSEC,
          P150_CYCLE_500_MSEC,
          P150_CYCLE_1_SEC,
          P150_CYCLE_4_SEC,
          P150_CYCLE_8_SEC,
          P150_CYCLE_16_SEC,
        };
        addFormSelector(F("Continuous conversion cycle time"), F("cycle"), 8, cycleCaptions, cycleOptions, P150_GET_CONF_CYCLE_BITS);
      }

      addFormSubHeader(F("Output"));

      addFormSelector_YesNo(F("Enable 'Raw' value"), F("raw"), P150_GET_OPT_ENABLE_RAW ? 1 : 0, true);
      addFormNote(F("Changing this setting will save and reload this page."));

      addFormCheckBox(F("Log measured values (INFO)"), F("log"), P150_GET_OPT_ENABLE_LOG);

      # if P150_USE_EXTRA_LOG
      addFormCheckBox(F("Log low-level values (INFO)"), F("xlog"), P150_GET_OPT_EXTRA_LOG);
      # endif

      success = true;

      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P150_I2C_ADDRESS = getFormItemInt(F("i2c_addr"));
      P150_TEMPERATURE_OFFSET = getFormItemInt(F("offset"));
      P150_SET_CONF_AVERAGING(getFormItemInt(F("avg")));
      uint8_t prvConv = P150_GET_CONF_CONVERSION_MODE;
      P150_SET_CONF_CONVERSION_MODE(getFormItemInt(F("conv")));

      if ((P150_GET_CONF_CONVERSION_MODE == P150_CONVERSION_CONTINUOUS) && (prvConv == P150_CONVERSION_CONTINUOUS)) {
        P150_SET_CONF_CYCLE_BITS(getFormItemInt(F("cycle")));
      } else {
        P150_SET_CONF_CYCLE_BITS(P150_CYCLE_1_SEC);
      }

      uint8_t raw = getFormItemInt(F("raw"));

      if (P150_GET_OPT_ENABLE_RAW != raw) {
        if (raw) {
          strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_150));
          ExtraTaskSettings.TaskDeviceValueDecimals[1] = 0;
        }
        P150_SET_OPT_ENABLE_RAW(raw);
      }
      P150_SET_OPT_ENABLE_LOG(isFormItemChecked(F("log")));
      # if P150_USE_EXTRA_LOG
      P150_SET_OPT_EXTRA_LOG(isFormItemChecked(F("xlog")));
      # endif

      success = true;

      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P150_data_struct(event));
      P150_data_struct *P150_data =
        static_cast<P150_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P150_data && P150_data->init());

      break;
    }

    case PLUGIN_READ:
    {
      P150_data_struct *P150_data =
        static_cast<P150_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P150_data) {
        success = P150_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P150_data_struct *P150_data =
        static_cast<P150_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P150_data) {
        success = P150_data->plugin_once_a_second(event);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P151_Honeywell_pressure.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P151






#define PLUGIN_151 
#define PLUGIN_ID_151 151
#define PLUGIN_NAME_151 "Environment - I2C Honeywell Pressure"
#define PLUGIN_VALUENAME1_151 "Pressure"
#define PLUGIN_VALUENAME2_151 "Temperature"

# include "./src/PluginStructs/P151_data_struct.h"

boolean Plugin_151(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_151;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_DUAL;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_151);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_151));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_151));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
# 67 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P151_Honeywell_pressure.ino"
      const uint8_t i2cAddressValues[] = {
        0x28 ,
        0x38 ,
        0x48 ,
        0x58 ,
        0x68 ,
        0x78 ,
        0x88 ,
        0x98
      };
      constexpr size_t addrCount = sizeof(i2cAddressValues) / sizeof(uint8_t);

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("pi2c"), addrCount, i2cAddressValues, P151_I2C_ADDR);
      } else {
        success = intArrayContains(addrCount, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P151_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      P151_I2C_ADDR = 0x28;

      P151_OUTPUT_MAX = 14745;
      P151_OUTPUT_MIN = 1638;
      P151_PRESSURE_MAX = 1;
      P151_PRESSURE_MIN = 0;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormNumericBox(F("Sensor Output Min"), F("out_min"), P151_OUTPUT_MIN, 0, (1 << 14) - 1);
      addFormNumericBox(F("Sensor Output Max"), F("out_max"), P151_OUTPUT_MAX, 0, (1 << 14) - 1);
      addFormFloatNumberBox(F("Pressure Min"), F("p_min"),
                            P151_PRESSURE_MIN, P151_MIN_PRESSURE_VALUE, 0.0f, 3);
      addFormFloatNumberBox(F("Pressure Max"), F("p_max"),
                            P151_PRESSURE_MAX, 0.0f, P151_MAX_PRESSURE_VALUE, 3);
      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P151_I2C_ADDR = getFormItemInt(F("pi2c"));
      P151_OUTPUT_MIN = getFormItemInt(F("out_min"));
      P151_OUTPUT_MAX = getFormItemInt(F("out_max"));
      P151_PRESSURE_MIN = getFormItemFloat(F("p_min"));
      P151_PRESSURE_MAX = getFormItemFloat(F("p_max"));

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P151_data_struct());
      break;
    }

    case PLUGIN_READ:
    {
      P151_data_struct *P151_data = static_cast<P151_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P151_data) {
        success = P151_data->fetch_last_sample(event);
      }

      break;
    }

    case PLUGIN_ONCE_A_SECOND:
    {
      P151_data_struct *P151_data = static_cast<P151_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P151_data) {
        success = P151_data->plugin_read(event);
      }

      break;
    }
# 181 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P151_Honeywell_pressure.ino"
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P152_DAC.ino"
#ifdef USES_P152
# 14 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P152_DAC.ino"
#include "_Plugin_Helper.h"

#define PLUGIN_152 
#define PLUGIN_ID_152 152
#define PLUGIN_NAME_152 "Output - ESP32 DAC"
#define PLUGIN_VALUENAME1_152 "Output"

#define P152_DAC_VALUE UserVar[event->BaseVarIndex]
#define P152_SET_DAC_VALUE(x) UserVar.setFloat(event->TaskIndex, 0, x)

#if !(defined(ESP32_CLASSIC) || defined(ESP32S2))
# error P152 ESP32 DAC not supported on this CPU type!
#endif

boolean Plugin_152(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_152;
      Device[deviceCount].Type = DEVICE_TYPE_SINGLE;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].Custom = true;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 1;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_152);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_152));
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addRowLabel(F("Analog Output"));
      addDAC_PinSelect(F("taskdevicepin1"), CONFIG_PIN1);

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      int dac;

      success = getDAC_gpio_info(CONFIG_PIN1, dac);
      break;
    }

    case PLUGIN_READ:
    {
      success = true;
      break;
    }

    case PLUGIN_WRITE:
    {
      const String command = parseString(string, 1);


      if (equals(command, F("dac"))) {
        int dac;

        if (getDAC_gpio_info(CONFIG_PIN1, dac) && (dac == event->Par1)) {
          int value = min(255, max(0, event->Par2));
          P152_SET_DAC_VALUE(value);
          dacWrite(CONFIG_PIN1, value);
          addLog(LOG_LEVEL_INFO,
                 formatGpioName_DAC(CONFIG_PIN1) +
                 concat(F(" : Output: "), value));

          success = true;
        }
      }
      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      int dac;

      if (getDAC_gpio_info(CONFIG_PIN1, dac)) {
        string += formatGpioName_DAC(CONFIG_PIN1);
        success = true;
      }
      break;
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P153_SHT4x.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P153
# 26 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P153_SHT4x.ino"
#define PLUGIN_153 
#define PLUGIN_ID_153 153
#define PLUGIN_NAME_153 "Environment - SHT4x"
#define PLUGIN_VALUENAME1_153 "Temperature"
#define PLUGIN_VALUENAME2_153 "Humidity"

# include "./src/PluginStructs/P153_data_struct.h"

bool P153_CheckIntervalError(struct EventStruct *event, int interval) {
  bool result = false;
  P153_configuration_e conf = static_cast<P153_configuration_e>(P153_STARTUP_CONFIGURATION);

  if (((P153_configuration_e::HighResolution200mW1000msec == conf) ||
       (P153_configuration_e::HighResolution110mW1000msec == conf) ||
       (P153_configuration_e::HighResolution20mW1000msec == conf))
      && (interval <= 10)) {
    result = true;
  }
  return result;
}

boolean Plugin_153(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  const __FlashStringHelper *_intervalError = F("Interval must be increased or Heater duration decreased!");

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_153;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_HUM;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_153);

      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_153));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_153));

      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x44, 0x45, 0x46 };

      if (PLUGIN_WEBFORM_SHOW_I2C_PARAMS == function) {
        addFormSelectorI2C(F("i2c_addr"), 3, i2cAddressValues, P153_I2C_ADDRESS);
        addFormNote(F("Chip type determines address: SHT-4x-<b>A</b>xxx = 0x44, SHT-4x-<b>B</b>xxx = 0x45, SHT-4x-<b>C</b>xxx = 0x46"));
      } else {
        success = intArrayContains(3, i2cAddressValues, event->Par1);
      }

      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P153_I2C_ADDRESS;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      P153_STARTUP_CONFIGURATION = static_cast<int>(P153_configuration_e::HighResolution);
      P153_NORMAL_CONFIGURATION = static_cast<int>(P153_configuration_e::HighResolution);
      P153_INTERVAL_LOOPS = 0;

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormTextBox(F("Temperature offset"), F("tempoffset"), toString(P153_TEMPERATURE_OFFSET, 2), 5);
      addUnit(F("&deg;C"));

      {
        const __FlashStringHelper *configurations[] = {
          F("Low resolution"),
          F("Medium resolution"),
          F("High resolution"),
          F("High res., Heater 200 mWatt for 1 sec."),
          F("High res., Heater 200 mWatt for 0.1 sec."),
          F("High res., Heater 110 mWatt for 1 sec."),
          F("High res., Heater 110 mWatt for 0.1 sec."),
          F("High res., Heater 20 mWatt for 1 sec."),
          F("High res., Heater 20 mWatt for 0.1 sec."),
        };
        const int configurationOptions[] = {
          static_cast<int>(P153_configuration_e::LowResolution),
          static_cast<int>(P153_configuration_e::MediumResolution),
          static_cast<int>(P153_configuration_e::HighResolution),
          static_cast<int>(P153_configuration_e::HighResolution200mW1000msec),
          static_cast<int>(P153_configuration_e::HighResolution200mW100msec),
          static_cast<int>(P153_configuration_e::HighResolution110mW1000msec),
          static_cast<int>(P153_configuration_e::HighResolution110mW100msec),
          static_cast<int>(P153_configuration_e::HighResolution20mW1000msec),
          static_cast<int>(P153_configuration_e::HighResolution20mW100msec),
        };
        addFormSelector(F("Startup Configuration"),
                        F("startup"),
                        sizeof(configurationOptions) / sizeof(configurationOptions[0]),
                        configurations,
                        configurationOptions,
                        P153_STARTUP_CONFIGURATION);
        addFormNote(F("Heater should not exceed 10% dutycycle, so 1 sec. heater must have Interval > 10 sec.!"));

        addFormNumericBox(F("Use Normal Configuration after"), F("loops"), P153_INTERVAL_LOOPS, 0, 10);
        addUnit(F("Interval runs (0..10)"));

        addFormSelector(F("Normal Configuration"),
                        F("normal"),
                        3,
                        configurations,
                        configurationOptions,
                        P153_NORMAL_CONFIGURATION);
      }

      success = true;
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P153_I2C_ADDRESS = getFormItemInt(F("i2c_addr"));
      P153_TEMPERATURE_OFFSET = getFormItemFloat(F("tempoffset"));
      P153_STARTUP_CONFIGURATION = getFormItemInt(F("startup"));
      P153_INTERVAL_LOOPS = getFormItemInt(F("loops"));
      P153_NORMAL_CONFIGURATION = getFormItemInt(F("normal"));

      int interval = getFormItemInt(F("TDT"));

      if (P153_CheckIntervalError(event, interval)) {
        addHtmlError(_intervalError);
      }

      success = true;
      break;
    }

    case PLUGIN_INIT:
    {
      int interval = Settings.TaskDeviceTimer[event->TaskIndex];

      if (!P153_CheckIntervalError(event, interval)) {
        initPluginTaskData(event->TaskIndex, new (std::nothrow) P153_data_struct(P153_I2C_ADDRESS,
                                                                                 P153_TEMPERATURE_OFFSET,
                                                                                 static_cast<P153_configuration_e>(P153_STARTUP_CONFIGURATION),
                                                                                 static_cast<P153_configuration_e>(P153_NORMAL_CONFIGURATION),
                                                                                 P153_INTERVAL_LOOPS));
        P153_data_struct *P153_data = static_cast<P153_data_struct *>(getPluginTaskData(event->TaskIndex));

        success = (nullptr != P153_data) && P153_data->init();
      } else {
        addLog(LOG_LEVEL_ERROR, concat(F("SHT4x: "), _intervalError));
      }

      break;
    }

    case PLUGIN_READ:
    {
      P153_data_struct *P153_data = static_cast<P153_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P153_data) {
        success = P153_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_WRITE:
    {
      P153_data_struct *P153_data = static_cast<P153_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P153_data) {
        success = P153_data->plugin_write(event, string);
      }

      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      P153_data_struct *P153_data = static_cast<P153_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P153_data) {
        success = P153_data->plugin_get_config_value(event, string);
      }

      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P154_BMP3xx.ino"
#include "_Plugin_Helper.h"
#ifdef USES_P154





# include "src/PluginStructs/P154_data_struct.h"

#define PLUGIN_154 
#define PLUGIN_ID_154 154
#define PLUGIN_NAME_154 "Environment - BMP3xx"
#define PLUGIN_VALUENAME1_154 "Temperature"
#define PLUGIN_VALUENAME2_154 "Pressure"

boolean Plugin_154(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {
      Device[++deviceCount].Number = PLUGIN_ID_154;
      Device[deviceCount].Type = DEVICE_TYPE_I2C;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_TEMP_BARO;
      Device[deviceCount].Ports = 0;
      Device[deviceCount].PullUpOption = false;
      Device[deviceCount].InverseLogicOption = false;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].ValueCount = 2;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].PluginStats = true;
      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_154);
      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_154));
      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_154));
      break;
    }

    case PLUGIN_I2C_HAS_ADDRESS:
    case PLUGIN_WEBFORM_SHOW_I2C_PARAMS:
    {
      const uint8_t i2cAddressValues[] = { 0x76, 0x77 };
      constexpr int nrAddressOptions = NR_ELEMENTS(i2cAddressValues);

      if (function == PLUGIN_WEBFORM_SHOW_I2C_PARAMS) {
        addFormSelectorI2C(F("i2c_addr"), nrAddressOptions, i2cAddressValues, P154_I2C_ADDR);
        addFormNote(F("SDO Low=0x76, High=0x77"));
      } else {
        success = intArrayContains(nrAddressOptions, i2cAddressValues, event->Par1);
      }
      break;
    }

    # if FEATURE_I2C_GET_ADDRESS
    case PLUGIN_I2C_GET_ADDRESS:
    {
      event->Par1 = P154_I2C_ADDR;
      success = true;
      break;
    }
    # endif

    case PLUGIN_SET_DEFAULTS:
    {
      P154_I2C_ADDR = 0x77;
      break;
    }

    case PLUGIN_INIT:
    {
      initPluginTaskData(event->TaskIndex, new (std::nothrow) P154_data_struct(event));
      P154_data_struct *P154_data =
        static_cast<P154_data_struct *>(getPluginTaskData(event->TaskIndex));

      success = (nullptr != P154_data && P154_data->begin());
      break;
    }

    case PLUGIN_READ:
    {
      P154_data_struct *P154_data =
        static_cast<P154_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr == P154_data) {
        break;
      }

      float temp, pressure{};

      success = P154_data->read(temp, pressure);
      UserVar.setFloat(event->TaskIndex, 0, temp);
      UserVar.setFloat(event->TaskIndex, 1, pressure);
      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      success = P154_data_struct::webformLoad(event);
      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      success = P154_data_struct::webformSave(event);
      break;
    }
  }
  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P159_LD2410.ino"
#include "_Plugin_Helper.h"
# 58 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_P159_LD2410.ino"
#ifdef USES_P159
# include "src/PluginStructs/P159_data_struct.h"


#define PLUGIN_159 
#define PLUGIN_ID_159 159
#define PLUGIN_NAME_159 "Presence - LD2410"


boolean Plugin_159(uint8_t function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
    {


      Device[++deviceCount].Number = PLUGIN_ID_159;
      Device[deviceCount].Type = DEVICE_TYPE_SERIAL;
      Device[deviceCount].VType = Sensor_VType::SENSOR_TYPE_SINGLE;
      Device[deviceCount].ValueCount = 4;
      Device[deviceCount].OutputDataType = Output_Data_type_t::Simple;
      Device[deviceCount].FormulaOption = true;
      Device[deviceCount].SendDataOption = true;
      Device[deviceCount].GlobalSyncOption = true;
      Device[deviceCount].TimerOption = true;
      Device[deviceCount].TimerOptional = true;
      Device[deviceCount].PluginStats = true;
      Device[deviceCount].ExitTaskBeforeSave = false;

      break;
    }

    case PLUGIN_GET_DEVICENAME:
    {
      string = F(PLUGIN_NAME_159);

      break;
    }

    case PLUGIN_GET_DEVICEVALUENAMES:
    {
      const int valueCount = P159_NR_OUTPUT_VALUES;

      for (uint8_t i = 0; i < VARS_PER_TASK; ++i) {
        if (i < valueCount) {
          const uint8_t pconfigIndex = i + P159_QUERY1_CONFIG_POS;
          const uint8_t option = PCONFIG(pconfigIndex);

          if ((option >= P159_OUTPUT_STATIC_DISTANCE_ENERGY_GATE0) && (option <= P159_OUTPUT_STATIC_DISTANCE_ENERGY_GATE8)) {
            ExtraTaskSettings.setTaskDeviceValueName(i, concat(Plugin_159_valuename(P159_OUTPUT_STATIC_DISTANCE_GATE_index, false),
                                                               option - P159_OUTPUT_STATIC_DISTANCE_ENERGY_GATE0));
          } else
          if ((option >= P159_OUTPUT_MOVING_DISTANCE_ENERGY_GATE0) && (option <= P159_OUTPUT_MOVING_DISTANCE_ENERGY_GATE8)) {
            ExtraTaskSettings.setTaskDeviceValueName(i, concat(Plugin_159_valuename(P159_OUTPUT_MOVING_DISTANCE_GATE_index, false),
                                                               option - P159_OUTPUT_MOVING_DISTANCE_ENERGY_GATE0));
          } else {
            ExtraTaskSettings.setTaskDeviceValueName(i, Plugin_159_valuename(option, false));
          }
          ExtraTaskSettings.TaskDeviceValueDecimals[i] = 0;
        } else {
          ExtraTaskSettings.clearTaskDeviceValueName(i);
        }
      }

      break;
    }

    case PLUGIN_GET_DEVICEGPIONAMES:
    {
      serialHelper_getGpioNames(event);

      break;
    }

    case PLUGIN_WEBFORM_SHOW_CONFIG:
    {
      string += serialHelper_getSerialTypeLabel(event);

      success = true;

      break;
    }

    case PLUGIN_GET_DEVICEVALUECOUNT:
    {
      event->Par1 = P159_NR_OUTPUT_VALUES;

      success = true;

      break;
    }

    case PLUGIN_GET_DEVICEVTYPE:
    {
      event->sensorType = static_cast<Sensor_VType>(PCONFIG(P159_SENSOR_TYPE_INDEX));
      event->idx = P159_SENSOR_TYPE_INDEX;

      success = true;

      break;
    }


    case PLUGIN_SET_DEFAULTS:
    {
      PCONFIG(0) = P159_OUTPUT_PRESENCE;
      PCONFIG(1) = P159_OUTPUT_DISTANCE;
      PCONFIG(2) = P159_OUTPUT_STATIONARY_ENERGY;
      PCONFIG(3) = P159_OUTPUT_MOVING_ENERGY;

      PCONFIG(P159_SENSOR_TYPE_INDEX) = static_cast<uint8_t>(Sensor_VType::SENSOR_TYPE_QUAD);

      success = true;

      break;
    }

    case PLUGIN_WEBFORM_LOAD_OUTPUT_SELECTOR:
    {
      const uint8_t optionCount = P159_GET_ENGINEERING_MODE == 1 ? P159_NR_ENGINEERING_OUTPUT_OPTIONS : P159_NR_OUTPUT_OPTIONS;
      String options[optionCount];

      for (uint8_t option = 0; option < optionCount; ++option) {
        if ((option >= P159_OUTPUT_STATIC_DISTANCE_ENERGY_GATE0) && (option <= P159_OUTPUT_STATIC_DISTANCE_ENERGY_GATE8)) {
          options[option] = concat(Plugin_159_valuename(P159_OUTPUT_STATIC_DISTANCE_GATE_index, true),
                                   option - P159_OUTPUT_STATIC_DISTANCE_ENERGY_GATE0);
        } else
        if ((option >= P159_OUTPUT_MOVING_DISTANCE_ENERGY_GATE0) && (option <= P159_OUTPUT_MOVING_DISTANCE_ENERGY_GATE8)) {
          options[option] = concat(Plugin_159_valuename(P159_OUTPUT_MOVING_DISTANCE_GATE_index, true),
                                   option - P159_OUTPUT_MOVING_DISTANCE_ENERGY_GATE0);
        } else {
          options[option] = Plugin_159_valuename(option, true);
        }
      }

      const int valueCount = P159_NR_OUTPUT_VALUES;

      for (uint8_t i = 0; i < valueCount; ++i) {
        const uint8_t pconfigIndex = i + P159_QUERY1_CONFIG_POS;
        sensorTypeHelper_loadOutputSelector(event, pconfigIndex, i, optionCount, options);
      }

      success = true;

      break;
    }

    case PLUGIN_WEBFORM_LOAD:
    {
      addFormSelector_YesNo(F("Engineering mode"), F("eng"), P159_GET_ENGINEERING_MODE, true);
      addFormNote(F("When changing this setting the page will be reloaded"));

      addFormCheckBox(F("Generate Events only when changed"), F("diff"), P159_GET_UPDATE_DIFF_ONLY);

      success = true;

      P159_data_struct *P159_data = static_cast<P159_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P159_data) {
        addFormSubHeader(F("Sensitivity settings"));
        success = P159_data->plugin_webform_load(event);
      }

      break;
    }

    case PLUGIN_WEBFORM_SAVE:
    {
      P159_SET_ENGINEERING_MODE(getFormItemInt(F("eng")));
      P159_SET_UPDATE_DIFF_ONLY(isFormItemChecked(F("diff")));

      P159_data_struct *P159_data = static_cast<P159_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P159_data) {
        P159_data->plugin_webform_save(event);
      }

      success = true;

      break;
    }
    case PLUGIN_INIT:
    {
      int8_t rxPin = serialHelper_getRxPin(event);
      int8_t txPin = serialHelper_getTxPin(event);
      ESPEasySerialPort portType = serialHelper_getSerialType(event);


      success = initPluginTaskData(event->TaskIndex, new (std::nothrow) P159_data_struct(portType,
                                                                               rxPin,
                                                                               txPin,
                                                                               P159_GET_ENGINEERING_MODE == 1));
      addLog(LOG_LEVEL_INFO, concat(F("P159 : INIT, success: "), success ? 1 : 0));

      break;
    }

    case PLUGIN_READ:
    {
      P159_data_struct *P159_data = static_cast<P159_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P159_data) {
        success = P159_data->plugin_read(event);
      }

      break;
    }

    case PLUGIN_WRITE:
    {
      P159_data_struct *P159_data = static_cast<P159_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P159_data) {
        success = P159_data->plugin_write(event, string);
      }

      break;
    }

    case PLUGIN_GET_CONFIG_VALUE:
    {
      P159_data_struct *P159_data = static_cast<P159_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P159_data) {
        success = P159_data->plugin_get_config_value(event, string);
      }

      break;
    }

    case PLUGIN_EXIT:
    {
      P159_data_struct *P159_data = static_cast<P159_data_struct *>(getPluginTaskData(event->TaskIndex));

      if (nullptr != P159_data) {
        P159_data->disconnectSerial();
      }

      success = true;

      break;
    }

    case PLUGIN_TEN_PER_SECOND:
    {
      P159_data_struct *P159_data = static_cast<P159_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P159_data) && !P159_data->isRunning()) {
        success = P159_data->processSensor(event);
      }

      break;
    }
    case PLUGIN_FIFTY_PER_SECOND:
    {
      P159_data_struct *P159_data = static_cast<P159_data_struct *>(getPluginTaskData(event->TaskIndex));

      if ((nullptr != P159_data) && P159_data->isRunning()) {
        success = P159_data->processSensor(event);
      }

      break;
    }
  }

  return success;
}

#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_Pxxx_PluginTemplate.ino"
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_Reporting.ino"


#if defined(FEATURE_REPORTING) && FEATURE_REPORTING


#include <ArduinoJson.h>



#define REPORT_HOST "espeasy.datux.nl"
#define FEATURE_REPORTING 1

void ReportStatus()
{
  String log;
  String host = F(REPORT_HOST);

  log = F("REP  : Reporting status to ");
  log += host;
  addLog(LOG_LEVEL_INFO, log);


  WiFiClient client;

#ifdef MUSTFIX_CLIENT_TIMEOUT_IN_SECONDS


  client.setTimeout((CONTROLLER_CLIENTTIMEOUT_MAX + 500) / 1000);
  Client *pClient = &client;
  pClient->setTimeout(CONTROLLER_CLIENTTIMEOUT_MAX);
#else
  client.setTimeout(CONTROLLER_CLIENTTIMEOUT_MAX);
#endif

  if (!connectClient(client, host.c_str(), 80, CONTROLLER_CLIENTTIMEOUT_MAX))
  {
    addLog(LOG_LEVEL_ERROR, F("REP  : connection failed"));
    return;
  }

  StaticJsonBuffer<256> jsonBuffer;
  JsonObject& root = jsonBuffer.createObject();

  root[F("chipId")] = ESP.getChipId();
  root[F("flashId")] = ESP.getFlashChipId();
  root[F("uptime")] = getUptimeMinutes();


  String body;
  root.printTo(body);

  String payload = F("POST /report.php HTTP/1.1");
  addNewLine(payload);
  payload += F("Host: ");
  payload += host;
  addNewLine(payload);
  payload += F("Connection: close");
  addNewLine(payload);
  payload += F("Content-Length: ");
  payload += String(body.length());
  addNewLine(payload);
  addNewLine(payload);
  payload += body;

  serialPrintln(payload);
  client.print(payload);


  addLog(LOG_LEVEL_INFO, F("REP  : report uploaded"));
}
# 106 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/_Reporting.ino"
#endif
# 1 "/Users/mgtn/Library/Mobile Documents/com~apple~CloudDocs/Documents/IoT/PlatformIO/Projects/ESPEasy/src/__ReleaseNotes.ino"